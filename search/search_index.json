{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"","title":"About"},{"location":"test/","text":"Terminal Here's an interactive terminal with full Linux commands: (function() { setTimeout(function() { const container = document.querySelector('.terminal-content'); if (!container || typeof Terminal === 'undefined') { console.error('Terminal setup failed'); return; } const term = new Terminal({ cursorBlink: true, fontSize: 15, fontFamily: '\"Fira Code\", \"Cascadia Code\", \"JetBrains Mono\", Consolas, Monaco, monospace', fontWeight: 400, fontWeightBold: 700, lineHeight: 1.2, letterSpacing: 0, theme: { background: '#1e1e1e', foreground: '#cccccc', cursor: '#00ff00', cursorAccent: '#1e1e1e', selection: '#264f78', black: '#000000', red: '#cd3131', green: '#0dbc79', yellow: '#e5e510', blue: '#2472c8', magenta: '#bc3fbc', cyan: '#11a8cd', white: '#e5e5e5', brightBlack: '#666666', brightRed: '#f14c4c', brightGreen: '#23d18b', brightYellow: '#f5f543', brightBlue: '#3b8eea', brightMagenta: '#d670d6', brightCyan: '#29b8db', brightWhite: '#ffffff' }, allowTransparency: true }); term.open(container); // Enhanced file system let fileSystem = { '/': { 'home': { 'user': { 'documents': { 'notes.txt': 'These are my personal notes.\\nRemember to study for the exam!', 'todo.txt': '1. Finish homework\\n2. Practice CTF\\n3. Read security blog' }, 'projects': { 'cybersec': { 'README.md': '# CyberSec Project\\n\\nThis is a cybersecurity learning project.', 'exploit.py': '#!/usr/bin/env python3\\nprint(\"Hello, hacker!\")' }, 'web': { 'index.html': '<html><body>Hello World</body></html>' } }, 'scripts': { 'hello.sh': '#!/bin/bash\\necho \"Hello, World!\"' } } }, 'etc': { 'hosts': '127.0.0.1 localhost\\n::1 localhost', 'passwd': 'root:x:0:0:root:/root:/bin/bash\\nuser:x:1000:1000::/home/user:/bin/bash' }, 'var': { 'log': { 'syslog': 'System log entries...' } }, 'tmp': {} } }; let currentPath = '/home/user'; let currentLine = ''; let commandHistory = []; let historyIndex = -1; let vimMode = false; let vimBuffer = []; let vimCurrentLine = 0; let vimFilename = ''; let vimInsertMode = false; let vimCommandMode = false; let vimCommandLine = ''; term.writeln('\\x1b[1;32m\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\x1b[0m'); term.writeln('\\x1b[1;32m\u2551 Welcome to Interactive Terminal Demo \u2551\\x1b[0m'); term.writeln('\\x1b[1;32m\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\x1b[0m'); term.writeln(''); term.writeln('Type \\x1b[1;36mhelp\\x1b[0m for available commands.'); term.writeln(''); writePrompt(); function writePrompt() { term.write(`\\x1b[1;32muser@nchscyber\\x1b[0m:\\x1b[1;34m${currentPath}\\x1b[0m$ `); } function getObjectAtPath(path) { if (path === '/') return fileSystem['/']; const parts = path.split('/').filter(p => p); let current = fileSystem['/']; for (const part of parts) { if (!current || current[part] === undefined) { return null; } current = current[part]; } return current; } function resolvePath(path) { if (path.startsWith('/')) { return path; } if (path === '~') { return '/home/user'; } if (path.startsWith('~/')) { return '/home/user/' + path.substring(2); } let result = currentPath; const parts = path.split('/'); for (const part of parts) { if (part === '..') { const segments = result.split('/').filter(p => p); segments.pop(); result = '/' + segments.join('/'); if (result === '/') result = '/'; } else if (part === '.' || part === '') { continue; } else { result = result + (result.endsWith('/') ? '' : '/') + part; } } return result; } function isDirectory(obj) { return obj !== null && typeof obj === 'object' && !Array.isArray(obj); } function processCommand(cmd) { // Handle pipes if (cmd.includes('|')) { const parts = cmd.split('|').map(p => p.trim()); let output = null; for (let i = 0; i < parts.length; i++) { if (i === 0) { output = executeCommand(parts[i]); } else { output = executeCommand(parts[i], output); } } return; } // Handle output redirection if (cmd.includes('>')) { const parts = cmd.split('>').map(p => p.trim()); const output = executeCommand(parts[0]); if (output && parts[1]) { const filepath = resolvePath(parts[1]); const pathParts = filepath.split('/').filter(p => p); const filename = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && isDirectory(dir)) { dir[filename] = output.join('\\n'); term.writeln(`\\x1b[32mOutput written to ${parts[1]}\\x1b[0m`); } else { term.writeln(`\\x1b[31mError: Directory not found\\x1b[0m`); } } return; } executeCommand(cmd); } function executeCommand(cmd, pipeInput = null) { const parts = cmd.split(' ').filter(p => p); const command = parts[0]; const args = parts.slice(1); const commands = { 'help': () => { const output = [ '\\x1b[1;33mAvailable Commands:\\x1b[0m', ' \\x1b[36mhelp\\x1b[0m - Show this help message', ' \\x1b[36mclear\\x1b[0m - Clear the terminal screen', ' \\x1b[36mecho\\x1b[0m - Print text to terminal', ' \\x1b[36mdate\\x1b[0m - Show current date and time', ' \\x1b[36mpwd\\x1b[0m - Print working directory', ' \\x1b[36mls\\x1b[0m - List directory contents', ' \\x1b[36mcd\\x1b[0m - Change directory', ' \\x1b[36mmkdir\\x1b[0m - Create a new directory', ' \\x1b[36mrmdir\\x1b[0m - Remove empty directory', ' \\x1b[36mtouch\\x1b[0m - Create a new file', ' \\x1b[36mcat\\x1b[0m - Display file contents', ' \\x1b[36mrm\\x1b[0m - Remove file or directory', ' \\x1b[36mmv\\x1b[0m - Move/rename files', ' \\x1b[36mcp\\x1b[0m - Copy files', ' \\x1b[36mgrep\\x1b[0m - Search for patterns', ' \\x1b[36mfind\\x1b[0m - Find files', ' \\x1b[36mwhoami\\x1b[0m - Display current user', ' \\x1b[36muname\\x1b[0m - Display system information', ' \\x1b[36mvim\\x1b[0m - Text editor', '', '\\x1b[1;33mAdvanced:\\x1b[0m', ' Use \\x1b[36m|\\x1b[0m for pipes: ls | grep test', ' Use \\x1b[36m>\\x1b[0m for output: echo hello > file.txt' ]; output.forEach(line => term.writeln(line)); return output; }, 'clear': () => { term.clear(); return []; }, 'date': () => { const output = [new Date().toString()]; term.writeln(output[0]); return output; }, 'pwd': () => { const output = [currentPath]; term.writeln(output[0]); return output; }, 'whoami': () => { const output = ['user']; term.writeln(output[0]); return output; }, 'uname': () => { const output = args[0] === '-a' ? ['Linux nchscyber 5.15.0 #1 SMP x86_64 GNU/Linux'] : ['Linux']; term.writeln(output[0]); return output; }, 'ls': () => { const path = args[0] ? resolvePath(args[0]) : currentPath; const obj = getObjectAtPath(path); const output = []; if (!obj) { term.writeln(`\\x1b[31mls: ${args[0]}: No such file or directory\\x1b[0m`); return []; } if (!isDirectory(obj)) { term.writeln(`\\x1b[31mls: ${args[0]}: Not a directory\\x1b[0m`); return []; } const entries = Object.keys(obj); if (entries.length === 0) { return []; } entries.forEach(entry => { if (isDirectory(obj[entry])) { term.writeln(`\\x1b[1;34m${entry}/\\x1b[0m`); output.push(entry + '/'); } else { term.writeln(`\\x1b[37m${entry}\\x1b[0m`); output.push(entry); } }); return output; }, 'cd': () => { if (args.length === 0 || args[0] === '~') { currentPath = '/home/user'; return []; } const newPath = resolvePath(args[0]); const obj = getObjectAtPath(newPath); if (obj && isDirectory(obj)) { currentPath = newPath; } else { term.writeln(`\\x1b[31mcd: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'mkdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: mkdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && isDirectory(parent)) { if (parent[dirName]) { term.writeln(`\\x1b[31mmkdir: ${args[0]}: File exists\\x1b[0m`); } else { parent[dirName] = {}; term.writeln(`\\x1b[32mDirectory '${args[0]}' created\\x1b[0m`); } } else { term.writeln(`\\x1b[31mmkdir: cannot create directory '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'rmdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rmdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[dirName]) { if (isDirectory(parent[dirName])) { if (Object.keys(parent[dirName]).length === 0) { delete parent[dirName]; term.writeln(`\\x1b[32mDirectory '${args[0]}' removed\\x1b[0m`); } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Directory not empty\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Not a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'touch': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: touch <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && isDirectory(dir)) { dir[fileName] = dir[fileName] || ''; term.writeln(`\\x1b[32mFile '${args[0]}' created\\x1b[0m`); } else { term.writeln(`\\x1b[31mtouch: cannot touch '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'cat': () => { if (pipeInput !== null) { pipeInput.forEach(line => term.writeln(line)); return pipeInput; } if (args.length === 0) { term.writeln('\\x1b[31mUsage: cat <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { const output = dir[fileName].split('\\n'); output.forEach(line => term.writeln(line)); return output; } else { term.writeln(`\\x1b[31mcat: ${args[0]}: Is a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcat: ${args[0]}: No such file or directory\\x1b[0m`); } return []; }, 'rm': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const recursive = args[0] === '-r' || args[0] === '-rf'; const target = recursive ? args[1] : args[0]; if (!target) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const path = resolvePath(target); const pathParts = path.split('/').filter(p => p); const name = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[name] !== undefined) { if (isDirectory(parent[name]) && !recursive) { term.writeln(`\\x1b[31mrm: ${target}: is a directory (use -r to remove)\\x1b[0m`); } else { delete parent[name]; term.writeln(`\\x1b[32m'${target}' removed\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrm: ${target}: No such file or directory\\x1b[0m`); } return []; }, 'mv': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: mv <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { dstParent[dstName] = srcParent[srcName]; delete srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' moved to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mmv: cannot move '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'cp': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: cp <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { if (typeof srcParent[srcName] === 'string') { dstParent[dstName] = srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' copied to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mcp: ${args[0]}: Is a directory (directory copy not implemented)\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcp: cannot copy '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'grep': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: grep <pattern> [file] or <command> | grep <pattern>\\x1b[0m'); return []; } const pattern = args[0]; let searchLines = []; if (pipeInput !== null) { searchLines = pipeInput; } else if (args[1]) { const path = resolvePath(args[1]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && typeof dir[fileName] === 'string') { searchLines = dir[fileName].split('\\n'); } } const output = searchLines.filter(line => line.toLowerCase().includes(pattern.toLowerCase()) ); output.forEach(line => term.writeln(line)); return output; }, 'find': () => { const searchName = args[0] || ''; const output = []; function searchDir(path, obj) { if (!isDirectory(obj)) return; for (const [name, value] of Object.entries(obj)) { const fullPath = path + (path === '/' ? '' : '/') + name; if (name.includes(searchName)) { output.push(fullPath); term.writeln(fullPath); } if (isDirectory(value)) { searchDir(fullPath, value); } } } searchDir('/', fileSystem['/']); return output; }, 'echo': () => { const output = [args.join(' ')]; term.writeln(output[0]); return output; }, 'vim': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: vim <filename>\\x1b[0m'); return []; } vimFilename = args[0]; const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { vimBuffer = dir[fileName].split('\\n'); } else { term.writeln(`\\x1b[31mvim: ${vimFilename}: Is a directory\\x1b[0m`); return []; } } else { vimBuffer = ['']; } vimMode = true; vimInsertMode = false; vimCommandMode = false; vimCommandLine = ''; vimCurrentLine = 0; displayVim(); return []; } }; if (commands[command]) { return commands[command](); } else { term.writeln(`\\x1b[31m${command}: command not found\\x1b[0m`); return []; } } function displayVim() { term.clear(); vimBuffer.forEach((line, i) => { if (i === vimCurrentLine && !vimCommandMode) { term.writeln(`\\x1b[7m${line || ' '}\\x1b[0m`); } else { term.writeln(line); } }); term.write('\\r\\n'); const mode = vimInsertMode ? '-- INSERT --' : (vimCommandMode ? '' : '-- NORMAL --'); const status = `\\x1b[7m ${vimFilename} [${vimBuffer.length} lines] ${mode} \\x1b[0m`; term.writeln(status); if (!vimInsertMode && !vimCommandMode) { term.writeln('\\x1b[33m[i=insert, j/k=move, :w=save, :q=quit, :wq=save&quit]\\x1b[0m'); } if (vimCommandMode) { term.write(':' + vimCommandLine); } } function handleVimInput(key, domEvent) { if (vimCommandMode) { if (domEvent.key === 'Enter') { term.write('\\r\\n'); if (vimCommandLine === 'w' || vimCommandLine === 'wq') { const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir) { dir[fileName] = vimBuffer.join('\\n'); term.writeln(`\\x1b[32m\"${vimFilename}\" ${vimBuffer.length} lines written\\x1b[0m`); } } if (vimCommandLine === 'q' || vimCommandLine === 'wq' || vimCommandLine === 'q!') { vimMode = false; setTimeout(() => { term.clear(); writePrompt(); }, vimCommandLine === 'wq' ? 800 : 0); } else { setTimeout(() => displayVim(), 1000); } vimCommandMode = false; vimCommandLine = ''; } else if (domEvent.key === 'Escape') { vimCommandMode = false; vimCommandLine = ''; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimCommandLine.length > 0) { vimCommandLine = vimCommandLine.slice(0, -1); displayVim(); } } else if (key.length === 1) { vimCommandLine += key; displayVim(); } } else if (!vimInsertMode) { if (key === 'i') { vimInsertMode = true; displayVim(); } else if (key === 'j' && vimCurrentLine < vimBuffer.length - 1) { vimCurrentLine++; displayVim(); } else if (key === 'k' && vimCurrentLine > 0) { vimCurrentLine--; displayVim(); } else if (key === ':') { vimCommandMode = true; displayVim(); } } else { if (domEvent.key === 'Escape') { vimInsertMode = false; displayVim(); } else if (domEvent.key === 'Enter') { vimBuffer.splice(vimCurrentLine + 1, 0, ''); vimCurrentLine++; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimBuffer[vimCurrentLine].length > 0) { vimBuffer[vimCurrentLine] = vimBuffer[vimCurrentLine].slice(0, -1); } else if (vimCurrentLine > 0) { vimBuffer.splice(vimCurrentLine, 1); vimCurrentLine--; } displayVim(); } else if (key.length === 1) { vimBuffer[vimCurrentLine] = (vimBuffer[vimCurrentLine] || '') + key; displayVim(); } } } term.onKey(function(e) { if (vimMode) { handleVimInput(e.key, e.domEvent); return; } const ev = e.domEvent; const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey; if (ev.key === 'Enter') { term.write('\\r\\n'); if (currentLine.trim()) { commandHistory.push(currentLine.trim()); historyIndex = commandHistory.length; processCommand(currentLine.trim()); } currentLine = ''; if (!vimMode) { writePrompt(); } } else if (ev.key === 'Backspace') { if (currentLine.length > 0) { currentLine = currentLine.slice(0, -1); term.write('\\b \\b'); } } else if (ev.key === 'ArrowUp') { if (historyIndex > 0) { historyIndex--; replaceCurrentLine(commandHistory[historyIndex]); } } else if (ev.key === 'ArrowDown') { if (historyIndex < commandHistory.length - 1) { historyIndex++; replaceCurrentLine(commandHistory[historyIndex]); } else { historyIndex = commandHistory.length; replaceCurrentLine(''); } } else if (ev.key === 'Tab') { ev.preventDefault(); } else if (printable) { currentLine += e.key; term.write(e.key); } }); function replaceCurrentLine(newLine) { term.write('\\r'); writePrompt(); term.write(' '.repeat(currentLine.length)); term.write('\\r'); writePrompt(); currentLine = newLine; term.write(currentLine); } }, 100); })();","title":"Terminal"},{"location":"test/#terminal","text":"Here's an interactive terminal with full Linux commands: (function() { setTimeout(function() { const container = document.querySelector('.terminal-content'); if (!container || typeof Terminal === 'undefined') { console.error('Terminal setup failed'); return; } const term = new Terminal({ cursorBlink: true, fontSize: 15, fontFamily: '\"Fira Code\", \"Cascadia Code\", \"JetBrains Mono\", Consolas, Monaco, monospace', fontWeight: 400, fontWeightBold: 700, lineHeight: 1.2, letterSpacing: 0, theme: { background: '#1e1e1e', foreground: '#cccccc', cursor: '#00ff00', cursorAccent: '#1e1e1e', selection: '#264f78', black: '#000000', red: '#cd3131', green: '#0dbc79', yellow: '#e5e510', blue: '#2472c8', magenta: '#bc3fbc', cyan: '#11a8cd', white: '#e5e5e5', brightBlack: '#666666', brightRed: '#f14c4c', brightGreen: '#23d18b', brightYellow: '#f5f543', brightBlue: '#3b8eea', brightMagenta: '#d670d6', brightCyan: '#29b8db', brightWhite: '#ffffff' }, allowTransparency: true }); term.open(container); // Enhanced file system let fileSystem = { '/': { 'home': { 'user': { 'documents': { 'notes.txt': 'These are my personal notes.\\nRemember to study for the exam!', 'todo.txt': '1. Finish homework\\n2. Practice CTF\\n3. Read security blog' }, 'projects': { 'cybersec': { 'README.md': '# CyberSec Project\\n\\nThis is a cybersecurity learning project.', 'exploit.py': '#!/usr/bin/env python3\\nprint(\"Hello, hacker!\")' }, 'web': { 'index.html': '<html><body>Hello World</body></html>' } }, 'scripts': { 'hello.sh': '#!/bin/bash\\necho \"Hello, World!\"' } } }, 'etc': { 'hosts': '127.0.0.1 localhost\\n::1 localhost', 'passwd': 'root:x:0:0:root:/root:/bin/bash\\nuser:x:1000:1000::/home/user:/bin/bash' }, 'var': { 'log': { 'syslog': 'System log entries...' } }, 'tmp': {} } }; let currentPath = '/home/user'; let currentLine = ''; let commandHistory = []; let historyIndex = -1; let vimMode = false; let vimBuffer = []; let vimCurrentLine = 0; let vimFilename = ''; let vimInsertMode = false; let vimCommandMode = false; let vimCommandLine = ''; term.writeln('\\x1b[1;32m\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\x1b[0m'); term.writeln('\\x1b[1;32m\u2551 Welcome to Interactive Terminal Demo \u2551\\x1b[0m'); term.writeln('\\x1b[1;32m\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\x1b[0m'); term.writeln(''); term.writeln('Type \\x1b[1;36mhelp\\x1b[0m for available commands.'); term.writeln(''); writePrompt(); function writePrompt() { term.write(`\\x1b[1;32muser@nchscyber\\x1b[0m:\\x1b[1;34m${currentPath}\\x1b[0m$ `); } function getObjectAtPath(path) { if (path === '/') return fileSystem['/']; const parts = path.split('/').filter(p => p); let current = fileSystem['/']; for (const part of parts) { if (!current || current[part] === undefined) { return null; } current = current[part]; } return current; } function resolvePath(path) { if (path.startsWith('/')) { return path; } if (path === '~') { return '/home/user'; } if (path.startsWith('~/')) { return '/home/user/' + path.substring(2); } let result = currentPath; const parts = path.split('/'); for (const part of parts) { if (part === '..') { const segments = result.split('/').filter(p => p); segments.pop(); result = '/' + segments.join('/'); if (result === '/') result = '/'; } else if (part === '.' || part === '') { continue; } else { result = result + (result.endsWith('/') ? '' : '/') + part; } } return result; } function isDirectory(obj) { return obj !== null && typeof obj === 'object' && !Array.isArray(obj); } function processCommand(cmd) { // Handle pipes if (cmd.includes('|')) { const parts = cmd.split('|').map(p => p.trim()); let output = null; for (let i = 0; i < parts.length; i++) { if (i === 0) { output = executeCommand(parts[i]); } else { output = executeCommand(parts[i], output); } } return; } // Handle output redirection if (cmd.includes('>')) { const parts = cmd.split('>').map(p => p.trim()); const output = executeCommand(parts[0]); if (output && parts[1]) { const filepath = resolvePath(parts[1]); const pathParts = filepath.split('/').filter(p => p); const filename = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && isDirectory(dir)) { dir[filename] = output.join('\\n'); term.writeln(`\\x1b[32mOutput written to ${parts[1]}\\x1b[0m`); } else { term.writeln(`\\x1b[31mError: Directory not found\\x1b[0m`); } } return; } executeCommand(cmd); } function executeCommand(cmd, pipeInput = null) { const parts = cmd.split(' ').filter(p => p); const command = parts[0]; const args = parts.slice(1); const commands = { 'help': () => { const output = [ '\\x1b[1;33mAvailable Commands:\\x1b[0m', ' \\x1b[36mhelp\\x1b[0m - Show this help message', ' \\x1b[36mclear\\x1b[0m - Clear the terminal screen', ' \\x1b[36mecho\\x1b[0m - Print text to terminal', ' \\x1b[36mdate\\x1b[0m - Show current date and time', ' \\x1b[36mpwd\\x1b[0m - Print working directory', ' \\x1b[36mls\\x1b[0m - List directory contents', ' \\x1b[36mcd\\x1b[0m - Change directory', ' \\x1b[36mmkdir\\x1b[0m - Create a new directory', ' \\x1b[36mrmdir\\x1b[0m - Remove empty directory', ' \\x1b[36mtouch\\x1b[0m - Create a new file', ' \\x1b[36mcat\\x1b[0m - Display file contents', ' \\x1b[36mrm\\x1b[0m - Remove file or directory', ' \\x1b[36mmv\\x1b[0m - Move/rename files', ' \\x1b[36mcp\\x1b[0m - Copy files', ' \\x1b[36mgrep\\x1b[0m - Search for patterns', ' \\x1b[36mfind\\x1b[0m - Find files', ' \\x1b[36mwhoami\\x1b[0m - Display current user', ' \\x1b[36muname\\x1b[0m - Display system information', ' \\x1b[36mvim\\x1b[0m - Text editor', '', '\\x1b[1;33mAdvanced:\\x1b[0m', ' Use \\x1b[36m|\\x1b[0m for pipes: ls | grep test', ' Use \\x1b[36m>\\x1b[0m for output: echo hello > file.txt' ]; output.forEach(line => term.writeln(line)); return output; }, 'clear': () => { term.clear(); return []; }, 'date': () => { const output = [new Date().toString()]; term.writeln(output[0]); return output; }, 'pwd': () => { const output = [currentPath]; term.writeln(output[0]); return output; }, 'whoami': () => { const output = ['user']; term.writeln(output[0]); return output; }, 'uname': () => { const output = args[0] === '-a' ? ['Linux nchscyber 5.15.0 #1 SMP x86_64 GNU/Linux'] : ['Linux']; term.writeln(output[0]); return output; }, 'ls': () => { const path = args[0] ? resolvePath(args[0]) : currentPath; const obj = getObjectAtPath(path); const output = []; if (!obj) { term.writeln(`\\x1b[31mls: ${args[0]}: No such file or directory\\x1b[0m`); return []; } if (!isDirectory(obj)) { term.writeln(`\\x1b[31mls: ${args[0]}: Not a directory\\x1b[0m`); return []; } const entries = Object.keys(obj); if (entries.length === 0) { return []; } entries.forEach(entry => { if (isDirectory(obj[entry])) { term.writeln(`\\x1b[1;34m${entry}/\\x1b[0m`); output.push(entry + '/'); } else { term.writeln(`\\x1b[37m${entry}\\x1b[0m`); output.push(entry); } }); return output; }, 'cd': () => { if (args.length === 0 || args[0] === '~') { currentPath = '/home/user'; return []; } const newPath = resolvePath(args[0]); const obj = getObjectAtPath(newPath); if (obj && isDirectory(obj)) { currentPath = newPath; } else { term.writeln(`\\x1b[31mcd: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'mkdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: mkdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && isDirectory(parent)) { if (parent[dirName]) { term.writeln(`\\x1b[31mmkdir: ${args[0]}: File exists\\x1b[0m`); } else { parent[dirName] = {}; term.writeln(`\\x1b[32mDirectory '${args[0]}' created\\x1b[0m`); } } else { term.writeln(`\\x1b[31mmkdir: cannot create directory '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'rmdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rmdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[dirName]) { if (isDirectory(parent[dirName])) { if (Object.keys(parent[dirName]).length === 0) { delete parent[dirName]; term.writeln(`\\x1b[32mDirectory '${args[0]}' removed\\x1b[0m`); } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Directory not empty\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Not a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'touch': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: touch <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && isDirectory(dir)) { dir[fileName] = dir[fileName] || ''; term.writeln(`\\x1b[32mFile '${args[0]}' created\\x1b[0m`); } else { term.writeln(`\\x1b[31mtouch: cannot touch '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'cat': () => { if (pipeInput !== null) { pipeInput.forEach(line => term.writeln(line)); return pipeInput; } if (args.length === 0) { term.writeln('\\x1b[31mUsage: cat <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { const output = dir[fileName].split('\\n'); output.forEach(line => term.writeln(line)); return output; } else { term.writeln(`\\x1b[31mcat: ${args[0]}: Is a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcat: ${args[0]}: No such file or directory\\x1b[0m`); } return []; }, 'rm': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const recursive = args[0] === '-r' || args[0] === '-rf'; const target = recursive ? args[1] : args[0]; if (!target) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const path = resolvePath(target); const pathParts = path.split('/').filter(p => p); const name = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[name] !== undefined) { if (isDirectory(parent[name]) && !recursive) { term.writeln(`\\x1b[31mrm: ${target}: is a directory (use -r to remove)\\x1b[0m`); } else { delete parent[name]; term.writeln(`\\x1b[32m'${target}' removed\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrm: ${target}: No such file or directory\\x1b[0m`); } return []; }, 'mv': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: mv <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { dstParent[dstName] = srcParent[srcName]; delete srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' moved to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mmv: cannot move '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'cp': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: cp <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { if (typeof srcParent[srcName] === 'string') { dstParent[dstName] = srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' copied to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mcp: ${args[0]}: Is a directory (directory copy not implemented)\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcp: cannot copy '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'grep': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: grep <pattern> [file] or <command> | grep <pattern>\\x1b[0m'); return []; } const pattern = args[0]; let searchLines = []; if (pipeInput !== null) { searchLines = pipeInput; } else if (args[1]) { const path = resolvePath(args[1]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && typeof dir[fileName] === 'string') { searchLines = dir[fileName].split('\\n'); } } const output = searchLines.filter(line => line.toLowerCase().includes(pattern.toLowerCase()) ); output.forEach(line => term.writeln(line)); return output; }, 'find': () => { const searchName = args[0] || ''; const output = []; function searchDir(path, obj) { if (!isDirectory(obj)) return; for (const [name, value] of Object.entries(obj)) { const fullPath = path + (path === '/' ? '' : '/') + name; if (name.includes(searchName)) { output.push(fullPath); term.writeln(fullPath); } if (isDirectory(value)) { searchDir(fullPath, value); } } } searchDir('/', fileSystem['/']); return output; }, 'echo': () => { const output = [args.join(' ')]; term.writeln(output[0]); return output; }, 'vim': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: vim <filename>\\x1b[0m'); return []; } vimFilename = args[0]; const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { vimBuffer = dir[fileName].split('\\n'); } else { term.writeln(`\\x1b[31mvim: ${vimFilename}: Is a directory\\x1b[0m`); return []; } } else { vimBuffer = ['']; } vimMode = true; vimInsertMode = false; vimCommandMode = false; vimCommandLine = ''; vimCurrentLine = 0; displayVim(); return []; } }; if (commands[command]) { return commands[command](); } else { term.writeln(`\\x1b[31m${command}: command not found\\x1b[0m`); return []; } } function displayVim() { term.clear(); vimBuffer.forEach((line, i) => { if (i === vimCurrentLine && !vimCommandMode) { term.writeln(`\\x1b[7m${line || ' '}\\x1b[0m`); } else { term.writeln(line); } }); term.write('\\r\\n'); const mode = vimInsertMode ? '-- INSERT --' : (vimCommandMode ? '' : '-- NORMAL --'); const status = `\\x1b[7m ${vimFilename} [${vimBuffer.length} lines] ${mode} \\x1b[0m`; term.writeln(status); if (!vimInsertMode && !vimCommandMode) { term.writeln('\\x1b[33m[i=insert, j/k=move, :w=save, :q=quit, :wq=save&quit]\\x1b[0m'); } if (vimCommandMode) { term.write(':' + vimCommandLine); } } function handleVimInput(key, domEvent) { if (vimCommandMode) { if (domEvent.key === 'Enter') { term.write('\\r\\n'); if (vimCommandLine === 'w' || vimCommandLine === 'wq') { const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir) { dir[fileName] = vimBuffer.join('\\n'); term.writeln(`\\x1b[32m\"${vimFilename}\" ${vimBuffer.length} lines written\\x1b[0m`); } } if (vimCommandLine === 'q' || vimCommandLine === 'wq' || vimCommandLine === 'q!') { vimMode = false; setTimeout(() => { term.clear(); writePrompt(); }, vimCommandLine === 'wq' ? 800 : 0); } else { setTimeout(() => displayVim(), 1000); } vimCommandMode = false; vimCommandLine = ''; } else if (domEvent.key === 'Escape') { vimCommandMode = false; vimCommandLine = ''; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimCommandLine.length > 0) { vimCommandLine = vimCommandLine.slice(0, -1); displayVim(); } } else if (key.length === 1) { vimCommandLine += key; displayVim(); } } else if (!vimInsertMode) { if (key === 'i') { vimInsertMode = true; displayVim(); } else if (key === 'j' && vimCurrentLine < vimBuffer.length - 1) { vimCurrentLine++; displayVim(); } else if (key === 'k' && vimCurrentLine > 0) { vimCurrentLine--; displayVim(); } else if (key === ':') { vimCommandMode = true; displayVim(); } } else { if (domEvent.key === 'Escape') { vimInsertMode = false; displayVim(); } else if (domEvent.key === 'Enter') { vimBuffer.splice(vimCurrentLine + 1, 0, ''); vimCurrentLine++; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimBuffer[vimCurrentLine].length > 0) { vimBuffer[vimCurrentLine] = vimBuffer[vimCurrentLine].slice(0, -1); } else if (vimCurrentLine > 0) { vimBuffer.splice(vimCurrentLine, 1); vimCurrentLine--; } displayVim(); } else if (key.length === 1) { vimBuffer[vimCurrentLine] = (vimBuffer[vimCurrentLine] || '') + key; displayVim(); } } } term.onKey(function(e) { if (vimMode) { handleVimInput(e.key, e.domEvent); return; } const ev = e.domEvent; const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey; if (ev.key === 'Enter') { term.write('\\r\\n'); if (currentLine.trim()) { commandHistory.push(currentLine.trim()); historyIndex = commandHistory.length; processCommand(currentLine.trim()); } currentLine = ''; if (!vimMode) { writePrompt(); } } else if (ev.key === 'Backspace') { if (currentLine.length > 0) { currentLine = currentLine.slice(0, -1); term.write('\\b \\b'); } } else if (ev.key === 'ArrowUp') { if (historyIndex > 0) { historyIndex--; replaceCurrentLine(commandHistory[historyIndex]); } } else if (ev.key === 'ArrowDown') { if (historyIndex < commandHistory.length - 1) { historyIndex++; replaceCurrentLine(commandHistory[historyIndex]); } else { historyIndex = commandHistory.length; replaceCurrentLine(''); } } else if (ev.key === 'Tab') { ev.preventDefault(); } else if (printable) { currentLine += e.key; term.write(e.key); } }); function replaceCurrentLine(newLine) { term.write('\\r'); writePrompt(); term.write(' '.repeat(currentLine.length)); term.write('\\r'); writePrompt(); currentLine = newLine; term.write(currentLine); } }, 100); })();","title":"Terminal"},{"location":"unit1/","text":"UNIT 1: Introduction to Linux and the Field of Cybersecurity Welcome to Cybersecurity! This was the unit we covered in our early meetings, but essentially this unit covers the basics of what Cybersecurity is all about, and a little intro to how to setup linux for the future, so in later lessons we can start applying what we learn on our machines! :) To begin, let's move on to Lesson 1.1","title":"Overview"},{"location":"unit1/#unit-1-introduction-to-linux-and-the-field-of-cybersecurity","text":"Welcome to Cybersecurity! This was the unit we covered in our early meetings, but essentially this unit covers the basics of what Cybersecurity is all about, and a little intro to how to setup linux for the future, so in later lessons we can start applying what we learn on our machines! :) To begin, let's move on to Lesson 1.1","title":"UNIT 1: Introduction to Linux and the Field of Cybersecurity"},{"location":"unit2/","text":"","title":"Unit 2"},{"location":"unit3/","text":"","title":"Unit 3"},{"location":"LECTURES/unit1/installation-process/","text":"What is it? Kali is an operating system that was made specially for cybersecurity work (and hacking as well). It has a large toolkit of useful programs that we're going to learn about, including Hydra, Nmap, Wireshark, Tcpdump, MacChanger, Chisel, Aircrack-ng, etc. Some Vocab: As much as we know vocabulary might not be that interesting, it's important to know for the future, since there's a LOT of acronyms and words in cybersecurity that you're going to be hearing and using, so it's best to get used to it. Operating System (OS) : The main software that runs your computer, like Windows, macOS, iOS, GNU/Linux, etc. Virtual Machine (VM) : It's basically a computer inside another computer. You can run your regular OS, like Windows, and still have Kali Linux inside of it ISO File (International Organization for Standardization File) : Sounds fancy, but really it's just a full copy of an OS within one tiny file Hypervisor : Software that creates and manages VMs. Examples are VirtualBox and VMWare Workstation. There's also QEMU, but mostly Linux users use that, and you're likely running on Windows or mac Bootable USB : Just a USB drive (which you hopefully already know about) that can start up a computer and install an OS (we don't need this yet) Partitioning : A more advanced topic, but it's dividing up your drive into sections called partitions , which are like walls for a room. We don't need this yet, but it is good to know Now, let's get into the nitty-gritty: Method 1: Easy way :) Minimum Requirements*: 8 GB of RAM 20-30 GB of free hard drive space A decently fast CPU (you probably have this) *But, how do I know if I meet them? Well, you can press Ctrl+Shift+Esc on Windows and click on \"Performance\" inside of Task Manager, and it'll give you a spec (specifications) sheet. On mac, you can click on \"About\" in the top menu bar of your computer. On Linux, you can type uname -a , or use a custom program like fastfetch BIG DISCLAIMER FOR WINDOWS USERS: You NEED to DISABLE something called Hyper-V. If you don't know what that is, for Windows users, Hyper-V will conflict with Virtualbox, making it run poorly and crash often To check if you hve Hyper-V, press Win+R , and type optionalfeatures , then press Enter Look for a \"Hyper-V\" in the list of shown items. If it's checked, then it's enabled. Uncheck it. Alternative method: go to cmd (Command Prompt), and right click and \"Run as Administrator\". Then use the following command: bcdedit /set hypervisorlaunchtype off Finally, restart your computer BIG DISCLAIMER FOR MACOS USERS: You need to check if you're using an Intel-based Mac or Apple Silicon machine. If your device is M1, M2, M*, then it's Apple Silicon If this is the case, you will need to use a different software for virtualization. You have some options, like UTM or VMware Fusion . Also, you will have to install Kali Linux using the ARM64 version! Not x86-64! Now, go to virtualbox.org Click on the download for your OS, and install the program by following the instruction wizard. Now, go to the Kali Linux website . Download the \"Installer\" ISO file ( ~ 4 GB in size) Then choose the 64-bit version for modern computers. If your computer is old, it could be 32-bit. If so, you may need to check your system specifications as explained above. However, it probably isn't. Remember, Apple Silicon machines will install the ARM64 version of Kali Linux instead! Finally, make your Virtual Machine. Open up VirtualBox and click \"New\" Name it whatever, I'd call it \"Kali Linux\", or \"Kali Machine\". Type: Linux, Version: Debian (64-bit) Allocate at least 4 GB of RAM, AKA 4096 MB , by dragging the slider or typing in the number in the RAM text box Create a Virtual Hrd Disk (allocate 25-30 GB minimum) Choose VDI (VirtualBox Disk Image) Also select \"dynamically allocated\" to save space, and allows the VM to grow dynamically in storage size as you begin to add more things After clicking done, tell it to create, but do NOT tell it to also start yet Click on your virtual machine, and then go to settings Then go to Storage, and click the empty disk icon This is where we \"choose a disk file\", and select the downloaded Kali ISO Then under System, enable PAE/NX if available to you. PAE is Physical Address Extension, and NX is No Execute. These allow for > 4 GB of RAM access and prevents non-executable code from being executed in memory segments. If you don't know what that means, just ignore this Under Display, increase video memory to 128 MB Finally, save and exit Settings, and click on Start to boot your VM Select \"Graphical Install\" (press Enter, navigate using arrow keys) Choose your language, location, keyboard (these can later be changed, doesn't really matter) You can set a hostname, or keep the default (kali) IMPORTANT : username is kali and password is kali by default! Choose \"Guided - use entire disk\" for your partitioning Then select \"All files in one partition\" Confirm and wait a while. Take a walk outside, take a short nap, whatever you want. Just wait 10-20 minutes and it'll be done Restart when prompted On first login, enter the username and password Then, click the SUPER key ( Win key or Cmd key on mac) and type \"terminal\" or \"console\" into the search, and open the app In the terminal, you can type sudo apt update && sudo apt upgrade -y This command just updates your system When prompted with a password, type in your password Happy Linux! Method 2: Hard way (bare metal installation) Alright. You're ready for the real deal. No problem. WARNING! \u26a0\ufe0f\u26a0\ufe0f : This version of installation WILL take space on your disk! This means it will be physically installed, and it will NOT be installed as a VM! Just like Windows or macOS, it will be physically on your device. If you do this incorrectly, it may wipe your device completely . I'm not liable for if you mistakenly wipe your drive, it's up to you. Also, I personally do not recommend you install Kali Linux on a physical drive . If you want to use Linux for extra practice, install a distribution like Debian or Linux Mint . You are risking data loss if done incorrectly, so proceed at your own risk. Important things to note are: If you install on bare metal, AKA on your physical device, your device may have incompatibility issues. I would recommend doing your own research before doing so You may want to install Linux on a secondary drive, since if you use your main one, you will have to create a special partition for Linux to use exclusively, which is more difficult You'll need a USB drive with preferably 8 GB or more of storage You may need to adjust your BIOS (manufacturer specific, meaning it depends on what company made your computer and maybe even where you bought it from) to allow for other bootable devices, which can include removing Secure Boot There's some specifics for ARM64 machines like Apple Silicon that will be different! Overall, you are likely going to have to do your OWN research to make sure you don't mess anything up. Without further ado, these are some general instructions (not perfect): Create a bootable USB drive using an app like Balena Etcher or Rufus Make space on your hard drive by creating a disk partition of ~ 30 GB or more, or install on a secondary hard drive Boot from the USB drive from BIOS after restarting your computer and smashing the BIOS key as it boots up (typically Esc , F11 , F12 , or Del depending on the manufacturer) Follow the installation process, but make sure you select the right drive and if it's on the same disk as Windows or Mac, you install \"alongside\" it, not replace After going through the setup, you may re-enter the BIOS to change the boot order. What this means is move Linux above Windows so that on first boot you boot into Linux (optional) Some important extras: Make sure you regularly update your system at least weekly Make decent credentials or use a physical key Never just copy/paste a command without understanding it, look it up at least (even from me!) Install packages wisely and preferably from trusted sources Happy Linux! :)","title":"Linux Installation Process"},{"location":"LECTURES/unit1/installation-process/#what-is-it","text":"Kali is an operating system that was made specially for cybersecurity work (and hacking as well). It has a large toolkit of useful programs that we're going to learn about, including Hydra, Nmap, Wireshark, Tcpdump, MacChanger, Chisel, Aircrack-ng, etc.","title":"What is it?"},{"location":"LECTURES/unit1/installation-process/#some-vocab","text":"As much as we know vocabulary might not be that interesting, it's important to know for the future, since there's a LOT of acronyms and words in cybersecurity that you're going to be hearing and using, so it's best to get used to it. Operating System (OS) : The main software that runs your computer, like Windows, macOS, iOS, GNU/Linux, etc. Virtual Machine (VM) : It's basically a computer inside another computer. You can run your regular OS, like Windows, and still have Kali Linux inside of it ISO File (International Organization for Standardization File) : Sounds fancy, but really it's just a full copy of an OS within one tiny file Hypervisor : Software that creates and manages VMs. Examples are VirtualBox and VMWare Workstation. There's also QEMU, but mostly Linux users use that, and you're likely running on Windows or mac Bootable USB : Just a USB drive (which you hopefully already know about) that can start up a computer and install an OS (we don't need this yet) Partitioning : A more advanced topic, but it's dividing up your drive into sections called partitions , which are like walls for a room. We don't need this yet, but it is good to know Now, let's get into the nitty-gritty:","title":"Some Vocab:"},{"location":"LECTURES/unit1/installation-process/#method-1-easy-way","text":"","title":"Method 1: Easy way :)"},{"location":"LECTURES/unit1/installation-process/#minimum-requirements","text":"8 GB of RAM 20-30 GB of free hard drive space A decently fast CPU (you probably have this) *But, how do I know if I meet them? Well, you can press Ctrl+Shift+Esc on Windows and click on \"Performance\" inside of Task Manager, and it'll give you a spec (specifications) sheet. On mac, you can click on \"About\" in the top menu bar of your computer. On Linux, you can type uname -a , or use a custom program like fastfetch","title":"Minimum Requirements*:"},{"location":"LECTURES/unit1/installation-process/#big-disclaimer-for-windows-users","text":"You NEED to DISABLE something called Hyper-V. If you don't know what that is, for Windows users, Hyper-V will conflict with Virtualbox, making it run poorly and crash often To check if you hve Hyper-V, press Win+R , and type optionalfeatures , then press Enter Look for a \"Hyper-V\" in the list of shown items. If it's checked, then it's enabled. Uncheck it. Alternative method: go to cmd (Command Prompt), and right click and \"Run as Administrator\". Then use the following command: bcdedit /set hypervisorlaunchtype off Finally, restart your computer","title":"BIG DISCLAIMER FOR WINDOWS USERS:"},{"location":"LECTURES/unit1/installation-process/#big-disclaimer-for-macos-users","text":"You need to check if you're using an Intel-based Mac or Apple Silicon machine. If your device is M1, M2, M*, then it's Apple Silicon If this is the case, you will need to use a different software for virtualization. You have some options, like UTM or VMware Fusion . Also, you will have to install Kali Linux using the ARM64 version! Not x86-64! Now, go to virtualbox.org Click on the download for your OS, and install the program by following the instruction wizard. Now, go to the Kali Linux website . Download the \"Installer\" ISO file ( ~ 4 GB in size) Then choose the 64-bit version for modern computers. If your computer is old, it could be 32-bit. If so, you may need to check your system specifications as explained above. However, it probably isn't. Remember, Apple Silicon machines will install the ARM64 version of Kali Linux instead! Finally, make your Virtual Machine. Open up VirtualBox and click \"New\" Name it whatever, I'd call it \"Kali Linux\", or \"Kali Machine\". Type: Linux, Version: Debian (64-bit) Allocate at least 4 GB of RAM, AKA 4096 MB , by dragging the slider or typing in the number in the RAM text box Create a Virtual Hrd Disk (allocate 25-30 GB minimum) Choose VDI (VirtualBox Disk Image) Also select \"dynamically allocated\" to save space, and allows the VM to grow dynamically in storage size as you begin to add more things After clicking done, tell it to create, but do NOT tell it to also start yet Click on your virtual machine, and then go to settings Then go to Storage, and click the empty disk icon This is where we \"choose a disk file\", and select the downloaded Kali ISO Then under System, enable PAE/NX if available to you. PAE is Physical Address Extension, and NX is No Execute. These allow for > 4 GB of RAM access and prevents non-executable code from being executed in memory segments. If you don't know what that means, just ignore this Under Display, increase video memory to 128 MB Finally, save and exit Settings, and click on Start to boot your VM Select \"Graphical Install\" (press Enter, navigate using arrow keys) Choose your language, location, keyboard (these can later be changed, doesn't really matter) You can set a hostname, or keep the default (kali)","title":"BIG DISCLAIMER FOR MACOS USERS:"},{"location":"LECTURES/unit1/installation-process/#important-username-is-kali-and-password-is-kali-by-default","text":"Choose \"Guided - use entire disk\" for your partitioning Then select \"All files in one partition\" Confirm and wait a while. Take a walk outside, take a short nap, whatever you want. Just wait 10-20 minutes and it'll be done Restart when prompted On first login, enter the username and password Then, click the SUPER key ( Win key or Cmd key on mac) and type \"terminal\" or \"console\" into the search, and open the app In the terminal, you can type sudo apt update && sudo apt upgrade -y This command just updates your system When prompted with a password, type in your password Happy Linux!","title":"IMPORTANT: username is kali and password is kali by default!"},{"location":"LECTURES/unit1/installation-process/#method-2-hard-way-bare-metal-installation","text":"Alright. You're ready for the real deal. No problem. WARNING! \u26a0\ufe0f\u26a0\ufe0f : This version of installation WILL take space on your disk! This means it will be physically installed, and it will NOT be installed as a VM! Just like Windows or macOS, it will be physically on your device. If you do this incorrectly, it may wipe your device completely . I'm not liable for if you mistakenly wipe your drive, it's up to you. Also, I personally do not recommend you install Kali Linux on a physical drive . If you want to use Linux for extra practice, install a distribution like Debian or Linux Mint . You are risking data loss if done incorrectly, so proceed at your own risk. Important things to note are: If you install on bare metal, AKA on your physical device, your device may have incompatibility issues. I would recommend doing your own research before doing so You may want to install Linux on a secondary drive, since if you use your main one, you will have to create a special partition for Linux to use exclusively, which is more difficult You'll need a USB drive with preferably 8 GB or more of storage You may need to adjust your BIOS (manufacturer specific, meaning it depends on what company made your computer and maybe even where you bought it from) to allow for other bootable devices, which can include removing Secure Boot There's some specifics for ARM64 machines like Apple Silicon that will be different! Overall, you are likely going to have to do your OWN research to make sure you don't mess anything up. Without further ado, these are some general instructions (not perfect): Create a bootable USB drive using an app like Balena Etcher or Rufus Make space on your hard drive by creating a disk partition of ~ 30 GB or more, or install on a secondary hard drive Boot from the USB drive from BIOS after restarting your computer and smashing the BIOS key as it boots up (typically Esc , F11 , F12 , or Del depending on the manufacturer) Follow the installation process, but make sure you select the right drive and if it's on the same disk as Windows or Mac, you install \"alongside\" it, not replace After going through the setup, you may re-enter the BIOS to change the boot order. What this means is move Linux above Windows so that on first boot you boot into Linux (optional) Some important extras: Make sure you regularly update your system at least weekly Make decent credentials or use a physical key Never just copy/paste a command without understanding it, look it up at least (even from me!) Install packages wisely and preferably from trusted sources Happy Linux! :)","title":"Method 2: Hard way (bare metal installation)"},{"location":"LECTURES/unit1/lesson1-1/","text":"What do we know about Cybersecurity? Cybersecurity sounds like what it is exactly . Cyber, meaning digital, and security, meaning safety and protection. So digital protection/prevention/safety. But what does that really mean? Well you could say that cybersecurity is about how we can protect computers, servers, systems, etc. from digital attacks. These attacks oculd be viruses, worms, ransomware, etc. In order to keep sensitive data safe, we need to protect against the exploitation of security vulnerabilities. These are some cybersecurity goals: Identify and fix security vulnerabilities Prevent unauthorized access and data breaches Protect systems from malicious attacks Ensure integrity and availability of information Source: GeeksforGeeks","title":"Lesson 1.1"},{"location":"LECTURES/unit1/lesson1-1/#what-do-we-know-about-cybersecurity","text":"Cybersecurity sounds like what it is exactly . Cyber, meaning digital, and security, meaning safety and protection. So digital protection/prevention/safety. But what does that really mean? Well you could say that cybersecurity is about how we can protect computers, servers, systems, etc. from digital attacks. These attacks oculd be viruses, worms, ransomware, etc. In order to keep sensitive data safe, we need to protect against the exploitation of security vulnerabilities. These are some cybersecurity goals: Identify and fix security vulnerabilities Prevent unauthorized access and data breaches Protect systems from malicious attacks Ensure integrity and availability of information Source: GeeksforGeeks","title":"What do we know about Cybersecurity?"},{"location":"LECTURES/unit1/lesson1-2/","text":"Rings of Access Let's jump right into it! Protection rings are a hardware-level security feature on the CPU (Central Processing Unit) . When you think of CPU, think of that sticker you see on your laptop or PC that says Intel or AMD. That chip is a CPU, and it's in charge of managing important instructions on the computer. These \"rings\" determine the level of access from the operating system kernel (in this case the OS is Linux , which we'll talk about next lesson) to the user application. The most priviledged rings, where the most damage can be done the the most caution must be exercised, are the inner rings. The amount of priviledge provided grows as you approach the inner rings. The user typically resides in the outer most ring to do most of their applications. But with what we're going to be doing, we're going far deeper than the surface. The intermediate rings are for drivers to communicate between what the user does and what the kernel needs to do. What a kernel is is essentially just what controls the hardware itself at the lower level. Drivers are special software that translate a hardware device's instructions for the computer. For example, mouse movements, printers printing a document, graphics cards displaying something on screen, headphones or speakers, etc. The diagram below illustrates this: Source: Rings of Access Diagram But why this model? We use this to make sure when we run a command, we know how potentially impactful it could be. It prevents us from doing something not knowing it could destroy our system, and allows us to understand more intricately how the computer really is working. I know this doesn't sound like \"security\" yet, but we need to build our foundations first.","title":"Lesson 1.2"},{"location":"LECTURES/unit1/lesson1-2/#rings-of-access","text":"Let's jump right into it! Protection rings are a hardware-level security feature on the CPU (Central Processing Unit) . When you think of CPU, think of that sticker you see on your laptop or PC that says Intel or AMD. That chip is a CPU, and it's in charge of managing important instructions on the computer. These \"rings\" determine the level of access from the operating system kernel (in this case the OS is Linux , which we'll talk about next lesson) to the user application. The most priviledged rings, where the most damage can be done the the most caution must be exercised, are the inner rings. The amount of priviledge provided grows as you approach the inner rings. The user typically resides in the outer most ring to do most of their applications. But with what we're going to be doing, we're going far deeper than the surface. The intermediate rings are for drivers to communicate between what the user does and what the kernel needs to do. What a kernel is is essentially just what controls the hardware itself at the lower level. Drivers are special software that translate a hardware device's instructions for the computer. For example, mouse movements, printers printing a document, graphics cards displaying something on screen, headphones or speakers, etc. The diagram below illustrates this: Source: Rings of Access Diagram But why this model? We use this to make sure when we run a command, we know how potentially impactful it could be. It prevents us from doing something not knowing it could destroy our system, and allows us to understand more intricately how the computer really is working. I know this doesn't sound like \"security\" yet, but we need to build our foundations first.","title":"Rings of Access"},{"location":"LECTURES/unit1/lesson1-3/","text":"Intro to Linux & Commands What is Linux? What are commands? How do I do said commands? Fear not, that's what this lesson is all about! To begin, let's define a seemingly unrelated term: Operating Systems. An operating system is the software that supports the functions of your computer, like executing apps, controlling peripherals like a mouse or keyboard, and scheduling tasks like updates. Examples of this would be Windows 11/10, Linux, MacOS, BSD, Android, ChromeOS, UNIX, etc. We are focusing in on Linux, as Linux gives us the most freedom whilst also being relatively easier to learn that alternatives. By freedom, we mean that with Linux, we can get down to that kernel level access mentioned previously. But what flavor of Linux shall we use? For those who aren't familiar, there are different distributions, or distros of Linux. They're basically different versions of Linux that look and operate differently, but are fundamentally the same overall. The one we'll be using moving forwards is Kali Linux , which is specially designed for penetration testing (future topic) and is Debian-based (means it comes from the Debian version of Linux). Commands So...what exactly is a command? Well, if your parents tell you what to do, like chores, that's a command. Similarly, when we type commands into a terminal emulator , we command the computer to follow through with a sort of chore. But what's a terminal emulator? A terminal emulator is a big scary text box where we type commands in. That's it. ls -> lists files in current directory cat <file> -> spits out whats in the file in plain text mv <source> <destination> -> moves a file to a destination directory touch <file> -> makes the file grep <pattern> <file> -> searches for that pattern in the file. Like if a word appears in it man <command> -> linux manual for this command. How to do this command? help -> Gives you the list of available commands and other useful info sudo <command> -> Gives you super user do permissions. Do this as the admin. cp <source> <destination> -> copy a file to a destination directory cd <directory> -> change to this directory ls -a -> list ALL files, even the hidden ones rm <file> -> removes a file mkdir <directory> -> makes a new directory inside the current working one rm -rf <directory> -> removes all files recursively in a directory (so the directory and everything in it, including subdirectories) rmdir <directory> -> same thing as above command, but a different way of doing it cd -> if you just type \"cd\" it brings you to the home, or ~ directory. This is your starting point We'll be practicing these commands using a Virtual Machine , which is a pretend computer that uses a Virtual Disk. We do this so that we don't have to install on bare metal , which is just your actual computer. Assuming you have your schoolwork, games, and messaging apps and other important files on your main computer, we don't want to erase that. So, we use a Virtual Machine. Unless you want to dual-boot, which is a more advanced technique involving installing multiple operating systems on one computer, but that's a more advanced topic. For practice with commands, you can either run them in a VM, or do so here: Terminal Practice If you want to learn how to install Kali Linux, follow the installation process here: Linux Installation Process","title":"Lesson 1.3"},{"location":"LECTURES/unit1/lesson1-3/#intro-to-linux-commands","text":"What is Linux? What are commands? How do I do said commands? Fear not, that's what this lesson is all about! To begin, let's define a seemingly unrelated term: Operating Systems. An operating system is the software that supports the functions of your computer, like executing apps, controlling peripherals like a mouse or keyboard, and scheduling tasks like updates. Examples of this would be Windows 11/10, Linux, MacOS, BSD, Android, ChromeOS, UNIX, etc. We are focusing in on Linux, as Linux gives us the most freedom whilst also being relatively easier to learn that alternatives. By freedom, we mean that with Linux, we can get down to that kernel level access mentioned previously. But what flavor of Linux shall we use? For those who aren't familiar, there are different distributions, or distros of Linux. They're basically different versions of Linux that look and operate differently, but are fundamentally the same overall. The one we'll be using moving forwards is Kali Linux , which is specially designed for penetration testing (future topic) and is Debian-based (means it comes from the Debian version of Linux).","title":"Intro to Linux &amp; Commands"},{"location":"LECTURES/unit1/lesson1-3/#commands","text":"So...what exactly is a command? Well, if your parents tell you what to do, like chores, that's a command. Similarly, when we type commands into a terminal emulator , we command the computer to follow through with a sort of chore. But what's a terminal emulator? A terminal emulator is a big scary text box where we type commands in. That's it. ls -> lists files in current directory cat <file> -> spits out whats in the file in plain text mv <source> <destination> -> moves a file to a destination directory touch <file> -> makes the file grep <pattern> <file> -> searches for that pattern in the file. Like if a word appears in it man <command> -> linux manual for this command. How to do this command? help -> Gives you the list of available commands and other useful info sudo <command> -> Gives you super user do permissions. Do this as the admin. cp <source> <destination> -> copy a file to a destination directory cd <directory> -> change to this directory ls -a -> list ALL files, even the hidden ones rm <file> -> removes a file mkdir <directory> -> makes a new directory inside the current working one rm -rf <directory> -> removes all files recursively in a directory (so the directory and everything in it, including subdirectories) rmdir <directory> -> same thing as above command, but a different way of doing it cd -> if you just type \"cd\" it brings you to the home, or ~ directory. This is your starting point We'll be practicing these commands using a Virtual Machine , which is a pretend computer that uses a Virtual Disk. We do this so that we don't have to install on bare metal , which is just your actual computer. Assuming you have your schoolwork, games, and messaging apps and other important files on your main computer, we don't want to erase that. So, we use a Virtual Machine. Unless you want to dual-boot, which is a more advanced technique involving installing multiple operating systems on one computer, but that's a more advanced topic. For practice with commands, you can either run them in a VM, or do so here: Terminal Practice If you want to learn how to install Kali Linux, follow the installation process here: Linux Installation Process","title":"Commands"},{"location":"LECTURES/unit2/lesson2-1/","text":"LESSON 3: INTERNET PROTOCOLS How does the Internet work? The internet works by sending packets of information across the network. There are certain technologies that determine how this information is sent and with what. These are called protocols What's a protocol? A protocol is basically just a regulation or ruleset for how certain data is sent. The two we'll talk about are TCP and UDP. TCP, or Transmission Control Protocol, basically sends packets in a way where it's about QUALITY over speed. This means that packets are sent in full functionality, which means that data is reliable and uncorrupted. However, UDP, or User Datagram Protocol, is more about speed and efficiency. TCP is then used in other protocols, like FTP for file transfers, HTTP or HTTPS, which is for displaying web pages, SMTP for emails, etc. UDP is used for things like video game chats, video conferencing like Zoom calls, and VoIP, or Voice over Internet Protocol, which basically means voice chats. This speed but lack of accuracy is what can lead to freezing or stuttering or missing data. When data is sent using TCP, there's this thing called a TCP header, which contains important information that helps routers route where the packet should go, hopping to the right location, and eventually going back. Data reliability vs validity? Data is reliable when it's uncorrupted and functional. But data can be reliable and also invalid. Valid data means accurate data. For example, if I have a text file that contains people's heights and the file is uncorrupted, it's reliable. But if the heights I write down are in seconds, and not in feet or cm, then most likely the data is invalid. What about Networks? In terms of networks, when we connect different computers together, that is an INTERnet. An INTRAnet would be a local network, but an INTERnet would be (usually) across longer distances, and at a large scale. But technically the local network of your home could be called an internet, but that's not what we usually say. There's different network models out there, such as LAN or WLAN, PAN, and there's various security solutions to keep these things safe. A LAN is basically just a local area network of computers. A WLAN is just just a Wide LAN. So a corporate building or a college campus network would be a WLAN (technically there are more specific terminologies for these, but it's fine). A PAN is a Personal Area Network. When you connect peripherals (like a mouse or keyboard) wirelessly, or use your wireless earbuds to listen to music, that is an example of a PAN. A 1-person network with more than one device, interconnected. Security? VPNS, firewalls, and other intrusion prevension systems are used to protect these networks. This is the core of cybersecurity. Keeping our networks safe from attackers. But don't think that these solutions keep you completely anonymous or anything. There's a lot of information out there. We can go more in depth on these later in a future lesson about online anonymity and security. When are we getting to the cool stuff? If you're talking about commands in the terminal...Don't worry. In the next lesson, we're jumping straight into the basics of Kali Linux.","title":"Lesson2 1"},{"location":"LECTURES/unit2/lesson2-1/#lesson-3-internet-protocols","text":"How does the Internet work? The internet works by sending packets of information across the network. There are certain technologies that determine how this information is sent and with what. These are called protocols What's a protocol? A protocol is basically just a regulation or ruleset for how certain data is sent. The two we'll talk about are TCP and UDP. TCP, or Transmission Control Protocol, basically sends packets in a way where it's about QUALITY over speed. This means that packets are sent in full functionality, which means that data is reliable and uncorrupted. However, UDP, or User Datagram Protocol, is more about speed and efficiency. TCP is then used in other protocols, like FTP for file transfers, HTTP or HTTPS, which is for displaying web pages, SMTP for emails, etc. UDP is used for things like video game chats, video conferencing like Zoom calls, and VoIP, or Voice over Internet Protocol, which basically means voice chats. This speed but lack of accuracy is what can lead to freezing or stuttering or missing data. When data is sent using TCP, there's this thing called a TCP header, which contains important information that helps routers route where the packet should go, hopping to the right location, and eventually going back. Data reliability vs validity? Data is reliable when it's uncorrupted and functional. But data can be reliable and also invalid. Valid data means accurate data. For example, if I have a text file that contains people's heights and the file is uncorrupted, it's reliable. But if the heights I write down are in seconds, and not in feet or cm, then most likely the data is invalid. What about Networks? In terms of networks, when we connect different computers together, that is an INTERnet. An INTRAnet would be a local network, but an INTERnet would be (usually) across longer distances, and at a large scale. But technically the local network of your home could be called an internet, but that's not what we usually say. There's different network models out there, such as LAN or WLAN, PAN, and there's various security solutions to keep these things safe. A LAN is basically just a local area network of computers. A WLAN is just just a Wide LAN. So a corporate building or a college campus network would be a WLAN (technically there are more specific terminologies for these, but it's fine). A PAN is a Personal Area Network. When you connect peripherals (like a mouse or keyboard) wirelessly, or use your wireless earbuds to listen to music, that is an example of a PAN. A 1-person network with more than one device, interconnected. Security? VPNS, firewalls, and other intrusion prevension systems are used to protect these networks. This is the core of cybersecurity. Keeping our networks safe from attackers. But don't think that these solutions keep you completely anonymous or anything. There's a lot of information out there. We can go more in depth on these later in a future lesson about online anonymity and security. When are we getting to the cool stuff? If you're talking about commands in the terminal...Don't worry. In the next lesson, we're jumping straight into the basics of Kali Linux.","title":"LESSON 3: INTERNET PROTOCOLS"}]}