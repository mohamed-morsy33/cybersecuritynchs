<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal - NCHS Cybersecurity</title>
    
    
    <link rel="icon" href="../img/logo.png">
    
    
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    
    <!-- Google Analytics -->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DRPQMPQQS6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-DRPQMPQQS6');
    </script>
    
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #141b3a;
            --text-primary: #00ff41;
            --text-secondary: #7affa7;
            --text-muted: #4a9960;
            --accent: #ff0844;
            --accent-secondary: #00d4ff;
            --border: #1a3a2a;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-secondary);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Navigation */
        nav {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--text-primary);
            padding: 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 255, 65, 0.2);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-logo img {
            height: 40px;
            width: auto;
        }

        .nav-logo a {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--text-primary);
            text-decoration: none;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px var(--text-primary);
        }

        .nav-links {
            display: flex;
            gap: 30px;
            list-style: none;
            align-items: center;
        }

        .nav-links > li {
            position: relative;
        }

        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            padding: 8px 15px;
            border-radius: 4px;
            display: block;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--text-primary);
            background: rgba(0, 255, 65, 0.1);
            text-shadow: 0 0 10px var(--text-primary);
        }

        /* Dropdown menu */
        .nav-links .dropdown {
            position: relative;
        }

        .nav-links .dropdown > a::after {
            content: ' ▼';
            font-size: 0.7em;
            margin-left: 5px;
        }

        .nav-links .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-secondary);
            border: 2px solid var(--text-primary);
            border-radius: 4px;
            min-width: 250px;
            box-shadow: 0 8px 30px rgba(0, 255, 65, 0.3);
            z-index: 1000;
            padding: 10px 0;
            margin-top: 5px;
        }

        .nav-links .dropdown:hover .dropdown-content {
            display: block;
        }

        .nav-links .dropdown-content li {
            list-style: none;
        }

        .nav-links .dropdown-content a {
            padding: 10px 20px;
            border-radius: 0;
        }

        .nav-links .dropdown-content .nested {
            padding-left: 20px;
        }

        .nav-links .dropdown-content .nested a {
            padding: 8px 20px;
            font-size: 0.9em;
            color: var(--text-muted);
        }

        .nav-links .dropdown-content .nested a:hover {
            color: var(--text-primary);
            background: rgba(0, 255, 65, 0.05);
        }

        /* Mobile menu toggle */
        .nav-toggle {
            display: none;
            background: none;
            border: 2px solid var(--text-primary);
            color: var(--text-primary);
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
        }

        /* Main Content */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 30px;
        }

        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Orbitron', sans-serif;
            color: var(--text-primary);
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        h1 {
            font-size: 2.5rem;
            text-shadow: 0 0 20px var(--text-primary);
            letter-spacing: 0.05em;
            border-bottom: 2px solid var(--text-primary);
            padding-bottom: 15px;
        }

        h2 {
            font-size: 2rem;
            border-left: 4px solid var(--text-primary);
            padding-left: 15px;
        }

        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.25rem; }

        p {
            margin-bottom: 1.2rem;
            color: var(--text-secondary);
        }

        a {
            color: var(--accent-secondary);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        a:hover {
            color: var(--text-primary);
            text-shadow: 0 0 10px var(--text-primary);
        }

        /* Code Blocks */
        code {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
        }

        pre {
            background: var(--bg-secondary);
            border: 2px solid var(--text-primary);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        pre code {
            background: transparent;
            border: none;
            padding: 0;
        }

        /* Lists */
        ul, ol {
            margin-left: 30px;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        li::marker {
            color: var(--text-primary);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        th {
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 12px;
            text-align: left;
            border: 1px solid var(--text-primary);
            font-weight: 700;
        }

        td {
            padding: 12px;
            border: 1px solid var(--border);
        }

        tr:hover {
            background: rgba(0, 255, 65, 0.05);
        }

        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--text-primary);
            background: var(--bg-secondary);
            padding: 15px 20px;
            margin: 20px 0;
            font-style: italic;
        }

        /* Images */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--text-primary);
            margin: 30px 0;
            opacity: 0.3;
        }

        /* Footer */
        footer {
            background: var(--bg-secondary);
            border-top: 2px solid var(--text-primary);
            padding: 30px;
            margin-top: 60px;
            text-align: center;
            color: var(--text-muted);
        }

        /* Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 255, 65, 0.02) 51%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        /* Selection */
        ::selection {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-primary);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-toggle {
                display: block;
            }

            .nav-links {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: var(--bg-secondary);
                flex-direction: column;
                padding: 20px;
                border-bottom: 2px solid var(--text-primary);
            }

            .nav-links.active {
                display: flex;
            }

            h1 {
                font-size: 2rem;
            }

            .container {
                padding: 20px 15px;
            }
        }

        /* Search Box */
        .search-box {
            padding: 10px;
            background: var(--bg-primary);
            border: 1px solid var(--text-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .search-box::placeholder {
            color: var(--text-muted);
        }

        /* Lesson Navigation */
        .lesson-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 60px 0 40px 0;
            padding: 30px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .lesson-nav-button {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            background: var(--bg-primary);
            border: 2px solid var(--text-primary);
            border-radius: 8px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        .lesson-nav-button:hover {
            background: var(--text-primary);
            color: var(--bg-primary);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.3);
        }

        .lesson-nav-button.disabled {
            opacity: 0.3;
            pointer-events: none;
        }

        .lesson-nav-button .arrow {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .lesson-nav-info {
            text-align: center;
            color: var(--text-secondary);
        }

        .lesson-nav-info .current-lesson {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .lesson-nav-info .lesson-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .lesson-nav {
                flex-direction: column;
                gap: 20px;
            }

            .lesson-nav-button {
                width: 100%;
                justify-content: center;
            }

            .lesson-nav-info {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-container">
            <div class="nav-logo">
                
                <img src="../img/logo.png" alt="Logo">
                
                <a href="https://mohamed-morsy33.github.io/cybersecuritynchs/">NCHS Cybersecurity</a>
            </div>
            
            <button class="nav-toggle" onclick="toggleMenu()">MENU</button>
            
            <ul class="nav-links" id="navLinks">
                
                <li >
                    
                        <a href=".." 
                           >
                            Home
                        </a>
                    
                </li>
                
                <li class="dropdown">
                    
                        <a href="#">Curriculum</a>
                        <ul class="dropdown-content">
                            
                                
                                    <li class="nested">
                                        <strong style="color: var(--text-primary); padding: 10px 20px; display: block;">Unit 1</strong>
                                        
                                        <li class="nested">
                                            <a href="../unit1/">Overview</a>
                                        </li>
                                        
                                        <li class="nested">
                                            <a href="../LECTURES/unit1/lesson1-1/">Lesson 1.1</a>
                                        </li>
                                        
                                        <li class="nested">
                                            <a href="../LECTURES/unit1/lesson1-2/">Lesson 1.2</a>
                                        </li>
                                        
                                        <li class="nested">
                                            <a href="../LECTURES/unit1/lesson1-3/">Lesson 1.3</a>
                                        </li>
                                        
                                        <li class="nested">
                                            <a href="../LECTURES/unit1/installation-process/">Linux Installation Process</a>
                                        </li>
                                        
                                    </li>
                                
                            
                                
                                    <li>
                                        <a href="../unit2/">Unit 2</a>
                                    </li>
                                
                            
                                
                                    <li>
                                        <a href="../unit3/">Unit 3</a>
                                    </li>
                                
                            
                        </ul>
                    
                </li>
                
                <li >
                    
                        <a href="./" 
                           class="active">
                            Terminal
                        </a>
                    
                </li>
                
            </ul>
        </div>
    </nav>

    <div class="container">
        
        <h1 id="terminal">Terminal</h1>
<p>Here's an interactive terminal with full Linux commands:</p>
<p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" /></p>
<div id="terminal-container" class="power-on">
    <div class="terminal-header">
        <div class="terminal-buttons">
            <div class="terminal-button close"></div>
            <div class="terminal-button minimize"></div>
            <div class="terminal-button maximize"></div>
        </div>
    </div>
    <div class="terminal-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script>
(function() {
    setTimeout(function() {
        const container = document.querySelector('.terminal-content');

        if (!container || typeof Terminal === 'undefined') {
            console.error('Terminal setup failed');
            return;
        }

        const term = new Terminal({
            cursorBlink: true,
            fontSize: 15,
            fontFamily: '"Fira Code", "Cascadia Code", "JetBrains Mono", Consolas, Monaco, monospace',
            fontWeight: 400,
            fontWeightBold: 700,
            lineHeight: 1.2,
            letterSpacing: 0,
            theme: {
                background: '#1e1e1e',
                foreground: '#cccccc',
                cursor: '#00ff00',
                cursorAccent: '#1e1e1e',
                selection: '#264f78',
                black: '#000000',
                red: '#cd3131',
                green: '#0dbc79',
                yellow: '#e5e510',
                blue: '#2472c8',
                magenta: '#bc3fbc',
                cyan: '#11a8cd',
                white: '#e5e5e5',
                brightBlack: '#666666',
                brightRed: '#f14c4c',
                brightGreen: '#23d18b',
                brightYellow: '#f5f543',
                brightBlue: '#3b8eea',
                brightMagenta: '#d670d6',
                brightCyan: '#29b8db',
                brightWhite: '#ffffff'
            },
            allowTransparency: true
        });

        term.open(container);

        // Enhanced file system
        let fileSystem = {
            '/': {
                'home': {
                    'user': {
                        'documents': {
                            'notes.txt': 'These are my personal notes.\nRemember to study for the exam!',
                            'todo.txt': '1. Finish homework\n2. Practice CTF\n3. Read security blog'
                        },
                        'projects': {
                            'cybersec': {
                                'README.md': '# CyberSec Project\n\nThis is a cybersecurity learning project.',
                                'exploit.py': '#!/usr/bin/env python3\nprint("Hello, hacker!")'
                            },
                            'web': {
                                'index.html': '<html><body>Hello World</body></html>'
                            }
                        },
                        'scripts': {
                            'hello.sh': '#!/bin/bash\necho "Hello, World!"'
                        }
                    }
                },
                'etc': {
                    'hosts': '127.0.0.1 localhost\n::1 localhost',
                    'passwd': 'root:x:0:0:root:/root:/bin/bash\nuser:x:1000:1000::/home/user:/bin/bash'
                },
                'var': {
                    'log': {
                        'syslog': 'System log entries...'
                    }
                },
                'tmp': {}
            }
        };

        let currentPath = '/home/user';
        let currentLine = '';
        let commandHistory = [];
        let historyIndex = -1;
        let vimMode = false;
        let vimBuffer = [];
        let vimCurrentLine = 0;
        let vimFilename = '';
        let vimInsertMode = false;
        let vimCommandMode = false;
        let vimCommandLine = '';

        term.writeln('\x1b[1;32m╔═══════════════════════════════════════════════╗\x1b[0m');
        term.writeln('\x1b[1;32m║    Welcome to Interactive Terminal Demo       ║\x1b[0m');
        term.writeln('\x1b[1;32m╚═══════════════════════════════════════════════╝\x1b[0m');
        term.writeln('');
        term.writeln('Type \x1b[1;36mhelp\x1b[0m for available commands.');
        term.writeln('');
        writePrompt();

        function writePrompt() {
            term.write(`\x1b[1;32muser@nchscyber\x1b[0m:\x1b[1;34m${currentPath}\x1b[0m$ `);
        }

        function getObjectAtPath(path) {
            if (path === '/') return fileSystem['/'];

            const parts = path.split('/').filter(p => p);
            let current = fileSystem['/'];

            for (const part of parts) {
                if (!current || current[part] === undefined) {
                    return null;
                }
                current = current[part];
            }
            return current;
        }

        function resolvePath(path) {
            if (path.startsWith('/')) {
                return path;
            }

            if (path === '~') {
                return '/home/user';
            }

            if (path.startsWith('~/')) {
                return '/home/user/' + path.substring(2);
            }

            let result = currentPath;
            const parts = path.split('/');

            for (const part of parts) {
                if (part === '..') {
                    const segments = result.split('/').filter(p => p);
                    segments.pop();
                    result = '/' + segments.join('/');
                    if (result === '/') result = '/';
                } else if (part === '.' || part === '') {
                    continue;
                } else {
                    result = result + (result.endsWith('/') ? '' : '/') + part;
                }
            }

            return result;
        }

        function isDirectory(obj) {
            return obj !== null && typeof obj === 'object' && !Array.isArray(obj);
        }

        function processCommand(cmd) {
            // Handle pipes
            if (cmd.includes('|')) {
                const parts = cmd.split('|').map(p => p.trim());
                let output = null;

                for (let i = 0; i < parts.length; i++) {
                    if (i === 0) {
                        output = executeCommand(parts[i]);
                    } else {
                        output = executeCommand(parts[i], output);
                    }
                }
                return;
            }

            // Handle output redirection
            if (cmd.includes('>')) {
                const parts = cmd.split('>').map(p => p.trim());
                const output = executeCommand(parts[0]);

                if (output && parts[1]) {
                    const filepath = resolvePath(parts[1]);
                    const pathParts = filepath.split('/').filter(p => p);
                    const filename = pathParts.pop();
                    const dirPath = '/' + pathParts.join('/');

                    const dir = getObjectAtPath(dirPath || '/');
                    if (dir && isDirectory(dir)) {
                        dir[filename] = output.join('\n');
                        term.writeln(`\x1b[32mOutput written to ${parts[1]}\x1b[0m`);
                    } else {
                        term.writeln(`\x1b[31mError: Directory not found\x1b[0m`);
                    }
                }
                return;
            }

            executeCommand(cmd);
        }

        function executeCommand(cmd, pipeInput = null) {
            const parts = cmd.split(' ').filter(p => p);
            const command = parts[0];
            const args = parts.slice(1);

            const commands = {
                'help': () => {
                    const output = [
                        '\x1b[1;33mAvailable Commands:\x1b[0m',
                        '  \x1b[36mhelp\x1b[0m       - Show this help message',
                        '  \x1b[36mclear\x1b[0m      - Clear the terminal screen',
                        '  \x1b[36mecho\x1b[0m       - Print text to terminal',
                        '  \x1b[36mdate\x1b[0m       - Show current date and time',
                        '  \x1b[36mpwd\x1b[0m        - Print working directory',
                        '  \x1b[36mls\x1b[0m         - List directory contents',
                        '  \x1b[36mcd\x1b[0m         - Change directory',
                        '  \x1b[36mmkdir\x1b[0m      - Create a new directory',
                        '  \x1b[36mrmdir\x1b[0m      - Remove empty directory',
                        '  \x1b[36mtouch\x1b[0m      - Create a new file',
                        '  \x1b[36mcat\x1b[0m        - Display file contents',
                        '  \x1b[36mrm\x1b[0m         - Remove file or directory',
                        '  \x1b[36mmv\x1b[0m         - Move/rename files',
                        '  \x1b[36mcp\x1b[0m         - Copy files',
                        '  \x1b[36mgrep\x1b[0m       - Search for patterns',
                        '  \x1b[36mfind\x1b[0m       - Find files',
                        '  \x1b[36mwhoami\x1b[0m     - Display current user',
                        '  \x1b[36muname\x1b[0m      - Display system information',
                        '  \x1b[36mvim\x1b[0m        - Text editor',
                        '',
                        '\x1b[1;33mAdvanced:\x1b[0m',
                        '  Use \x1b[36m|\x1b[0m for pipes: ls | grep test',
                        '  Use \x1b[36m>\x1b[0m for output: echo hello > file.txt'
                    ];
                    output.forEach(line => term.writeln(line));
                    return output;
                },

                'clear': () => {
                    term.clear();
                    return [];
                },

                'date': () => {
                    const output = [new Date().toString()];
                    term.writeln(output[0]);
                    return output;
                },

                'pwd': () => {
                    const output = [currentPath];
                    term.writeln(output[0]);
                    return output;
                },

                'whoami': () => {
                    const output = ['user'];
                    term.writeln(output[0]);
                    return output;
                },

                'uname': () => {
                    const output = args[0] === '-a' 
                        ? ['Linux nchscyber 5.15.0 #1 SMP x86_64 GNU/Linux']
                        : ['Linux'];
                    term.writeln(output[0]);
                    return output;
                },

                'ls': () => {
                    const path = args[0] ? resolvePath(args[0]) : currentPath;
                    const obj = getObjectAtPath(path);
                    const output = [];

                    if (!obj) {
                        term.writeln(`\x1b[31mls: ${args[0]}: No such file or directory\x1b[0m`);
                        return [];
                    }

                    if (!isDirectory(obj)) {
                        term.writeln(`\x1b[31mls: ${args[0]}: Not a directory\x1b[0m`);
                        return [];
                    }

                    const entries = Object.keys(obj);
                    if (entries.length === 0) {
                        return [];
                    }

                    entries.forEach(entry => {
                        if (isDirectory(obj[entry])) {
                            term.writeln(`\x1b[1;34m${entry}/\x1b[0m`);
                            output.push(entry + '/');
                        } else {
                            term.writeln(`\x1b[37m${entry}\x1b[0m`);
                            output.push(entry);
                        }
                    });

                    return output;
                },

                'cd': () => {
                    if (args.length === 0 || args[0] === '~') {
                        currentPath = '/home/user';
                        return [];
                    }

                    const newPath = resolvePath(args[0]);
                    const obj = getObjectAtPath(newPath);

                    if (obj && isDirectory(obj)) {
                        currentPath = newPath;
                    } else {
                        term.writeln(`\x1b[31mcd: ${args[0]}: No such directory\x1b[0m`);
                    }
                    return [];
                },

                'mkdir': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: mkdir <directory_name>\x1b[0m');
                        return [];
                    }

                    const path = resolvePath(args[0]);
                    const pathParts = path.split('/').filter(p => p);
                    const dirName = pathParts.pop();
                    const parentPath = '/' + pathParts.join('/');

                    const parent = getObjectAtPath(parentPath || '/');
                    if (parent && isDirectory(parent)) {
                        if (parent[dirName]) {
                            term.writeln(`\x1b[31mmkdir: ${args[0]}: File exists\x1b[0m`);
                        } else {
                            parent[dirName] = {};
                            term.writeln(`\x1b[32mDirectory '${args[0]}' created\x1b[0m`);
                        }
                    } else {
                        term.writeln(`\x1b[31mmkdir: cannot create directory '${args[0]}': No such file or directory\x1b[0m`);
                    }
                    return [];
                },

                'rmdir': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: rmdir <directory_name>\x1b[0m');
                        return [];
                    }

                    const path = resolvePath(args[0]);
                    const pathParts = path.split('/').filter(p => p);
                    const dirName = pathParts.pop();
                    const parentPath = '/' + pathParts.join('/');

                    const parent = getObjectAtPath(parentPath || '/');
                    if (parent && parent[dirName]) {
                        if (isDirectory(parent[dirName])) {
                            if (Object.keys(parent[dirName]).length === 0) {
                                delete parent[dirName];
                                term.writeln(`\x1b[32mDirectory '${args[0]}' removed\x1b[0m`);
                            } else {
                                term.writeln(`\x1b[31mrmdir: ${args[0]}: Directory not empty\x1b[0m`);
                            }
                        } else {
                            term.writeln(`\x1b[31mrmdir: ${args[0]}: Not a directory\x1b[0m`);
                        }
                    } else {
                        term.writeln(`\x1b[31mrmdir: ${args[0]}: No such directory\x1b[0m`);
                    }
                    return [];
                },

                'touch': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: touch <filename>\x1b[0m');
                        return [];
                    }

                    const path = resolvePath(args[0]);
                    const pathParts = path.split('/').filter(p => p);
                    const fileName = pathParts.pop();
                    const dirPath = '/' + pathParts.join('/');

                    const dir = getObjectAtPath(dirPath || currentPath);
                    if (dir && isDirectory(dir)) {
                        dir[fileName] = dir[fileName] || '';
                        term.writeln(`\x1b[32mFile '${args[0]}' created\x1b[0m`);
                    } else {
                        term.writeln(`\x1b[31mtouch: cannot touch '${args[0]}': No such file or directory\x1b[0m`);
                    }
                    return [];
                },

                'cat': () => {
                    if (pipeInput !== null) {
                        pipeInput.forEach(line => term.writeln(line));
                        return pipeInput;
                    }

                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: cat <filename>\x1b[0m');
                        return [];
                    }

                    const path = resolvePath(args[0]);
                    const pathParts = path.split('/').filter(p => p);
                    const fileName = pathParts.pop();
                    const dirPath = '/' + pathParts.join('/');

                    const dir = getObjectAtPath(dirPath || '/');
                    if (dir && dir[fileName] !== undefined) {
                        if (typeof dir[fileName] === 'string') {
                            const output = dir[fileName].split('\n');
                            output.forEach(line => term.writeln(line));
                            return output;
                        } else {
                            term.writeln(`\x1b[31mcat: ${args[0]}: Is a directory\x1b[0m`);
                        }
                    } else {
                        term.writeln(`\x1b[31mcat: ${args[0]}: No such file or directory\x1b[0m`);
                    }
                    return [];
                },

                'rm': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: rm [-r] <file_or_directory>\x1b[0m');
                        return [];
                    }

                    const recursive = args[0] === '-r' || args[0] === '-rf';
                    const target = recursive ? args[1] : args[0];

                    if (!target) {
                        term.writeln('\x1b[31mUsage: rm [-r] <file_or_directory>\x1b[0m');
                        return [];
                    }

                    const path = resolvePath(target);
                    const pathParts = path.split('/').filter(p => p);
                    const name = pathParts.pop();
                    const parentPath = '/' + pathParts.join('/');

                    const parent = getObjectAtPath(parentPath || '/');
                    if (parent && parent[name] !== undefined) {
                        if (isDirectory(parent[name]) && !recursive) {
                            term.writeln(`\x1b[31mrm: ${target}: is a directory (use -r to remove)\x1b[0m`);
                        } else {
                            delete parent[name];
                            term.writeln(`\x1b[32m'${target}' removed\x1b[0m`);
                        }
                    } else {
                        term.writeln(`\x1b[31mrm: ${target}: No such file or directory\x1b[0m`);
                    }
                    return [];
                },

                'mv': () => {
                    if (args.length < 2) {
                        term.writeln('\x1b[31mUsage: mv <source> <destination>\x1b[0m');
                        return [];
                    }

                    const srcPath = resolvePath(args[0]);
                    const dstPath = resolvePath(args[1]);

                    const srcParts = srcPath.split('/').filter(p => p);
                    const srcName = srcParts.pop();
                    const srcParentPath = '/' + srcParts.join('/');

                    const dstParts = dstPath.split('/').filter(p => p);
                    const dstName = dstParts.pop();
                    const dstParentPath = '/' + dstParts.join('/');

                    const srcParent = getObjectAtPath(srcParentPath || '/');
                    const dstParent = getObjectAtPath(dstParentPath || '/');

                    if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) {
                        dstParent[dstName] = srcParent[srcName];
                        delete srcParent[srcName];
                        term.writeln(`\x1b[32m'${args[0]}' moved to '${args[1]}'\x1b[0m`);
                    } else {
                        term.writeln(`\x1b[31mmv: cannot move '${args[0]}' to '${args[1]}'\x1b[0m`);
                    }
                    return [];
                },

                'cp': () => {
                    if (args.length < 2) {
                        term.writeln('\x1b[31mUsage: cp <source> <destination>\x1b[0m');
                        return [];
                    }

                    const srcPath = resolvePath(args[0]);
                    const dstPath = resolvePath(args[1]);

                    const srcParts = srcPath.split('/').filter(p => p);
                    const srcName = srcParts.pop();
                    const srcParentPath = '/' + srcParts.join('/');

                    const dstParts = dstPath.split('/').filter(p => p);
                    const dstName = dstParts.pop();
                    const dstParentPath = '/' + dstParts.join('/');

                    const srcParent = getObjectAtPath(srcParentPath || '/');
                    const dstParent = getObjectAtPath(dstParentPath || '/');

                    if (srcParent && srcParent[srcName] !== undefined && dstParent && isDirectory(dstParent)) {
                        if (typeof srcParent[srcName] === 'string') {
                            dstParent[dstName] = srcParent[srcName];
                            term.writeln(`\x1b[32m'${args[0]}' copied to '${args[1]}'\x1b[0m`);
                        } else {
                            term.writeln(`\x1b[31mcp: ${args[0]}: Is a directory (directory copy not implemented)\x1b[0m`);
                        }
                    } else {
                        term.writeln(`\x1b[31mcp: cannot copy '${args[0]}' to '${args[1]}'\x1b[0m`);
                    }
                    return [];
                },

                'grep': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: grep <pattern> [file] or <command> | grep <pattern>\x1b[0m');
                        return [];
                    }

                    const pattern = args[0];
                    let searchLines = [];

                    if (pipeInput !== null) {
                        searchLines = pipeInput;
                    } else if (args[1]) {
                        const path = resolvePath(args[1]);
                        const pathParts = path.split('/').filter(p => p);
                        const fileName = pathParts.pop();
                        const dirPath = '/' + pathParts.join('/');
                        const dir = getObjectAtPath(dirPath || '/');

                        if (dir && typeof dir[fileName] === 'string') {
                            searchLines = dir[fileName].split('\n');
                        }
                    }

                    const output = searchLines.filter(line => 
                        line.toLowerCase().includes(pattern.toLowerCase())
                    );

                    output.forEach(line => term.writeln(line));
                    return output;
                },

                'find': () => {
                    const searchName = args[0] || '';
                    const output = [];

                    function searchDir(path, obj) {
                        if (!isDirectory(obj)) return;

                        for (const [name, value] of Object.entries(obj)) {
                            const fullPath = path + (path === '/' ? '' : '/') + name;

                            if (name.includes(searchName)) {
                                output.push(fullPath);
                                term.writeln(fullPath);
                            }

                            if (isDirectory(value)) {
                                searchDir(fullPath, value);
                            }
                        }
                    }

                    searchDir('/', fileSystem['/']);
                    return output;
                },

                'echo': () => {
                    const output = [args.join(' ')];
                    term.writeln(output[0]);
                    return output;
                },

                'vim': () => {
                    if (args.length === 0) {
                        term.writeln('\x1b[31mUsage: vim <filename>\x1b[0m');
                        return [];
                    }

                    vimFilename = args[0];
                    const path = resolvePath(vimFilename);
                    const pathParts = path.split('/').filter(p => p);
                    const fileName = pathParts.pop();
                    const dirPath = '/' + pathParts.join('/');
                    const dir = getObjectAtPath(dirPath || currentPath);

                    if (dir && dir[fileName] !== undefined) {
                        if (typeof dir[fileName] === 'string') {
                            vimBuffer = dir[fileName].split('\n');
                        } else {
                            term.writeln(`\x1b[31mvim: ${vimFilename}: Is a directory\x1b[0m`);
                            return [];
                        }
                    } else {
                        vimBuffer = [''];
                    }

                    vimMode = true;
                    vimInsertMode = false;
                    vimCommandMode = false;
                    vimCommandLine = '';
                    vimCurrentLine = 0;
                    displayVim();
                    return [];
                }
            };

            if (commands[command]) {
                return commands[command]();
            } else {
                term.writeln(`\x1b[31m${command}: command not found\x1b[0m`);
                return [];
            }
        }

        function displayVim() {
            term.clear();

            vimBuffer.forEach((line, i) => {
                if (i === vimCurrentLine && !vimCommandMode) {
                    term.writeln(`\x1b[7m${line || ' '}\x1b[0m`);
                } else {
                    term.writeln(line);
                }
            });

            term.write('\r\n');
            const mode = vimInsertMode ? '-- INSERT --' : (vimCommandMode ? '' : '-- NORMAL --');
            const status = `\x1b[7m ${vimFilename} [${vimBuffer.length} lines] ${mode} \x1b[0m`;
            term.writeln(status);

            if (!vimInsertMode && !vimCommandMode) {
                term.writeln('\x1b[33m[i=insert, j/k=move, :w=save, :q=quit, :wq=save&quit]\x1b[0m');
            }

            if (vimCommandMode) {
                term.write(':' + vimCommandLine);
            }
        }

        function handleVimInput(key, domEvent) {
            if (vimCommandMode) {
                if (domEvent.key === 'Enter') {
                    term.write('\r\n');

                    if (vimCommandLine === 'w' || vimCommandLine === 'wq') {
                        const path = resolvePath(vimFilename);
                        const pathParts = path.split('/').filter(p => p);
                        const fileName = pathParts.pop();
                        const dirPath = '/' + pathParts.join('/');
                        const dir = getObjectAtPath(dirPath || currentPath);

                        if (dir) {
                            dir[fileName] = vimBuffer.join('\n');
                            term.writeln(`\x1b[32m"${vimFilename}" ${vimBuffer.length} lines written\x1b[0m`);
                        }
                    }

                    if (vimCommandLine === 'q' || vimCommandLine === 'wq' || vimCommandLine === 'q!') {
                        vimMode = false;
                        setTimeout(() => {
                            term.clear();
                            writePrompt();
                        }, vimCommandLine === 'wq' ? 800 : 0);
                    } else {
                        setTimeout(() => displayVim(), 1000);
                    }

                    vimCommandMode = false;
                    vimCommandLine = '';
                } else if (domEvent.key === 'Escape') {
                    vimCommandMode = false;
                    vimCommandLine = '';
                    displayVim();
                } else if (domEvent.key === 'Backspace') {
                    if (vimCommandLine.length > 0) {
                        vimCommandLine = vimCommandLine.slice(0, -1);
                        displayVim();
                    }
                } else if (key.length === 1) {
                    vimCommandLine += key;
                    displayVim();
                }
            } else if (!vimInsertMode) {
                if (key === 'i') {
                    vimInsertMode = true;
                    displayVim();
                } else if (key === 'j' && vimCurrentLine < vimBuffer.length - 1) {
                    vimCurrentLine++;
                    displayVim();
                } else if (key === 'k' && vimCurrentLine > 0) {
                    vimCurrentLine--;
                    displayVim();
                } else if (key === ':') {
                    vimCommandMode = true;
                    displayVim();
                }
            } else {
                if (domEvent.key === 'Escape') {
                    vimInsertMode = false;
                    displayVim();
                } else if (domEvent.key === 'Enter') {
                    vimBuffer.splice(vimCurrentLine + 1, 0, '');
                    vimCurrentLine++;
                    displayVim();
                } else if (domEvent.key === 'Backspace') {
                    if (vimBuffer[vimCurrentLine].length > 0) {
                        vimBuffer[vimCurrentLine] = vimBuffer[vimCurrentLine].slice(0, -1);
                    } else if (vimCurrentLine > 0) {
                        vimBuffer.splice(vimCurrentLine, 1);
                        vimCurrentLine--;
                    }
                    displayVim();
                } else if (key.length === 1) {
                    vimBuffer[vimCurrentLine] = (vimBuffer[vimCurrentLine] || '') + key;
                    displayVim();
                }
            }
        }

        term.onKey(function(e) {
            if (vimMode) {
                handleVimInput(e.key, e.domEvent);
                return;
            }

            const ev = e.domEvent;
            const printable = !ev.altKey && !ev.ctrlKey && !ev.metaKey;

            if (ev.key === 'Enter') {
                term.write('\r\n');

                if (currentLine.trim()) {
                    commandHistory.push(currentLine.trim());
                    historyIndex = commandHistory.length;
                    processCommand(currentLine.trim());
                }

                currentLine = '';
                if (!vimMode) {
                    writePrompt();
                }
            } else if (ev.key === 'Backspace') {
                if (currentLine.length > 0) {
                    currentLine = currentLine.slice(0, -1);
                    term.write('\b \b');
                }
            } else if (ev.key === 'ArrowUp') {
                if (historyIndex > 0) {
                    historyIndex--;
                    replaceCurrentLine(commandHistory[historyIndex]);
                }
            } else if (ev.key === 'ArrowDown') {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    replaceCurrentLine(commandHistory[historyIndex]);
                } else {
                    historyIndex = commandHistory.length;
                    replaceCurrentLine('');
                }
            } else if (ev.key === 'Tab') {
                ev.preventDefault();
            } else if (printable) {
                currentLine += e.key;
                term.write(e.key);
            }
        });

        function replaceCurrentLine(newLine) {
            term.write('\r');
            writePrompt();
            term.write(' '.repeat(currentLine.length));
            term.write('\r');
            writePrompt();
            currentLine = newLine;
            term.write(currentLine);
        }

    }, 100);
})();
</script>
        

        <!-- Lesson Navigation (only show on non-homepage pages) -->
        
        <div class="lesson-nav">
            
            <a href="../unit3/" class="lesson-nav-button">
                <span class="arrow">←</span>
                <span>Previous: Unit 3</span>
            </a>
            

            <div class="lesson-nav-info">
                <div class="current-lesson">Current Lesson</div>
                <div class="lesson-title">Terminal</div>
            </div>

            
            <div class="lesson-nav-button disabled">
                <span>Next</span>
                <span class="arrow">→</span>
            </div>
            
        </div>
        
    </div>

    <footer>
        <p>NCHS Cybersecurity | Built with MkDocs</p>
        
        <p>Copyright &copy; 2025 Mohamed Morsy</p>
        
    </footer>

    <!-- Xterm.js for terminal -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    
    <script>
        function toggleMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('active');
        }

        // Highlight.js integration if enabled
        
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('pre code').forEach((block) => {
                // Add terminal-like styling
                block.parentElement.style.position = 'relative';
            });
        });
        
    </script>
</body>
</html>